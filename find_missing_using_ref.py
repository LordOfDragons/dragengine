#!/usr/bin/env python3
"""
Scan C++ source files for usage of ClassName::Ref where the class is missing
a 'using Ref = ...' or 'typedef ... Ref;' declaration.

This script detects cases where code uses ClassName::Ref in variable declarations
or class members, but the class ClassName doesn't have the required Ref type alias.

This script has been generated by copilot.
"""

import os
import re
import sys
from pathlib import Path
from typing import Set, Dict, List, Tuple


class RefDeclarationScanner:
    def __init__(self, scan_dir: str, repo_root: str = None):
        self.scan_dir = Path(scan_dir)
        self.repo_root = Path(repo_root) if repo_root else self.scan_dir
        self.classes_with_ref: Set[str] = set()  # Classes that have Ref declaration
        
    def find_cpp_files(self, directory: Path) -> List[Path]:
        """Find all C++ source and header files."""
        patterns = ['**/*.cpp', '**/*.h', '**/*.hpp']
        files = []
        for pattern in patterns:
            files.extend(directory.glob(pattern))
        return files
    
    def extract_ref_declarations(self, file_path: Path) -> List[str]:
        """Extract classes that have Ref typedef or using declarations."""
        classes = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
        except Exception as e:
            return classes
        
        # Match typedef declarations: typedef ... Ref;
        # Examples:
        #   typedef deTObjectReference<ClassName> Ref;
        #   typedef deTThreadSafeObjectReference<ClassName> Ref;
        #   typedef std::shared_ptr<ClassName> Ref;
        typedef_pattern = re.compile(
            r'typedef\s+[\w:]+\s*<\s*(\w+)\s*>\s+Ref\s*;',
            re.MULTILINE
        )
        
        for match in typedef_pattern.finditer(content):
            class_name = match.group(1)
            classes.append(class_name)
        
        # Match using declarations: using Ref = ...;
        # Examples:
        #   using Ref = deTObjectReference<ClassName>;
        #   using Ref = std::shared_ptr<ClassName>;
        using_pattern = re.compile(
            r'using\s+Ref\s*=\s*[\w:]+\s*<\s*(\w+)\s*>\s*;',
            re.MULTILINE
        )
        
        for match in using_pattern.finditer(content):
            class_name = match.group(1)
            classes.append(class_name)
        
        return classes
    
    def build_ref_declarations_index(self, files: List[Path]):
        """Build index of all classes that have Ref declarations."""
        print("Building index of classes with Ref declarations...")
        
        for file_path in files:
            classes = self.extract_ref_declarations(file_path)
            for class_name in classes:
                self.classes_with_ref.add(class_name)
        
        print(f"Found {len(self.classes_with_ref)} classes with Ref declarations")
    
    def find_ref_usage(self, file_path: Path) -> List[Tuple[int, str, str]]:
        """Find uses of 'ClassName::Ref' where ClassName doesn't have Ref declaration."""
        violations = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
        except Exception as e:
            return violations
        
        # First, check for local Ref declarations in this file
        local_classes_with_ref = set()
        content = ''.join(lines)
        
        # Find typedef declarations in this file
        typedef_pattern = re.compile(
            r'typedef\s+[\w:]+\s*<\s*(\w+)\s*>\s+Ref\s*;',
            re.MULTILINE
        )
        for match in typedef_pattern.finditer(content):
            local_classes_with_ref.add(match.group(1))
        
        # Find using declarations in this file
        using_pattern = re.compile(
            r'using\s+Ref\s*=\s*[\w:]+\s*<\s*(\w+)\s*>\s*;',
            re.MULTILINE
        )
        for match in using_pattern.finditer(content):
            local_classes_with_ref.add(match.group(1))
        
        # Pattern to match ClassName::Ref usage
        # Examples:
        #   ClassName::Ref variable;
        #   const ClassName::Ref variable;
        #   ClassName::Ref variable(arg);
        #   function returning: ClassName::Ref FunctionName()
        #   member variable: ClassName::Ref pMember;
        ref_usage_pattern = re.compile(r'\b(\w+)::Ref\b')
        
        for line_num, line in enumerate(lines, 1):
            # Skip comments
            stripped = line.strip()
            if stripped.startswith('//') or stripped.startswith('*') or stripped.startswith('/*'):
                continue
            
            # Remove single-line comments
            code_part = line.split('//', 1)[0]
            
            # Find all 'ClassName::Ref' patterns
            for match in ref_usage_pattern.finditer(code_part):
                class_name = match.group(1)
                
                # Check if this class has a Ref declaration
                # Skip common non-class identifiers
                if class_name in ('std', 'boost', 'decString'):
                    continue
                
                # Skip classes from external libraries (prefixed with 'derl' for deremotelauncher)
                # These are external dependencies with their own type definitions
                if class_name.startswith('derl'):
                    continue
                
                # Check both global index and local file declarations
                if class_name not in self.classes_with_ref and class_name not in local_classes_with_ref:
                    violations.append((line_num, class_name, line.rstrip()))
        
        return violations
    
    def should_exclude_file(self, file_path, exclude_dirs):
        """
        Check if a file should be excluded based on top-level directory exclusions.
        Only excludes if the file is directly under repo_root/excluded_dir.
        """
        try:
            # Get the relative path from repo root
            rel_path = file_path.relative_to(self.repo_root)
            # Get the top-level directory (first part of relative path)
            if len(rel_path.parts) > 0:
                top_dir = rel_path.parts[0]
                return top_dir in exclude_dirs
        except ValueError:
            # File is not under repo_root
            pass
        return False
    
    def scan(self, exclude_dirs: Set[str] = None):
        """Scan all source files for missing Ref declarations."""
        if exclude_dirs is None:
            exclude_dirs = {'.git', 'build', 'extern', '.vs', '__pycache__'}
        
        # When building index, include extern to find external library Ref declarations
        exclude_dirs_for_index = exclude_dirs - {'extern'}
        
        # First, build index from all header files in the repository
        print("Building index from repository headers...")
        all_header_files = []
        for item in self.repo_root.rglob('*.h'):
            if not self.should_exclude_file(item, exclude_dirs_for_index):
                all_header_files.append(item)
        
        for item in self.repo_root.rglob('*.hpp'):
            if not self.should_exclude_file(item, exclude_dirs_for_index):
                all_header_files.append(item)
        
        print(f"Found {len(all_header_files)} header files in repository")
        self.build_ref_declarations_index(all_header_files)
        
        # Now find all C++ files in the scan directory
        print(f"\nScanning directory: {self.scan_dir}")
        scan_files = []
        for item in self.scan_dir.rglob('*'):
            if item.is_file() and item.suffix in ('.cpp', '.h', '.hpp'):
                # Check if any excluded directory is in the path
                if not self.should_exclude_file(item, exclude_dirs):
                    scan_files.append(item)
        
        print(f"Found {len(scan_files)} C++ files to scan for violations")
        
        # Scan for violations
        print("\nScanning for missing Ref declarations...")
        total_violations = 0
        files_with_violations = 0
        violation_details = []
        
        for file_path in scan_files:
            violations = self.find_ref_usage(file_path)
            
            if violations:
                files_with_violations += 1
                total_violations += len(violations)
                
                for line_num, class_name, line in violations:
                    violation_details.append((file_path, line_num, class_name, line))
        
        # Group violations by class name for better reporting
        violations_by_class: Dict[str, List[Tuple[Path, int, str]]] = {}
        for file_path, line_num, class_name, line in violation_details:
            if class_name not in violations_by_class:
                violations_by_class[class_name] = []
            violations_by_class[class_name].append((file_path, line_num, line))
        
        # Print violations grouped by class
        for class_name in sorted(violations_by_class.keys()):
            print(f"\nClass '{class_name}' missing Ref declaration:")
            for file_path, line_num, line in violations_by_class[class_name]:
                print(f"  {file_path}:{line_num}: {line.strip()}")
        
        print(f"\n{'='*70}")
        print(f"Summary:")
        print(f"  Total files scanned: {len(scan_files)}")
        print(f"  Files with violations: {files_with_violations}")
        print(f"  Total violations: {total_violations}")
        print(f"  Classes missing Ref: {len(violations_by_class)}")
        print(f"{'='*70}")
        
        if total_violations > 0:
            print("\nRecommendation: Add 'using Ref = deTObjectReference<ClassName>;' to class definition")
            return 1
        else:
            print("\nNo violations found!")
            return 0


def main():
    """Main entry point."""
    # Get the repository root (where this script is located)
    repo_root = Path(__file__).parent
    
    # Allow specifying a different directory as command-line argument
    if len(sys.argv) > 1:
        scan_dir = Path(sys.argv[1])
        if not scan_dir.is_absolute():
            scan_dir = repo_root / scan_dir
    else:
        scan_dir = repo_root
    
    if not scan_dir.exists():
        print(f"Error: Directory {scan_dir} does not exist")
        sys.exit(1)
    
    scanner = RefDeclarationScanner(scan_dir, repo_root)
    
    # Exclude certain directories
    exclude_dirs = {
        '.git', 
        'build', 
        'extern',  # External dependencies
        '.vs',     # Visual Studio files
        '__pycache__',
        'vs',      # Visual Studio project files
        'installer',
        'ghdocs'
    }
    
    exit_code = scanner.scan(exclude_dirs)
    sys.exit(exit_code)


if __name__ == '__main__':
    main()
