#!/usr/bin/env python3
"""
Scan C++ source files for prohibited use of 'new' operator with reference-counted classes.

This script detects cases where classes deriving from deObject or deThreadSafeObject
are instantiated using 'new ClassName' instead of the proper 'ClassName::Ref::New()'.

This script has been generated by copilot.
"""

import os
import re
import sys
from pathlib import Path
from typing import Set, Dict, List, Tuple


class RefCountedClassScanner:
    def __init__(self, scan_dir: str, repo_root: str = None):
        self.scan_dir = Path(scan_dir)
        self.repo_root = Path(repo_root) if repo_root else self.scan_dir
        self.ref_counted_classes: Set[str] = set()
        self.class_hierarchy: Dict[str, str] = {}  # child -> parent
        
    def find_cpp_files(self, directory: Path) -> List[Path]:
        """Find all C++ source and header files."""
        patterns = ['**/*.cpp', '**/*.h', '**/*.hpp']
        files = []
        for pattern in patterns:
            files.extend(directory.glob(pattern))
        return files
    
    def extract_class_inheritance(self, file_path: Path) -> List[Tuple[str, str]]:
        """Extract class inheritance relationships from a file."""
        relationships = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
        except Exception as e:
            return relationships
        
        # Match class declarations with inheritance
        # Matches: class ClassName : public BaseClass
        # Also handles DLL export macros and various spacing
        class_pattern = re.compile(
            r'class\s+(?:\w+\s+)?(\w+)\s*:\s*(?:public|protected|private)\s+(\w+(?:\s*,\s*(?:public|protected|private)\s+\w+)*)',
            re.MULTILINE
        )
        
        for match in class_pattern.finditer(content):
            class_name = match.group(1)
            bases_str = match.group(2)
            
            # Extract all base classes
            # The bases_str might be just "BaseClass" or "BaseClass, public OtherBase"
            base_pattern = re.compile(r'(?:(?:public|protected|private)\s+)?(\w+)')
            for base_match in base_pattern.finditer(bases_str):
                base_name = base_match.group(1)
                if base_name and base_name not in ('public', 'protected', 'private'):
                    relationships.append((class_name, base_name))
        
        return relationships
    
    def is_ref_counted(self, class_name: str) -> bool:
        """Check if a class is reference-counted by traversing hierarchy."""
        if class_name in self.ref_counted_classes:
            return True
        
        # Traverse up the hierarchy
        visited = set()
        current = class_name
        
        while current and current not in visited:
            visited.add(current)
            
            if current in ('deObject', 'deThreadSafeObject'):
                return True
            
            current = self.class_hierarchy.get(current)
        
        return False
    
    def build_class_hierarchy(self, files: List[Path]):
        """Build the class inheritance hierarchy."""
        print("Building class hierarchy...")
        
        # First, mark the known base classes
        self.ref_counted_classes.add('deObject')
        self.ref_counted_classes.add('deThreadSafeObject')
        
        for file_path in files:
            relationships = self.extract_class_inheritance(file_path)
            for child, parent in relationships:
                # Store only the first parent (closest in inheritance)
                if child not in self.class_hierarchy:
                    self.class_hierarchy[child] = parent
                
                # Mark known base classes
                if parent in ('deObject', 'deThreadSafeObject'):
                    self.ref_counted_classes.add(child)
        
        # Propagate ref-counted status through hierarchy
        changed = True
        iterations = 0
        max_iterations = 100
        
        while changed and iterations < max_iterations:
            changed = False
            iterations += 1
            
            for child, parent in self.class_hierarchy.items():
                if parent in self.ref_counted_classes and child not in self.ref_counted_classes:
                    self.ref_counted_classes.add(child)
                    changed = True
        
        print(f"Found {len(self.ref_counted_classes)} reference-counted classes")
    
    def find_prohibited_new(self, file_path: Path) -> List[Tuple[int, str, str]]:
        """Find uses of 'new ClassName' where ClassName is reference-counted."""
        violations = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
        except Exception as e:
            return violations
        
        # Pattern to match 'new ClassName' or 'new ClassName(...)' or 'new ClassName;'
        # Avoid matching 'new[]' array allocations
        new_pattern = re.compile(r'\bnew\s+(\w+)\s*[(\[;]')
        
        for line_num, line in enumerate(lines, 1):
            # Skip comments
            if line.strip().startswith('//'):
                continue
            
            # Check if previous line has the allow comment
            if line_num > 1:
                prev_line = lines[line_num - 2].strip()  # line_num is 1-indexed, array is 0-indexed
                if prev_line.startswith('//') and 'DELint-Allow-NewWithoutRef' in prev_line:
                    continue
            
            # Remove single-line comments
            code_part = line.split('//', 1)[0]
            
            # Find all 'new ClassName' patterns
            for match in new_pattern.finditer(code_part):
                class_name = match.group(1)
                
                # Check if this class is reference-counted
                if self.is_ref_counted(class_name):
                    violations.append((line_num, class_name, line.rstrip()))
        
        return violations
    
    def scan(self, exclude_dirs: Set[str] = None):
        """Scan all source files for prohibited 'new' usage."""
        if exclude_dirs is None:
            exclude_dirs = {'.git', 'build', 'extern', '.vs', '__pycache__'}
        
        # First, build class hierarchy from dragengine headers
        print("Building class hierarchy from dragengine headers...")
        dragengine_dir = self.repo_root / 'src' / 'dragengine'
        header_files = []
        if dragengine_dir.exists():
            for item in dragengine_dir.rglob('*.h'):
                if not any(excluded in item.parts for excluded in exclude_dirs):
                    header_files.append(item)
        print(f"Found {len(header_files)} header files in dragengine core")
        self.build_class_hierarchy(header_files)
        
        # Now find all C++ files in the scan directory
        print(f"\nScanning directory: {self.scan_dir}")
        scan_files = []
        for item in self.scan_dir.rglob('*'):
            if item.is_file() and item.suffix in ('.cpp', '.h', '.hpp'):
                # Check if any excluded directory is in the path
                if not any(excluded in item.parts for excluded in exclude_dirs):
                    scan_files.append(item)
        
        print(f"Found {len(scan_files)} C++ files to scan for violations")
        
        # Add headers from scan directory to hierarchy (in case they define new classes)
        scan_headers = [f for f in scan_files if f.suffix in ('.h', '.hpp')]
        if scan_headers:
            self.build_class_hierarchy(scan_headers)
        
        # Scan for violations
        print("\nScanning for prohibited 'new' usage...")
        total_violations = 0
        files_with_violations = 0
        
        for file_path in scan_files:
            violations = self.find_prohibited_new(file_path)
            
            if violations:
                files_with_violations += 1
                total_violations += len(violations)
                
                for line_num, class_name, line in violations:
                    print(f"{file_path}:{line_num}: new {class_name}: {line.strip()}")
        
        print(f"\n{'='*70}")
        print(f"Summary:")
        print(f"  Total files scanned: {len(scan_files)}")
        print(f"  Files with violations: {files_with_violations}")
        print(f"  Total violations: {total_violations}")
        print(f"{'='*70}")
        
        if total_violations > 0:
            print("\nRecommendation: Use ClassName::Ref::New() instead of new ClassName")
            return 1
        else:
            print("\nNo violations found!")
            return 0


def main():
    """Main entry point."""
    # Get the repository root (where this script is located)
    repo_root = Path(__file__).parent
    
    # Allow specifying a different directory as command-line argument
    if len(sys.argv) > 1:
        scan_dir = Path(sys.argv[1])
        if not scan_dir.is_absolute():
            scan_dir = repo_root / scan_dir
    else:
        scan_dir = repo_root
    
    if not scan_dir.exists():
        print(f"Error: Directory {scan_dir} does not exist")
        sys.exit(1)
    
    scanner = RefCountedClassScanner(scan_dir, repo_root)
    
    # Exclude certain directories
    exclude_dirs = {
        '.git', 
        'build', 
        'extern',  # External dependencies
        '.vs',     # Visual Studio files
        '__pycache__',
        'vs',      # Visual Studio project files
        'installer',
        'ghdocs'
    }
    
    exit_code = scanner.scan(exclude_dirs)
    sys.exit(exit_code)


if __name__ == '__main__':
    main()
