#!/usr/bin/env python3
"""
Scan C++ header files for classes deriving from deObject or deThreadSafeObject
that have public destructors instead of protected ones.

Reference-counted objects should have protected destructors to prevent accidental
deletion via raw pointers instead of through the reference counting mechanism.

This script has been generated by copilot.
"""

import os
import re
import sys
from pathlib import Path
from typing import Set, Dict, List, Tuple, Optional


class PublicDestructorScanner:
    def __init__(self, scan_dir: str, repo_root: str = None):
        self.scan_dir = Path(scan_dir)
        self.repo_root = Path(repo_root) if repo_root else self.scan_dir
        
    def find_header_files(self, directory: Path) -> List[Path]:
        """Find all C++ header files."""
        patterns = ['**/*.h', '**/*.hpp']
        files = []
        for pattern in patterns:
            files.extend(directory.glob(pattern))
        return files
    
    def extract_class_info(self, file_path: Path) -> List[Tuple[str, str, bool, Optional[int]]]:
        """
        Extract class information from a header file.
        
        Returns a list of tuples: (class_name, base_class, has_public_destructor, destructor_line_number)
        """
        classes_info = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
        except Exception as e:
            return classes_info
        
        # Remove comments for brace counting (but keep original for line numbers)
        content_no_comments = re.sub(r'//.*?$', '', content, flags=re.MULTILINE)
        content_no_comments = re.sub(r'/\*.*?\*/', '', content_no_comments, flags=re.DOTALL)
        
        # Find all class declarations that derive from deObject or deThreadSafeObject
        # We search in the content with comments removed to avoid false matches
        class_pattern = re.compile(
            r'class\s+(\w+)\s*:[^{]*?(?:public\s+)?(deObject|deThreadSafeObject)',
            re.MULTILINE
        )
        
        for match in class_pattern.finditer(content_no_comments):
            class_name = match.group(1)
            base_class = match.group(2)
            
            # Find the opening brace of the class in the no-comments version
            class_decl_end = match.end()
            opening_brace = content_no_comments.find('{', class_decl_end)
            if opening_brace == -1:
                continue
            
            # Find matching braces for the class body using the no-comments version
            brace_count = 1  # Start at 1 because we found the opening brace
            class_end = opening_brace
            for i in range(opening_brace + 1, len(content_no_comments)):
                if content_no_comments[i] == '{':
                    brace_count += 1
                elif content_no_comments[i] == '}':
                    brace_count -= 1
                    if brace_count == 0:
                        class_end = i
                        break
            
            if class_end == opening_brace:
                continue
            
            # Extract class body from no-comments version for access level detection
            class_body = content_no_comments[opening_brace:class_end]
            
            # Find the class declaration position in the ORIGINAL content for line numbers
            # Search for the same class pattern in original content
            match_original = class_pattern.search(content, max(0, match.start() - 100))
            class_decl_start_original = match_original.start() if match_original and match_original.group(1) == class_name else match.start()
            
            # Check for destructor and its access level
            has_public_destructor, destructor_line_num = self.check_destructor_access(
                class_body, class_name, content, class_decl_start_original
            )
            
            if has_public_destructor:
                classes_info.append((class_name, base_class, has_public_destructor, destructor_line_num))
        
        return classes_info
    
    def check_destructor_access(self, class_body: str, class_name: str, 
                               full_content: str, class_decl_start: int) -> Tuple[bool, Optional[int]]:
        """
        Check if the destructor is public instead of protected.
        
        Returns: (has_public_destructor, destructor_line_number)
        """
        # Pattern to match destructor declaration
        destructor_pattern = re.compile(
            rf'~{class_name}\s*\([^)]*\)',
            re.MULTILINE
        )
        
        destructor_match = destructor_pattern.search(class_body)
        if not destructor_match:
            # No explicit destructor found - default is public
            # Find the class declaration line number in original content
            class_decl_line = full_content[:class_decl_start].count('\n') + 1
            return (True, class_decl_line)
        
        # Find the destructor in the full original content to get accurate line number
        # Search for the destructor starting from the class declaration
        destructor_in_full = destructor_pattern.search(full_content, class_decl_start)
        if not destructor_in_full:
            # Shouldn't happen, but fallback to class declaration line
            class_decl_line = full_content[:class_decl_start].count('\n') + 1
            return (True, class_decl_line)
        
        # Get the line number of the destructor in the original content
        destructor_line_num = full_content[:destructor_in_full.start()].count('\n') + 1
        
        # Find the access level of the destructor
        # Track the current access level as we scan through the class body
        destructor_pos = destructor_match.start()
        
        # Split by access specifiers and track position
        current_access = 'private'  # Default for class
        access_level_at_destructor = current_access
        
        # Find all access specifiers before the destructor
        # Allow whitespace at the start of the line
        access_pattern = re.compile(r'^\s*(public|protected|private)\s*:', re.MULTILINE)
        
        for access_match in access_pattern.finditer(class_body):
            if access_match.start() < destructor_pos:
                current_access = access_match.group(1)
                access_level_at_destructor = current_access
            else:
                break
        
        # Destructor should be protected, not public
        return (access_level_at_destructor == 'public', destructor_line_num)
    
    def get_line_containing_position(self, file_path: Path, position: int) -> Optional[str]:
        """Get the line of code containing a specific character position."""
        # This method is no longer used but kept for compatibility
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            # Count newlines up to position
            line_num = content[:position].count('\n')
            
            lines = content.split('\n')
            if line_num < len(lines):
                return lines[line_num].strip()
        except Exception:
            pass
        return None
    
    def should_exclude_file(self, file_path: Path, exclude_dirs: Set[str]) -> bool:
        """
        Check if a file should be excluded based on directory exclusions.
        Excludes files if any part of their path matches an excluded directory.
        """
        try:
            # Get the relative path from repo root
            rel_path = file_path.relative_to(self.repo_root)
            # Check if any part of the path is in exclude_dirs
            for part in rel_path.parts:
                if part in exclude_dirs:
                    return True
        except ValueError:
            # File is not under repo_root
            pass
        return False
    
    def scan(self, exclude_dirs: Set[str] = None):
        """Scan all header files for classes with public destructors."""
        if exclude_dirs is None:
            exclude_dirs = {'.git', 'build', 'extern', '.vs', '__pycache__'}
        
        print(f"Scanning directory: {self.scan_dir}")
        
        # Find all header files
        header_files = []
        for item in self.scan_dir.rglob('*'):
            if item.is_file() and item.suffix in ('.h', '.hpp'):
                if not self.should_exclude_file(item, exclude_dirs):
                    header_files.append(item)
        
        print(f"Found {len(header_files)} header files to scan")
        
        # Scan for violations
        print("\nScanning for public destructors in reference-counted classes...")
        total_violations = 0
        files_with_violations = 0
        violation_details = []
        
        for file_path in header_files:
            classes_info = self.extract_class_info(file_path)
            
            for class_name, base_class, has_public_destructor, destructor_line in classes_info:
                if has_public_destructor:
                    total_violations += 1
                    files_with_violations += 1
                    violation_details.append((file_path, class_name, base_class, destructor_line))
        
        # Print violations
        for file_path, class_name, base_class, destructor_line_num in sorted(violation_details):
            rel_path = file_path.relative_to(self.repo_root) if self.repo_root else file_path
            if destructor_line_num:
                # VS Code clickable format: filepath:line:column
                print(f"{rel_path}:{destructor_line_num}:1: Class '{class_name}' : public {base_class} has public destructor (should be protected)")
            else:
                print(f"{rel_path}:1:1: Class '{class_name}' : public {base_class} has no explicit destructor (defaults to public, should be protected)")
        
        print(f"\n{'='*70}")
        print(f"Summary:")
        print(f"  Total header files scanned: {len(header_files)}")
        print(f"  Classes with public destructors: {total_violations}")
        print(f"{'='*70}")
        
        if total_violations > 0:
            print("\nRecommendation: Change destructor access to 'protected:' in these classes")
            print("Example:")
            print("  protected:")
            print("    ~ClassName();")
            return 1
        else:
            print("\nNo violations found!")
            return 0


def main():
    """Main entry point."""
    # Get the repository root (where this script is located)
    repo_root = Path(__file__).parent
    
    # Allow specifying a different directory as command-line argument
    if len(sys.argv) > 1:
        scan_dir = Path(sys.argv[1])
        if not scan_dir.is_absolute():
            scan_dir = repo_root / scan_dir
    else:
        scan_dir = repo_root
    
    if not scan_dir.exists():
        print(f"Error: Directory {scan_dir} does not exist")
        sys.exit(1)
    
    scanner = PublicDestructorScanner(scan_dir, repo_root)
    
    # Exclude certain directories
    exclude_dirs = {
        '.git', 
        'build',   # Build output directories
        'extern',  # External dependencies
        '.vs',     # Visual Studio files
        '__pycache__',
        'vs',      # Visual Studio project files
        'installer',
        'ghdocs'
    }
    
    exit_code = scanner.scan(exclude_dirs)
    sys.exit(exit_code)


if __name__ == '__main__':
    main()
