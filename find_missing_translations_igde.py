#!/usr/bin/env python3
"""
Scan IGDE source files for translation strings that have no matching entry
in the respective en.delangpack file.

Translation strings are:
- String literals of the form "@<translation-name>"
- Function calls like Translate("<translation-name>")

The respective en.delangpack file is:
- For editor source files: src/deigde/editors/<editor>/data/languages/en.delangpack
- For IGDE source files: src/deigde/deigde/shared/data/languages/en.delangpack

This script has been generated by copilot.
"""

import os
import re
import sys
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Set, Dict, List, Tuple


class TranslationScanner:
    def __init__(self, scan_dir: str, repo_root: str = None):
        self.scan_dir = Path(scan_dir)
        self.repo_root = Path(repo_root) if repo_root else self.scan_dir
        self.translation_cache: Dict[Path, Set[str]] = {}  # langpack -> translation names
        # String literals to exclude from translation checking (e.g., special path variables)
        self.excluded_strings: Set[str] = {
            "@RoamingAppData",
            "@RoamingAppData\\\\DEIGDE\\\\Config",
            "@RoamingAppData\\\\DELaunchers\\\\Config",
            "@LocalAppData\\\\DEIGDE\\\\Logs",
            "@Documents",
            "@Documents\\\\DEGameProjects"
        }
        
    def find_source_files(self, directory: Path) -> List[Path]:
        """Find all C++ source and header files."""
        patterns = ['**/*.cpp', '**/*.h', '**/*.hpp']
        files = []
        for pattern in patterns:
            files.extend(directory.glob(pattern))
        return files
    
    def load_langpack_translations(self, langpack_path: Path) -> Set[str]:
        """Load all translation names from a delangpack XML file."""
        if langpack_path in self.translation_cache:
            return self.translation_cache[langpack_path]
        
        translations = set()
        
        if not langpack_path.exists():
            self.translation_cache[langpack_path] = translations
            return translations
        
        try:
            tree = ET.parse(langpack_path)
            root = tree.getroot()
            
            # Find all <translation name="..."> elements
            for trans_elem in root.findall('.//translation[@name]'):
                name = trans_elem.get('name')
                if name:
                    translations.add(name)
                    
        except Exception as e:
            print(f"Warning: Failed to parse {langpack_path}: {e}")
        
        self.translation_cache[langpack_path] = translations
        return translations
    
    def get_langpack_for_file(self, file_path: Path) -> List[Path]:
        """Determine the appropriate en.delangpack file(s) for a source file.
        
        Returns a list of langpack paths to check. For editor files, this includes
        both the editor-specific langpack and the shared IGDE langpack.
        """
        langpacks = []
        
        try:
            rel_path = file_path.relative_to(self.repo_root)
            parts = rel_path.parts
            
            # Check if it's an editor source file: src/deigde/editors/<editor>/...
            if len(parts) >= 4 and parts[0] == 'src' and parts[1] == 'deigde' and parts[2] == 'editors':
                editor_name = parts[3]
                editor_langpack = self.repo_root / 'src' / 'deigde' / 'editors' / editor_name / 'data' / 'languages' / 'en.delangpack'
                langpacks.append(editor_langpack)
                # Also check the shared IGDE langpack for common translations
                igde_langpack = self.repo_root / 'src' / 'deigde' / 'deigde' / 'shared' / 'data' / 'languages' / 'en.delangpack'
                langpacks.append(igde_langpack)
                return langpacks
            
            # Check if it's an IGDE source file: src/deigde/deigde/...
            if len(parts) >= 3 and parts[0] == 'src' and parts[1] == 'deigde' and parts[2] == 'deigde':
                langpack = self.repo_root / 'src' / 'deigde' / 'deigde' / 'shared' / 'data' / 'languages' / 'en.delangpack'
                langpacks.append(langpack)
                return langpacks
                
        except ValueError:
            pass
        
        return langpacks
    
    def find_translation_strings(self, file_path: Path) -> Tuple[List[Tuple[int, str]], List[Tuple[int, str, str]]]:
        """Find all translation string references in a source file.
        
        Returns:
            Tuple of (valid_translations, invalid_translations)
            - valid_translations: List of (line_num, trans_name)
            - invalid_translations: List of (line_num, trans_name, full_string)
        """
        valid_translations = []
        invalid_translations = []
        
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
        except Exception as e:
            return valid_translations, invalid_translations
        
        # Pattern 1: @<translation-name> in string literals (valid names: alphanumeric, dots, underscores, hyphens)
        # Match: "@Conversation.WPTopic.Actions.Label"
        at_pattern_valid = re.compile(r'"@([\w.-]+)"')
        
        # Pattern 2: @<anything> in string literals (to catch invalid names)
        # This captures strings starting with @ that contain spaces or other invalid characters
        at_pattern_any = re.compile(r'"(@[^"]+)"')
        
        # Pattern 3: Translate("<translation-name>")
        # Match: Translate("Conversation.WPTopic.Actions.Label")
        translate_pattern = re.compile(r'Translate\s*\(\s*"([\w.-]+)"\s*\)')
        
        for line_num, line in enumerate(lines, 1):
            # Skip comments
            stripped = line.strip()
            if stripped.startswith('//') or stripped.startswith('*') or stripped.startswith('/*'):
                continue
            
            # Remove single-line comments
            code_part = line.split('//', 1)[0]
            
            # First, find all @<anything> patterns to detect invalid names
            all_at_strings = {}
            for match in at_pattern_any.finditer(code_part):
                full_string = match.group(1)  # e.g., "@Link Set Controller"
                all_at_strings[match.start()] = full_string
            
            # Then find valid @<translation-name> patterns
            valid_positions = set()
            for match in at_pattern_valid.finditer(code_part):
                trans_name = match.group(1)
                # Check if this is an excluded string
                full_string = f"@{trans_name}"
                if full_string not in self.excluded_strings:
                    valid_translations.append((line_num, trans_name))
                    valid_positions.add(match.start())
            
            # Find invalid @strings (those that weren't matched by the valid pattern)
            for pos, full_string in all_at_strings.items():
                if pos not in valid_positions and full_string not in self.excluded_strings:
                    # Extract the attempted name (everything after @)
                    trans_name = full_string[1:]  # Remove the @
                    invalid_translations.append((line_num, trans_name, full_string))
            
            # Find Translate("<translation-name>") patterns
            for match in translate_pattern.finditer(code_part):
                trans_name = match.group(1)
                valid_translations.append((line_num, trans_name))
        
        return valid_translations, invalid_translations
    
    def should_exclude_file(self, file_path, exclude_dirs):
        """
        Check if a file should be excluded based on top-level directory exclusions.
        Only excludes if the file is directly under repo_root/excluded_dir.
        """
        try:
            # Get the relative path from repo root
            rel_path = file_path.relative_to(self.repo_root)
            # Get the top-level directory (first part of relative path)
            if len(rel_path.parts) > 0:
                top_dir = rel_path.parts[0]
                return top_dir in exclude_dirs
        except ValueError:
            # File is not under repo_root
            pass
        return False
    
    def scan(self, exclude_dirs: Set[str] = None):
        """Scan all source files for missing translations."""
        if exclude_dirs is None:
            exclude_dirs = {'.git', 'build', 'extern', '.vs', '__pycache__'}
        
        print(f"Scanning directory: {self.scan_dir}")
        
        # Find all source files
        scan_files = []
        for item in self.scan_dir.rglob('*'):
            if item.is_file() and item.suffix in ('.cpp', '.h', '.hpp'):
                if not self.should_exclude_file(item, exclude_dirs):
                    scan_files.append(item)
        
        print(f"Found {len(scan_files)} source files to scan")
        
        # Scan for missing translations and invalid names
        print("\nScanning for missing translations and invalid translation names...")
        total_missing = 0
        total_invalid = 0
        files_with_issues = 0
        missing_details = []
        invalid_details = []
        
        for file_path in scan_files:
            langpack_paths = self.get_langpack_for_file(file_path)
            
            if not langpack_paths:
                # Skip files that don't belong to IGDE or editors
                continue
            
            # Load translations from all langpacks (editor-specific and shared IGDE)
            available_translations = set()
            for langpack_path in langpack_paths:
                available_translations.update(self.load_langpack_translations(langpack_path))
            
            # Find translation strings in source file
            valid_refs, invalid_refs = self.find_translation_strings(file_path)
            
            # Check for invalid translation names
            primary_langpack = langpack_paths[0] if langpack_paths else None
            for line_num, trans_name, full_string in invalid_refs:
                invalid_details.append((file_path, line_num, trans_name, full_string, primary_langpack))
            
            # Check for missing translations (only for valid names)
            for line_num, trans_name in valid_refs:
                if trans_name not in available_translations:
                    missing_details.append((file_path, line_num, trans_name, primary_langpack))
        
        # Print invalid translation names first
        if invalid_details:
            print(f"\n{'='*70}")
            print("INVALID TRANSLATION NAMES FOUND")
            print(f"{'='*70}")
            print("Translation names must contain only alphanumeric characters, dots (.), hyphens (-), and underscores (_).")
            print("Spaces and other special characters are not allowed.\n")
            
            # Group by langpack
            invalid_by_langpack: Dict[Path, Dict[str, List[Tuple[Path, int, str]]]] = {}
            for file_path, line_num, trans_name, full_string, langpack_path in invalid_details:
                if langpack_path not in invalid_by_langpack:
                    invalid_by_langpack[langpack_path] = {}
                if trans_name not in invalid_by_langpack[langpack_path]:
                    invalid_by_langpack[langpack_path][trans_name] = []
                invalid_by_langpack[langpack_path][trans_name].append((file_path, line_num, full_string))
            
            for langpack_path in sorted(invalid_by_langpack.keys()):
                print(f"\nEditor: {langpack_path.parent.parent.parent.name if langpack_path else 'Unknown'}")
                print(f"-" * 70)
                
                for trans_name in sorted(invalid_by_langpack[langpack_path].keys()):
                    print(f"\nInvalid translation name: '{trans_name}'")
                    total_invalid += 1
                    for file_path, line_num, full_string in invalid_by_langpack[langpack_path][trans_name]:
                        print(f"  {file_path}:{line_num}")
                        print(f"    Found: \"{full_string}\"")
        
        # Group missing translations by langpack and translation name
        missing_by_langpack: Dict[Path, Dict[str, List[Tuple[Path, int]]]] = {}
        for file_path, line_num, trans_name, langpack_path in missing_details:
            if langpack_path not in missing_by_langpack:
                missing_by_langpack[langpack_path] = {}
            if trans_name not in missing_by_langpack[langpack_path]:
                missing_by_langpack[langpack_path][trans_name] = []
            missing_by_langpack[langpack_path][trans_name].append((file_path, line_num))
        
        # Print missing translations
        if missing_by_langpack:
            print(f"\n{'='*70}")
            print("MISSING TRANSLATIONS")
            print(f"{'='*70}\n")
            
            for langpack_path in sorted(missing_by_langpack.keys()):
                print(f"Missing translations in: {langpack_path}")
                print(f"-" * 70)
                
                for trans_name in sorted(missing_by_langpack[langpack_path].keys()):
                    print(f"\nTranslation '{trans_name}' missing:")
                    total_missing += 1
                    for file_path, line_num in missing_by_langpack[langpack_path][trans_name]:
                        print(f"  {file_path}:{line_num}")
        
        # Count files with issues
        files_with_issues = len(set(
            [fp for fp, _, _, _, _ in invalid_details] + 
            [fp for fp, _, _, _ in missing_details]
        ))
        
        print(f"\n{'='*70}")
        print(f"Summary:")
        print(f"  Total files scanned: {len(scan_files)}")
        print(f"  Files with issues: {files_with_issues}")
        print(f"  Invalid translation names: {total_invalid}")
        print(f"  Missing translations: {total_missing}")
        print(f"{'='*70}")
        
        if total_invalid > 0:
            print("\nRecommendation: Fix invalid translation names by:")
            print("  1. Replace spaces with dots or remove them")
            print("  2. Use only alphanumeric characters, dots (.), hyphens (-), and underscores (_)")
            print("  3. Follow the naming convention: Editor.Component.Action or similar")
        
        if total_missing > 0:
            print("\nRecommendation: Add missing translation entries to respective en.delangpack files")
        
        if total_invalid == 0 and total_missing == 0:
            print("\nNo issues found!")
            return 0
        
        return 1


def main():
    """Main entry point."""
    # Get the repository root (where this script is located)
    repo_root = Path(__file__).parent
    
    # Allow specifying a different directory as command-line argument
    if len(sys.argv) > 1:
        scan_dir = Path(sys.argv[1])
        if not scan_dir.is_absolute():
            scan_dir = repo_root / scan_dir
    else:
        scan_dir = repo_root / 'src' / 'deigde'
    
    if not scan_dir.exists():
        print(f"Error: Directory {scan_dir} does not exist")
        sys.exit(1)
    
    scanner = TranslationScanner(scan_dir, repo_root)
    
    # Exclude certain directories
    exclude_dirs = {
        '.git', 
        'build', 
        'extern',  # External dependencies
        '.vs',     # Visual Studio files
        '__pycache__',
        'vs',      # Visual Studio project files
        'installer',
        'ghdocs'
    }
    
    exit_code = scanner.scan(exclude_dirs)
    sys.exit(exit_code)


if __name__ == '__main__':
    main()
