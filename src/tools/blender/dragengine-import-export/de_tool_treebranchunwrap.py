# -*- coding: utf-8 -*-
#
# Drag[en]gine Blender Scripts
#
# Copyright (C) 2011, PlÃ¼ss Roland ( roland@rptd.ch )
# 
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later 
# version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# NOTE: For the GPL copy see http://www.gnu.org/licenses/gpl.html
#

import bpy

from .de_resources import Connectivity
from .de_porting import registerClass



# Tool Tree Branch Unwrap
###########################

class OBJECT_OT_ToolTreeBranchUnwrap( bpy.types.Operator ):
	bl_idname = "dragengine.treebranchunwrap"
	bl_label = "Tree Branch Unwrap"
	bl_options = { 'REGISTER', 'UNDO' }
	__doc__ = """Unwrap tree branches as generated by ngPlant"""
	
	scale = bpy.props.IntProperty( name="Scaling", description="Scaling", soft_min=1, soft_max=5, default=1 )
	
	@classmethod
	def poll( cls, context ):
		return context.active_object != None \
			and context.active_object.type == 'MESH' \
			and context.active_object.data.uv_layers.active \
			and context.tool_settings.mesh_select_mode[ 2 ]
	
	def execute( self, context ):
		# preparations
		editmode = ( context.mode == 'EDIT_MESH' )
		if editmode:
			bpy.ops.object.mode_set( mode='OBJECT' )
				
		mesh = context.active_object.data
		uvs = mesh.uv_layers.active.data
		
		scale = float( self.scale )
		maxCoordU = scale
		
		# build connectivity information
		con = Connectivity( mesh )
		
		# build list of vertices at the top or bottom
		for edge in con.edges:
			edge.isOpen = ( edge.face2 == None )
		
		for vertex in con.vertices:
			vertex.isOpen = False
			vertex.uv = None
			vertex.ring = None
			vertex.ringIndex = -1
		
		vertices = []
		for edge in con.edges:
			if edge.isOpen:
				if not edge.vertex1 in vertices:
					vertices.append( edge.vertex1 )
					edge.vertex1.isOpen = True
				if not edge.vertex2 in vertices:
					vertices.append( edge.vertex2 )
					edge.vertex2.isOpen = True
		
		# build groups of faces forming branches
		class Branch:
			def __init__( self ):
				self.faces = []
				self.vertices = []
				self.openFaces = []
				self.openVertices = []
				self.baseRing = []
				self.baseRingLen = 0.0
				self.startEdge = None
				self.startFace = None
		
		for face in con.faces:
			face.branch = None
		
		branches = []
		for face in con.faces:
			if face.branch:
				continue
			
			openVertex = None
			for vertex in face.vertices:
				if vertex.isOpen:
					openVertex = vertex
					break
			
			if openVertex:
				branch = Branch()
				branches.append( branch )
				
				facesToCheck = [ face ]
				while len( facesToCheck ) > 0:
					face = facesToCheck.pop()
					if face.branch:
						continue
					
					branch.faces.append( face )
					face.branch = branch
					
					for edge in face.edges:
						if edge.face1.index == face.index:
							if edge.face2 and not edge.face2.branch:
								facesToCheck.append( edge.face2 )
						else:
							if not edge.face1.branch:
								facesToCheck.append( edge.face1 )
		
		# unwrap the branches
		for branch in branches:
			# determine the open faces and vertices
			for face in branch.faces:
				for vertex in face.vertices:
					if not vertex in branch.vertices:
						branch.vertices.append( vertex )
			
			for face in branch.faces:
				for vertex in face.vertices:
					if vertex.isOpen:
						if not vertex in branch.openVertices:
							branch.openVertices.append( vertex )
						if not face in branch.openFaces:
							branch.openFaces.append( face )
							break
			
			# determine the base ring. for this the top and bottom ring are determined and their
			# length compared. the larger ring is considered the base ring
			lastVertex = branch.openVertices[ 0 ]
			ring1 = [ lastVertex ]
			ring1Len = 0.0
			while lastVertex:
				nextVertex = None
				for edge in lastVertex.edges:
					if edge.vertex1.index == lastVertex.index:
						nextVertex = edge.vertex2
					else:
						nextVertex = edge.vertex1
					if nextVertex.isOpen and not nextVertex in ring1:
						ring1.append( nextVertex )
						ring1Len = ring1Len + ( nextVertex.vertex.co - lastVertex.vertex.co ).length
						break
					else:
						nextVertex = None
				lastVertex = nextVertex
			
			ring2 = []
			ring2Len = 0.0
			for lastVertex in branch.openVertices:
				if not lastVertex in ring1:
					ring2 = [ lastVertex ]
					while lastVertex:
						nextVertex = None
						for edge in lastVertex.edges:
							if edge.vertex1.index == lastVertex.index:
								nextVertex = edge.vertex2
							else:
								nextVertex = edge.vertex1
							if nextVertex.isOpen and not nextVertex in ring2 and not nextVertex in ring1:
								ring2.append( nextVertex )
								ring2Len = ring2Len + ( nextVertex.vertex.co - lastVertex.vertex.co ).length
								break
							else:
								nextVertex = None
						lastVertex = nextVertex
			
			if ring1Len > ring2Len:
				branch.baseRing = ring1
				branch.baseRingLen = ring1Len
			else:
				branch.baseRing = ring2
				branch.baseRingLen = ring2Len
			
			# determine the start edge and start face. flips the direction of the start ring if the ring
			# is not aligned with the start edge direction relative to the start face
			startVertex1 = branch.baseRing[ 0 ]
			startVertex2 = branch.baseRing[ 1 ]
			for face in branch.openFaces:
				for corner in range( face.face.loop_total ):
					vertex = con.vertices[ face.face.vertices[ corner ] ]
					vertexNext = con.vertices[ face.face.vertices[ ( corner + 1 ) % face.face.loop_total ] ]
					if vertex == startVertex1 and vertexNext == startVertex2:
						branch.startEdge = face.edges[ corner ]
						branch.startFace = face
						break
					elif vertex == startVertex2 and vertexNext == startVertex1:
						branch.startEdge = face.edges[ corner ]
						branch.startFace = face
						branch.baseRing.reverse()
						branch.baseRing.insert( 0, branch.baseRing.pop() )
						branch.baseRing.insert( 0, branch.baseRing.pop() )
						break
			
			# calculate the rings and unwrap the vertices. each ring unwraps to a straight line from the
			# u=0 position to the u=maxCoordU position with all vertices inside spaced evenly
			ring = branch.baseRing
			ringVCoord = 0.0
			remainingVertices = [ vertex for vertex in branch.vertices ]
			while len( ring ) > 0:
				ringlen = 0.0
				count = len( ring )
				factorCoordU = maxCoordU / float( count )
				for index in range( count ):
					vertex = ring[ index ]
					vertex.uv = [ factorCoordU * float( index ), ringVCoord ]
					vertex.ring = ring
					vertex.ringIndex = index
					remainingVertices.remove( vertex )
					ringlen = ringlen + ( ring[ ( index + 1 ) % count ].vertex.co - vertex.vertex.co ).length
				
				nextRing = []
				edgelen = 0.0
				for index in range( count ):
					baseVertex = ring[ index ]
					for vertex in remainingVertices:
						edge = vertex.getEdgeWithVertex( baseVertex )
						if edge:
							nextRing.append( vertex )
							edgelen = edgelen + ( vertex.vertex.co - baseVertex.vertex.co ).length
							break
				
				ring = nextRing
				
				if len( ring ) > 0:
					edgelen = scale * edgelen / float( len( nextRing ) )
					ringVCoord = ringVCoord + edgelen / ringlen
			
			# create the texture coordinates for the faces. care has to be taken to map the last face in the
			# rings to map to maxCoordU instead of 0
			for face in branch.faces:
				for corner in range( face.face.loop_total ):
					vertex = con.vertices[ face.face.vertices[ corner ] ]
					u = vertex.uv[ 0 ]
					if vertex.ringIndex == 0:
						vertex2 = con.vertices[ face.face.vertices[ ( corner + 1 ) % face.face.loop_total ] ]
						if vertex2.ring != vertex.ring:
							vertex2 = con.vertices[ face.face.vertices[ ( corner - 1 + face.face.loop_total ) % face.face.loop_total ] ]
						if vertex2.ringIndex == len( vertex.ring ) - 1:
							u = maxCoordU
					uvs[ face.face.loop_start + corner ].uv = [ u, vertex.uv[ 1 ] ]
		
		# clean up
		if editmode:
			bpy.ops.object.mode_set( mode='EDIT' )
		
		return { 'FINISHED' }
registerClass(OBJECT_OT_ToolTreeBranchUnwrap)
