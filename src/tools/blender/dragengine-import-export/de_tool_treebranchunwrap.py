# -*- coding: utf-8 -*-
#
# Drag[en]gine Blender Scripts
#
# Copyright (C) 2011, PlÃ¼ss Roland ( roland@rptd.ch )
# 
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later 
# version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# NOTE: For the GPL copy see http://www.gnu.org/licenses/gpl.html
#

import bpy

from .de_resources import Connectivity
from .de_porting import registerClass, appendToMenu



# Tool Tree Branch Unwrap
###########################

class OBJECT_OT_ToolTreeBranchUnwrap( bpy.types.Operator ):
    bl_idname = "dragengine.treebranchunwrap"
    bl_label = "Tree Branch Unwrap"
    bl_label_button = "Tree Branch"
    bl_options = { 'REGISTER', 'UNDO' }
    __doc__ = """Unwrap tree branches as generated by ngPlant"""
    
    scale: bpy.props.IntProperty( name="Scaling", description="Scaling", soft_min=1, soft_max=5, default=1 )
    
    @classmethod
    def poll( cls, context ):
        return context.active_object != None \
            and context.active_object.type == 'MESH' \
            and context.active_object.data.uv_layers.active \
            and context.tool_settings.mesh_select_mode[ 2 ]
    
    def execute( self, context ):
        # preparations
        editmode = ( context.mode == 'EDIT_MESH' )
        if editmode:
            bpy.ops.object.mode_set( mode='OBJECT' )
                
        mesh = context.active_object.data
        uvs = mesh.uv_layers.active.data
        
        scale = float( self.scale )
        maxCoordU = scale
        
        # build connectivity information
        con = Connectivity( mesh )
        
        # build list of vertices at the top or bottom
        for edge in con.edges:
            edge.isOpen = ( edge.face2 == None )
        
        for vertex in con.vertices:
            vertex.isOpen = False
            vertex.uv = None
            vertex.ring = None
            vertex.ringIndex = -1
        
        vertices = []
        for edge in con.edges:
            if edge.isOpen:
                if not edge.vertex1 in vertices:
                    vertices.append( edge.vertex1 )
                    edge.vertex1.isOpen = True
                if not edge.vertex2 in vertices:
                    vertices.append( edge.vertex2 )
                    edge.vertex2.isOpen = True
        
        # build groups of faces forming branches
        class Branch:
            def __init__( self ):
                self.faces = []
                self.vertices = []
                self.openFaces = []
                self.openVertices = []
                self.baseRing = []
                self.baseRingLen = 0.0
                self.startEdge = None
                self.startFace = None
        
        for face in con.faces:
            face.branch = None
        
        branches = []
        for face in con.faces:
            if face.branch:
                continue
            
            openVertex = None
            for vertex in face.vertices:
                if vertex.isOpen:
                    openVertex = vertex
                    break
            
            if openVertex:
                branch = Branch()
                branches.append( branch )
                
                facesToCheck = [ face ]
                while len( facesToCheck ) > 0:
                    face = facesToCheck.pop()
                    if face.branch:
                        continue
                    
                    branch.faces.append( face )
                    face.branch = branch
                    
                    for edge in face.edges:
                        if edge.face1.index == face.index:
                            if edge.face2 and not edge.face2.branch:
                                facesToCheck.append( edge.face2 )
                        else:
                            if not edge.face1.branch:
                                facesToCheck.append( edge.face1 )
        
        # unwrap the branches
        for branch in branches:
            # determine the open faces and vertices
            for face in branch.faces:
                for vertex in face.vertices:
                    if not vertex in branch.vertices:
                        branch.vertices.append( vertex )
            
            for face in branch.faces:
                for vertex in face.vertices:
                    if vertex.isOpen:
                        if not vertex in branch.openVertices:
                            branch.openVertices.append( vertex )
                        if not face in branch.openFaces:
                            branch.openFaces.append( face )
                            break
            
            # determine the base ring. for this the top and bottom ring are determined and their
            # length compared. the larger ring is considered the base ring
            lastVertex = branch.openVertices[ 0 ]
            ring1 = [ lastVertex ]
            ring1Len = 0.0
            while lastVertex:
                nextVertex = None
                for edge in lastVertex.edges:
                    if edge.vertex1.index == lastVertex.index:
                        nextVertex = edge.vertex2
                    else:
                        nextVertex = edge.vertex1
                    if nextVertex.isOpen and not nextVertex in ring1:
                        ring1.append( nextVertex )
                        ring1Len = ring1Len + ( nextVertex.vertex.co - lastVertex.vertex.co ).length
                        break
                    else:
                        nextVertex = None
                lastVertex = nextVertex
            
            ring2 = []
            ring2Len = 0.0
            for lastVertex in branch.openVertices:
                if not lastVertex in ring1:
                    ring2 = [ lastVertex ]
                    while lastVertex:
                        nextVertex = None
                        for edge in lastVertex.edges:
                            if edge.vertex1.index == lastVertex.index:
                                nextVertex = edge.vertex2
                            else:
                                nextVertex = edge.vertex1
                            if nextVertex.isOpen and not nextVertex in ring2 and not nextVertex in ring1:
                                ring2.append( nextVertex )
                                ring2Len = ring2Len + ( nextVertex.vertex.co - lastVertex.vertex.co ).length
                                break
                            else:
                                nextVertex = None
                        lastVertex = nextVertex
            
            if ring1Len > ring2Len:
                branch.baseRing = ring1
                branch.baseRingLen = ring1Len
            else:
                branch.baseRing = ring2
                branch.baseRingLen = ring2Len
            
            # determine the start edge and start face. flips the direction of the start ring if the ring
            # is not aligned with the start edge direction relative to the start face
            startVertex1 = branch.baseRing[ 0 ]
            startVertex2 = branch.baseRing[ 1 ]
            for face in branch.openFaces:
                for corner in range( face.face.loop_total ):
                    vertex = con.vertices[ face.face.vertices[ corner ] ]
                    vertexNext = con.vertices[ face.face.vertices[ ( corner + 1 ) % face.face.loop_total ] ]
                    if vertex == startVertex1 and vertexNext == startVertex2:
                        branch.startEdge = face.edges[ corner ]
                        branch.startFace = face
                        break
                    elif vertex == startVertex2 and vertexNext == startVertex1:
                        branch.startEdge = face.edges[ corner ]
                        branch.startFace = face
                        branch.baseRing.reverse()
                        branch.baseRing.insert( 0, branch.baseRing.pop() )
                        branch.baseRing.insert( 0, branch.baseRing.pop() )
                        break
            
            # calculate the rings and unwrap the vertices. each ring unwraps to a straight line from the
            # u=0 position to the u=maxCoordU position with all vertices inside spaced evenly
            ring = branch.baseRing
            ringVCoord = 0.0
            remainingVertices = [ vertex for vertex in branch.vertices ]
            while len( ring ) > 0:
                ringlen = 0.0
                count = len( ring )
                factorCoordU = maxCoordU / float( count )
                for index in range( count ):
                    vertex = ring[ index ]
                    vertex.uv = [ factorCoordU * float( index ), ringVCoord ]
                    vertex.ring = ring
                    vertex.ringIndex = index
                    remainingVertices.remove( vertex )
                    ringlen = ringlen + ( ring[ ( index + 1 ) % count ].vertex.co - vertex.vertex.co ).length
                
                nextRing = []
                edgelen = 0.0
                for index in range( count ):
                    baseVertex = ring[ index ]
                    for vertex in remainingVertices:
                        edge = vertex.getEdgeWithVertex( baseVertex )
                        if edge:
                            nextRing.append( vertex )
                            edgelen = edgelen + ( vertex.vertex.co - baseVertex.vertex.co ).length
                            break
                
                ring = nextRing
                
                if len( ring ) > 0:
                    edgelen = scale * edgelen / float( len( nextRing ) )
                    ringVCoord = ringVCoord + edgelen / ringlen
            
            # create the texture coordinates for the faces. care has to be taken to map the last face in the
            # rings to map to maxCoordU instead of 0
            for face in branch.faces:
                for corner in range( face.face.loop_total ):
                    vertex = con.vertices[ face.face.vertices[ corner ] ]
                    u = vertex.uv[ 0 ]
                    if vertex.ringIndex == 0:
                        vertex2 = con.vertices[ face.face.vertices[ ( corner + 1 ) % face.face.loop_total ] ]
                        if vertex2.ring != vertex.ring:
                            vertex2 = con.vertices[ face.face.vertices[ ( corner - 1 + face.face.loop_total ) % face.face.loop_total ] ]
                        if vertex2.ringIndex == len( vertex.ring ) - 1:
                            u = maxCoordU
                    uvs[ face.face.loop_start + corner ].uv = [ u, vertex.uv[ 1 ] ]
        
        # clean up
        if editmode:
            bpy.ops.object.mode_set( mode='EDIT' )
        
        return { 'FINISHED' }

registerClass(OBJECT_OT_ToolTreeBranchUnwrap)
appendToMenu(bpy.types.VIEW3D_MT_edit_mesh_vertices,
             OBJECT_OT_ToolTreeBranchUnwrap)
