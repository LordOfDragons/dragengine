/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

namespace Dragengine.Services
pin Dragengine.Utils


/**
 * \brief Service providing access to Mod.io functionality if supported.
 * \version 1.23
 * 
 * Provides access to these functionalities:
 * - Mod browsing
 * - Mod installing
 * - Mod deinstalling
 */
class ServiceModio implements ServiceListener, ServiceMods
	var String pApiKey, pGameId, pUserId
	var ModioEnvironment pEnvironment
	var ModioPortal pPortal
	var Service pService
	var ServiceInitListener pInitListener
	var Boolean pIsInitialized
	var SafeArray pModsListeners
	
	
	
	/**
	 * \brief Create service ServiceModIO.
	 * 
	 * The service is asynchronously initialized. Once initialization finished
	 * the provided listener is called with success or failure outcome. If the
	 * outcome is success the service can be used. If the outcome is failure
	 * the service can not be used and should be disposed.
	 * 
	 * \param apiKey Application key.
	 * \param gameId Game identifier. Number in string form.
	 * \param userId User identifier. Called "Local platform user" in ModIO.
	 * \param environment Environment to use.
	 * \param portal Optional portal indicator. Can be null if not known.
	 * \param listener Listener called if initialization finished. Can be null.
	 * \throws EInvalidParam ModIO service module is not present.
	 * \throws EInvalidParam One or more of the provided parameters is not valid.
	 */
	func new(String apiKey, String gameId, String userId, ModioEnvironment environment,\
	ModioPortal portal, ServiceInitListener listener)
		pApiKey = apiKey
		pGameId = gameId
		pUserId = userId
		pEnvironment = environment
		pPortal = portal
		pInitListener = listener
		pModsListeners = SafeArray.new()
		
		var ServiceObject so = ServiceObject.new()
		so.setStringChildAt("apiKey", apiKey)
		so.setStringChildAt("gameId", gameId)
		so.setStringChildAt("userId", userId)
		so.setStringChildAt("environment", environment.name())
		if portal != null
			so.setStringChildAt("portal", portal.name())
		end
		
		pService = Service.new("Mod.io", so)
		
		pService.setListener(this)
	end
	
	/**
	 * \brief Dispose of ModIO service.
	 */
	func void dispose()
		pInitListener = null
		pModsListeners.removeAll()
		
		if pService != null
			pService.setListener(null)
		end
		pService = null
	end
	
	
	
	/**
	 * \brief Checks if ModIO service is supported.
	 * 
	 * Service is reported supported if the ModIO Service Module is present.
	 * Creating the service can still fail.
	 */
	static func bool isServiceSupported()
		return Engine.getSupportedServices().has("Mod.io")
	end
	
	
	
	/**
	 * \brief Application key.
	 */
	func String getApikey()
		return pApiKey
	end
	
	/**
	 * \brief Game identifier.
	 */
	func String getGameId()
		return pGameId
	end
	
	/**
	 * \brief User identifier. Called "Local platform user" in ModIO.
	 */
	func String getUserId()
		return pUserId
	end
	
	/**
	 * \brief Game environment.
	 */
	func ModioEnvironment getEnvironment()
		return pEnvironment
	end
	
	/**
	 * \brief Store portal or null if unknown.
	 */
	func ModioPortal getPortal()
		return pPortal
	end
	
	
	
	/**
	 * \brief Determines if service is initialized and ready to be used.
	 * 
	 * If null is returned the service is still initializing. If returned object has true
	 * value the service is initialized and ready to be used. If returned object has false
	 * value the service failed to initialized and has to be disposed.
	 */
	func Boolean isInitialized()
		return pIsInitialized
	end
	
	
	
	/**
	 * \brief Add modification listener.
	 * \param listener Listener to add
	 */
	func void addModsListener(ServiceModsListener listener)
		if listener == null
			throw ENullPointer.new("listener")
		end
		pModsListeners.add(listener)
	end
	
	/**
	 * \brief Remove modification listener.
	 * \param listener Listener to remove.
	 */
	func void removeModsListener(ServiceModsListener listener)
		pModsListeners.remove(listener)
	end
	
	
	
	/**
	 * \brief Filtered list of available game modifications.
	 * 
	 * Requests a list of game modifications using the provided filters. All filter
	 * parameters set to null cause default values to be used as defined by the
	 * service provider. Filters not supported by the service provider are ignored.
	 * 
	 * Once the results are retrieved the service calls
	 * \ref ServiceModsListener#listModsFinished(ServiceMods,UniqueID,Array) or
	 * \ref ServiceModsListener#listModsFailed(ServiceMods,UniqueID,String).
	 * The returned request identifier can be used in the listener methods to identify
	 * which request the received response belongs to.
	 * 
	 * Receiving the results can take considerable amount of time depending on the
	 * load of the service provider. To cancel the 
	 */
	func UniqueID listAllMods(ServiceModFilter filter)
		var ServiceObject so = ServiceObject.new()
		so.setStringChildAt("function", "listAllMods")
		
		pFilterAddEnum(so, "sortField", filter.sortField)
		pFilterAddEnum(so, "sortDirection", filter.sortDirection)
		pFilterAddStringSet(so, "nameContains", filter.nameContains)
		pFilterAddStringSet(so, "matchingAuthor", filter.matchingAuthor)
		pFilterAddStringSet(so, "matchingIds", filter.withIds)
		pFilterAddDate(so, "markedLiveAfter", filter.releasedAfter)
		pFilterAddDate(so, "markedLiveBefore", filter.releasedBefore)
		pFilterAddStringSet(so, "withTags", filter.withTags)
		pFilterAddStringSet(so, "withoutTags", filter.withoutTags)
		if filter.metadataLike != null
			so.setStringChildAt("metadataLike", filter.metadataLike)
		end
		pFilterAddEnum(so, "revenueType", filter.revenueType)
		so.setBoolChildAt("disallowMatureContent", filter.disallowMatureContent)
		pFilterAddEnumSet(so, "withMatureContentFlags", filter.withMatureContentFlags)
		so.setIntChildAt("startIndex", filter.startIndex)
		so.setIntChildAt("resultCount", filter.resultCount)
		
		var Dictionary d = Dictionary.new()
		pRecursiveServiceObject(d, "Request", so)
		pLogDictionary(BaseGameApp.getApp().getConsole(), d, "listAllMods")
		
		var UniqueID id = pService.nextId()
		pService.startRequest(id, so)
		return id
	end
	
	/**
	 * \brief Cancel request.
	 * 
	 * Safe to be called if request has been already cancelled or does not exist.
	 * 
	 * \param id Identifier of request to cancel.
	 */
	func void cancelRequest(UniqueID id)
		pService.cancelRequest(id)
	end
	
	
	
	/**
	 * \brief Service request response received.
	 */
	func void requestResponse(Service service, UniqueID id, ServiceObject response, bool finished)
		var String function = response.getChildAt("function").getString()
		
		var Dictionary d = Dictionary.new()
		pRecursiveServiceObject(d, "Response", response)
		pLogDictionary(BaseGameApp.getApp().getConsole(), d, "requestResponse")
		
		if function.equals("listAllMods")
			pModsListeners.forEach(block ServiceModsListener each
				each.listModsFinished(this, id, Array.new())
			end)
		end
	end
	
	/**
	 * \brief Service request failed.
	 */
	func void requestFailed(Service service, UniqueID id, ServiceObject error)
		var String function = error.getChildAt("function").getString()
		
		if function.equals("listAllMods")
			var String message = getErrorMessage(error)
			pModsListeners.forEach(block ServiceModsListener each
				each.listModsFailed(this, id, message)
			end)
		end
	end
	
	/**
	 * \brief Service notification received.
	 */
	func void eventReceived(Service service, ServiceObject event)
		var String eventName = event.getChildAt("event").getString()
		
		if eventName.equals("initialized")
			if event.getChildAt("success").getBoolean()
				pIsInitialized = Boolean.new(true)
				
				if pInitListener != null
					pInitListener.initSucceeded(this)
				end
				
			else
				pIsInitialized = Boolean.new(false)
				
				if pInitListener != null
					pInitListener.initFailed(this, event.getChildAt("message").getString())
				end
			end
			
			pInitListener = null
		end
	end
	
	
	
	/**
	 * \brief Service module service instance.
	 */
	protected func Service getService()
		return pService
	end
	
	/**
	 * \brief Get error message from response.
	 */
	func String getErrorMessage(ServiceObject error)
		error = error.getChildAt("message")
		return error != null if error.getString() else "Unknown error"
	end
	
	
	
	private func void pFilterAddEnum(ServiceObject so, String key, Enumeration value)
		if value != null
			so.setStringChildAt(key, value.name())
		end
	end
	
	private func void pFilterAddStringSet(ServiceObject so, String key, Set values)
		if values != null
			var ServiceObject so2 = ServiceObject.newList()
			values.forEach(block String each
				so2.addStringChild(each)
			end)
			so.setChildAt(key, so2)
		end
	end
	
	private func void pFilterAddEnumSet(ServiceObject so, String key, Set values)
		if values != null
			var ServiceObject so2 = ServiceObject.newList()
			values.forEach(block Enumeration each
				so2.addStringChild(each.name())
			end)
			so.setChildAt(key, so2)
		end
	end
	
	private func void pFilterAddDate(ServiceObject so, String key, TimeDate date)
		if date != null
			var ServiceObject so2 = ServiceObject.new()
			so2.setIntChildAt("year", date.getYear())
			so2.setIntChildAt("month", date.getMonth())
			so2.setIntChildAt("day", date.getDay())
			so.setChildAt(key, so2)
		end
	end
	
	private func void pRecursiveServiceObject(Dictionary d, String key, ServiceObject so)
		select so.getValueType()
		case ServiceObjectType.boolean
			d.setAt(key, so.getBoolean())
		case ServiceObjectType.integer
			d.setAt(key, so.getInteger())
		case ServiceObjectType.floating
			d.setAt(key, so.getFloat())
		case ServiceObjectType.string
			d.setAt(key, so.getString())
		case ServiceObjectType.resource
			d.setAt(key, so.getResource())
		case ServiceObjectType.data
			d.setAt(key, so.getData())
		case ServiceObjectType.dictionary
			var Dictionary d2 = Dictionary.new()
			d.setAt(key, d2)
			so.getChildrenKeys().forEach(block String key2
				pRecursiveServiceObject(d2, key2, so.getChildAt(key2))
			end)
		end
	end
	
	private func void pLogDictionary(Console c, Dictionary d, String prefix)
		d.forEach(block String key, Object value
			if value castable Dictionary
				c.addMessage("{}- {}:".format(Array.newWith(prefix, key)))
				pLogDictionary(c, value cast Dictionary, prefix + "  ")
			else
				c.addMessage("{}- {}: {}".format(Array.newWith(prefix, key, value)))
			end
		end)
	end
end
