/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

namespace Dragengine.Commands


/**
 * \brief Binding of command to input event on device.
 * 
 * Bindings are identified by device and either axis or button identifier.
 * For quicker access the device and button index are used.
 */
class Binding
	var String pDeviceID, pSourceID
	var Command pCommand
	var InputEventSource pSystem
	var int pDeviceIndex, pSourceIndex
	var bool pInverseAxis, pSimulateAxisPressed, pVRHandFacingUser
	var float pDeadzone, pLinearity, pLinearityFactor
	
	
	/**
	 * \brief Create binding.
	 * \version 1.28
	 */
	func new(String deviceID, String sourceID, Command command)
		if deviceID == null or sourceID == null or command == null
			throw ENullPointer.new()
		end
		
		pDeviceID = deviceID
		pSourceID = sourceID
		pCommand = command
		pDeviceIndex = pSourceIndex = -1
		pLinearityFactor = 1
	end
	
	/** \brief Create binding. */
	func new(String deviceID, String sourceID, Command command, bool inverseAxis)\
	this(deviceID, sourceID, command)
		pInverseAxis = inverseAxis
	end
	
	/** \brief Create copy of binding. */
	func new(Binding binding)
		pDeviceID = binding.pDeviceID
		pSourceID = binding.pSourceID
		pCommand = binding.pCommand
		pInverseAxis = binding.pInverseAxis
		pSystem = binding.pSystem
		pDeviceIndex = binding.pDeviceIndex
		pSourceIndex = binding.pSourceIndex
		pSimulateAxisPressed = false
		pVRHandFacingUser = binding.pVRHandFacingUser
		pDeadzone = binding.pDeadzone
		pLinearity = binding.pLinearity
		pLinearityFactor = binding.pLinearityFactor
	end
	
	/** \brief Create copy of binding with different command. */
	func new(Binding binding, Command command) this(binding)
		if command == null
			throw ENullPointer.new()
		end
		pCommand = command
	end
	
	
	/** \brief Input device identifier*/
	func String getDeviceID()
		return pDeviceID
	end
	
	/** \brief Axis or button identifier. */
	func String getSourceID()
		return pSourceID
	end
	
	/** \brief Bound command. */
	func Command getCommand()
		return pCommand
	end
	
	
	/** \brief Inverse axis. */
	func bool getInverseAxis()
		return pInverseAxis
	end
	
	/**
	 * \brief Set inverse axis.
	 * \version 1.28
	 */
	func void setInverseAxis(bool inverseAxis)
		pInverseAxis = inverseAxis
	end
	
	/**
	 * \brief VR hand has to face user.
	 * \version 1.28
	 */
	func bool getVRHandFacingUser()
		return pVRHandFacingUser
	end
	
	/**
	 * \brief Set VR hand has to face user.
	 * \version 1.28
	 */
	func void setVRHandFacingUser(bool facingUser)
		pVRHandFacingUser = facingUser
	end
	
	/**
	 * \brief Deadzone as percentage of range (0..1).
	 * \version 1.28
	 * 
	 * For use with absolute axis input in the range from -1 to 1 or 0 to 1.
	 */
	func float getDeadzone()
		return pDeadzone
	end
	
	/**
	 * \brief Set deadzone as percentage of range (0..1).
	 * \version 1.28
	 * 
	 * For use with absolute axis input in the range from -1 to 1 or 0 to 1.
	 */
	func void setDeadzone(float deadzone)
		pDeadzone = DEMath.clamp(deadzone, 0.0, 1.0)
	end
	
	/**
	 * \brief Linearity of input.
	 * \version 1.28
	 * 
	 * Value of 0 is linear input. Values up to 1 map larger input range to small movement.
	 * Values down to -1 map larger input range to larger movement. 0 is the default.
	 * 
	 * Linearity is calculated like this:
	 * 
	 * | Linearity | Mapped value (x=input) |
	 * | --- | --- |
	 * | 0 | x |
	 * | 1/3 | pow(x, 2) |
	 * | 2/3 | pow(x, 4) |
	 * | 1 | pow(x, 8) |
	 * | -1/3 | pow(x, 1/2) |
	 * | -2/3 | pow(x, 1/4) |
	 * | -1 | pow(x, 1/8) |
	 * 
	 * For use with absolute axis input in the range from -1 to 1 or 0 to 1.
	 */
	func float getLinearity()
		return pLinearity
	end
	
	/**
	 * \brief Set linearity of input.
	 * \version 1.28
	 * \see #getLinearity()
	 * 
	 * For use with absolute axis input in the range from -1 to 1 or 0 to 1.
	 */
	func void setLinearity(float linearity)
		pLinearity = DEMath.clamp(linearity, -1.0, 1.0)
		
		if linearity > 0.001
			pLinearityFactor = DEMath.pow(2, pLinearity * 3)
			
		elif linearity < -0.001
			pLinearityFactor = DEMath.pow(2, 1 / (pLinearity * 3))
			
		else
			pLinearityFactor = 1
		end
	end
	
	/**
	 * \brief Map axis value using deadzone and linearity.
	 * \version 1.28
	 * \param value Value in the range from -1 to 1.
	 * \returns Mapped value in the range from -1 to 1.
	 * 
	 * For use with absolute axis input in the range from -1 to 1 or 0 to 1.
	 */
	func float mapAxisValue(float value)
		if value > 0
			return DEMath.pow(DEMath.linearStep(value, pDeadzone, 1), pLinearityFactor)
			
		else
			return -DEMath.pow(DEMath.linearStep(value, -1, -pDeadzone, 1, 0), pLinearityFactor)
		end
	end
	
	
	/**
	 * \brief System or null if not set.
	 * \version 1.6
	 */
	func InputEventSource getSystem()
		return pSystem
	end
	
	/**
	 * \brief Set system or null if not set.
	 * \version 1.6
	 */
	func void setSystem(InputEventSource system)
		pSystem = system
	end
	
	/** \brief Device index or -1 if not set. */
	func int getDeviceIndex()
		return pDeviceIndex
	end
	
	/** \brief Set device index or -1 if not set. */
	func void setDeviceIndex(int index)
		pDeviceIndex = index
	end
	
	/** \brief Source index or -1 if not set. */
	func int getSourceIndex()
		return pSourceIndex
	end
	
	/** \brief Set source index or -1 if not set. */
	func void setSourceIndex(int index)
		pSourceIndex = index
	end
	
	
	/**
	 * \brief Device or null if not set.
	 * \version 1.6
	 */
	func InputDevice getInputDevice()
		if pDeviceIndex == -1
			return null
		end
		
		select pSystem
		case InputEventSource.input
			return InputSystem.getDeviceAt(pDeviceIndex)
			
		case InputEventSource.vr
			return VRSystem.getDeviceAt(pDeviceIndex)
		end
		
		return null
	end
	
	/**
	 * \brief Device axis or null if not set.
	 * \version 1.6
	 */
	func InputDeviceAxis getInputDeviceAxis()
		if pSourceIndex != -1
			var InputDevice device = getInputDevice()
			if device != null
				return device.getAxisAt(pSourceIndex)
			end
		end
		return null
	end
	
	/**
	 * \brief Device button or null if not set.
	 * \version 1.6
	 */
	func InputDeviceButton getInputDeviceButton()
		if pSourceIndex != -1
			var InputDevice device = getInputDevice()
			if device != null
				return device.getButtonAt(pSourceIndex)
			end
		end
		return null
	end
	
	/**
	 * \brief Device feedback or null if not set.
	 * \version 1.6
	 */
	func InputDeviceFeedback getInputDeviceFeedback()
		if pSourceIndex != -1
			var InputDevice device = getInputDevice()
			if device != null
				return device.getFeedbackAt(pSourceIndex)
			end
		end
		return null
	end
	
	
	/** \brief Axis pressed simulation state. */
	func bool getSimulateAxisPressed()
		return pSimulateAxisPressed
	end
	
	/** \brief Set axis pressed simulation state. */
	func void setSimulateAxisPressed(bool pressed)
		pSimulateAxisPressed = pressed
	end
	
	
	/** \brief Bindings are equal. */
	func bool equals(Object other)
		if other castable Binding
			var Binding binding = other cast Binding
			return pDeviceID.equals(binding.pDeviceID) \
				and pSourceID.equals(binding.pSourceID) \
				and pInverseAxis == binding.pInverseAxis
			
		else
			return false
		end
	end
end
