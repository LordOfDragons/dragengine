/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland PlÃ¼ss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Scenery

pin Dragengine.ConversationSystem
pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Utils


/**
 * \brief Game world.
 * 
 * A single simulation unit in the game. Simple games require usually only one game world
 * containing all elements of the currently loaded map or level. More complex games can use
 * multiple game worlds for example to simulate development of the game world outside the
 * currently visible section. Every game world wraps an engine world resource. Elements
 * removed from the game world using removeElement are not disposed of. This allows to move
 * elements between game worlds. Elements removed using removeAllElements though get disposed.
 */
class GameWorld
	private var World pWorld
	private var SafeArray pElements
	private var SafeArray pThinkers
	private var Dictionary pElementIDMap
	private var SafeArray pEnterFrameOnce
	private var SpawnPointList pSpawnPoints
	private var TemporaryDecalManager pTempDecalMgr
	private var CachedVegetation pCachedVegetation
	private var UniqueID pNextObjectID
	private var UniqueIDRemapper pUniqueIDRemapper
	private var Vector pGravity
	private var RailList pRailList
	private var ConversationActorList pConvoActorList
	private var ConversationCoordSystemList pConvoCoordSystemList
	private var AnchoredElementList pAnchoredElementList
	private var StubGameWorld pStub
	private var Array pBehaviors
	private var bool pBehaviorsInited
	private var Array pThinkingBehaviors
	private var bool pEnablePersistency
	
	private var GWBehaviorOneShotSpeaker pBehaviorOneShotSpeaker
	
	
	
	/** \brief Create game world. */
	public func new()
		pWorld = World.new()
		pEnablePersistency = not Engine.isCompatibleVersionOlder(1, 17)
		
		pElements = SafeArray.new()
		pThinkers = SafeArray.new()
		pElementIDMap = Dictionary.new()
		pEnterFrameOnce = SafeArray.new()
		pSpawnPoints = SpawnPointList.new()
		pTempDecalMgr = TemporaryDecalManager.new()
		pUniqueIDRemapper = UniqueIDRemapper.new()
		pGravity = Vector.new(0, -9.81, 0)
		pRailList = RailList.new()
		pConvoActorList = ConversationActorList.new()
		pConvoCoordSystemList = ConversationCoordSystemList.new()
		pAnchoredElementList = AnchoredElementList.new()
		pBehaviors = Array.new()
		pThinkingBehaviors = Array.new()
		
		// add behaviors
		pBehaviorOneShotSpeaker = GWBehaviorOneShotSpeaker.new(this)
		addBehavior(pBehaviorOneShotSpeaker)
	end
	
	
	
	/** \brief Dispose of game world. */
	public func void dispose()
		/*
		// for debugging purpose this code here can be used
		removeAllElements()
		if pThinkers != null
			pThinkers.forEach(block Element each
				BaseGameApp.getApp().getConsole().addMessage("GameWorld.dispose: Object of class " + each.className() + " left behind thinker")
			end)
		end
		*/
		
		pElements.removeAll(block Element each
			each.setGameWorld(null)
			each.safeDispose()
		end)
		
		if pBehaviors != null
			pBehaviors.forEachReverse(block GWBehavior each
				each.dispose()
			end)
			pBehaviors = null
		end
		pThinkingBehaviors = null
		pBehaviorOneShotSpeaker = null
		
		pThinkers = null
		pEnterFrameOnce = null
		pElementIDMap = null
		
		if pCachedVegetation != null
			pCachedVegetation.setWorld(null)
			pCachedVegetation = null
		end
		
		pConvoActorList = null
		pConvoCoordSystemList = null
		pAnchoredElementList = null
		pTempDecalMgr = null
		pSpawnPoints = null
		
		if pRailList != null
			pRailList.dispose()
			pRailList = null
		end
		
		pWorld = null
		pStub = null
	end
	
	
	
	/** \brief Engine world resource. */
	public func World getWorld()
		return pWorld
	end
	
	
	
	/**
	 * \brief Count of behaviors.
	 * \version 1.17
	 */
	public func int getBehaviorCount()
		return pBehaviors.getCount()
	end
	
	/**
	 * \brief Behavior at index.
	 * \version 1.17
	 */
	public func GWBehavior getBehaviorAt(int index)
		return pBehaviors.getAt(index) cast GWBehavior
	end
	
	/**
	 * \brief Add behavior.
	 * \version 1.17
	 * 
	 * This is called by constructors of class implementing GWBehavior. Usually you do not
	 * have to call this manually.
	 */
	public func void addBehavior(GWBehavior behavior)
		if behavior == null or pBehaviors.has(behavior)
			throw EInvalidParam.new("duplicate behavior")
		end
		
		pBehaviors.add(behavior)
		
		if behavior.requiresThink()
			pThinkingBehaviors.add(behavior)
		end
		
		if pBehaviorsInited
			behavior.init(pStub)
		end
	end
	
	/**
	 * \brief Visit behaviors with block.
	 * \versoin 1.17
	 * 
	 * Block is required to have one parameter of type GWBehavior or subclass thereof.
	 * Block is called only for behaviors castable to block parameter type.
	 */
	public func void forEachBehavior(Block ablock)
		pBehaviors.forEachCastable(ablock)
	end
	
	/**
	 * \brief Find behavior with block.
	 * \version 1.17
	 * 
	 * Block is required to have one parameter GWBehavior or subclass thereof and returning
	 * true if the right behavior is found otherwise false. Block is called only for
	 * behaviors castable to block parameter type.
	 */
	public func GWBehavior findBehavior(Block ablock)
		return pBehaviors.findCastable(ablock) cast GWBehavior
	end
	
	/**
	 * \brief Collect behaviors with block into Array.
	 * \version 1.17
	 * 
	 * Block is required to have one parameter GWBehavior or subclass thereof and returning
	 * true if the right behavior is found otherwise false. Block is called only for
	 * behaviors castable to block parameter type.
	 */
	public func Array collectBehaviors(Block ablock)
		return pBehaviors.collectCastable(ablock)
	end
	
	/**
	 * \brief Requires thinking changed.
	 * \version 1.17
	 * 
	 * Called by GWBehavior if their requirement for thinking changed. This means requiresThink()
	 * implementations return different values than last time they have been checked. Game world
	 * will check all behaviors for their thinking requirements changes. Using this method helps
	 * to reduce script processing load by not making calling update(), think() and postThink()
	 * on behaviors not requiring it.
	 */
	public func void requiresThinkChanged()
		pThinkingBehaviors.removeAll()
		pBehaviors.forEach(block GWBehavior each
			if each.requiresThink()
				pThinkingBehaviors.add(each)
			end
		end)
	end
	
	
	
	/**
	 * \brief One shot speaker game world behavior.
	 * \version 1.17
	 */
	public func GWBehaviorOneShotSpeaker getBehaviorOneShotSpeaker()
		return pBehaviorOneShotSpeaker
	end
	
	
	
	/**
	 * \brief Enable persistency (backwards compatibility).
	 * \version 1.17
	 * 
	 * Since Drag[en]gine 1.17 GameWorld supports persistency to load and save game world
	 * behavior states. This is incompatible with old saves where GameWorld did not persist
	 * any data. To support loading and saving saves prior to 1.17 use this method.
	 * 
	 * - While loading save states created prior to 1.17 set false
	 * - While loading save states created using 1.17 or later set to true
	 * - While saving converted save states supported 1.17 and later set to true
	 * - While saving save states not supporting 1.17 or later set to false
	 * 
	 * Hence to support loading old saves and saving new saves load with false and save with true.
	 * 
	 * By default enable persistency is set to true if the required version of the game project
	 * is set to 1.17 or newer and false otherwise. Hence projects require an earlier version
	 * will always operate with enable persistency set to false keeping them compatible while
	 * projects requiring 1.17 or newer enable persistency.
	 */
	public func bool getEnablePersistency()
		return pEnablePersistency
	end
	
	public func void setEnablePersistency(bool enable)
		pEnablePersistency = enable
	end
	
	
	
	/** \brief Add Element. */
	public func void addElement(Element element)
		if element.getGameWorld() == this
			return // adding more than once is allowed to make scripts simpler and more robust
		end
		if element.getGameWorld() != null
			throw EInvalidParam.new()
		end
		
		pElements.add(element)
		element.setGameWorld(this)
		pElementIDMap.setAt(element.getID(), element)
	end
	
// 	public static var RuntimeMeter rtm = null
	/** \brief Remove Element without disposing it. */
	public func void removeElement(Element element)
		/*if rtm != null
			rtm.reset(0, 1)
			
			pElements.remove(element)
			rtm.counterAdd(0, 6)
			
			element.setGameWorld(null)
			rtm.counterAdd(0, 7)
			
			if pThinkers.has(element)
				BaseGameApp.getApp().getConsole().addMessage("GameWorld.removeElement: Object of class " + element.className() + " left behind thinker")
				pThinkers.remove(element)
			end
			var int index = pEnterFrameOnce.indexOf(element)
			if index != -1
				BaseGameApp.getApp().getConsole().addMessage("GameWorld.removeElement: Object of class " + element.className() + " left behind enter frame once")
				pEnterFrameOnce.removeFrom(index)
			end
			rtm.counterAdd(0, 8)
			return
		end*/
		
		pElements.remove(element)
		element.setGameWorld(null)
		pElementIDMap.removeIfExisting(element.getID())
		
		if pThinkers.has(element)
			BaseGameApp.getApp().getConsole().addMessage("GameWorld.removeElement: Object of class " + element.className() + " left behind thinker")
			pThinkers.remove(element)
		end
		
		var int index = pEnterFrameOnce.indexOf(element)
		if index != -1
			BaseGameApp.getApp().getConsole().addMessage("GameWorld.removeElement: Object of class " + element.className() + " left behind enter frame once")
			pEnterFrameOnce.removeFrom(index)
		end
	end
	
	/** \brief Remove all elements calling safeDispose() on them. */
	public func void removeAllElements()
		pElements.removeAll(block Element each
			each.setGameWorld(null)
			each.safeDispose()
		end)
		pElementIDMap.removeAll()
	end
	
	/** \brief Element is present. */
	public func bool hasElement(Element element)
		return pElements.has(element)
	end
	
	/** \brief Element with identifier or \em null if absent. */
	public func Element getElementWithID(UniqueID id)
		return pElementIDMap.getAt(id, null) cast Element
// 		return pElements.find(block Element each
// 			return each.getID().equals(id)
// 		end) cast Element
	end
	
	/** \brief Visit elements. */
	public func void visitElements(ElementVisitor visitor)
		pElements.forEach(block Element each
			each.visit(visitor)
		end)
	end
	
	/** \brief Visit elements with block with parameter Element. */
	public func void forEachElement(Block ablock)
		pElements.forEach(ablock)
	end
	
	/** \brief Find element with block with parameter Element. */
	public func Element findElement(Block ablock)
		return pElements.find(ablock) cast Element
	end
	
	
	
	/** \brief Add element requiring thinking on frame updates. */
	public func void addThinker(Element element)
		if element == null
			throw EInvalidParam.new()
		end
		pThinkers.addIfAbsent(element)
	end
	
	/** \brief Remove element requiring thinking on frame updates. */
	public func void removeThinker(Element element)
		pThinkers.removeIfPresent(element)
	end
	
	/** \brief Visit thinkers with block with parameter Element. */
	public func void forEachThinker(Block ablock)
		pThinkers.forEach(ablock)
	end
	
	
	
	/** \brief Call Element.enterFrame() on element once at start of next frame update. */
	public func void addEnterFrameOnce(Element element)
		if element == null
			throw EInvalidParam.new()
		end
		if not pEnterFrameOnce.has(element)
			pEnterFrameOnce.add(element)
		end
	end
	
	/** \brief Stop call Element.enterFrame() on element once at start of next frame update. */
	public func void removeEnterFrameOnce(Element element)
		var int index = pEnterFrameOnce.indexOf(element)
		if index != -1
			pEnterFrameOnce.removeFrom(index)
		end
	end
	
	
	
	/** \brief Cached vegetation. */
	public func CachedVegetation getCachedVegetation()
		return pCachedVegetation
	end
	
	/** \brief Set cached vegetation. */
	public func void setCachedVegetation(CachedVegetation cachedVegetation)
		pCachedVegetation = cachedVegetation
		if cachedVegetation != null
			cachedVegetation.setWorld(pWorld)
		end
	end
	
	/** \brief Gravity. */
	public func Vector getGravity()
		return pGravity
	end
	
	/** \brief Set gravity. */
	public func void setGravity(Vector gravity)
		if gravity == null
			throw ENullPointer.new("gravity")
		end
		
		pGravity = gravity
	end
	
	
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func LayerMask getLayerMaskOneShotSpeaker()
		return pBehaviorOneShotSpeaker.getLayerMask()
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void setLayerMaskOneShotSpeaker(LayerMask layerMask)
		pBehaviorOneShotSpeaker.setLayerMask(layerMask)
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void addOneShotSpeaker(Speaker speaker)
		pBehaviorOneShotSpeaker.addSpeaker(speaker)
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void playSoundOnce(Sound sound, Element element, float volume, float range)
		pBehaviorOneShotSpeaker.playSoundOnce(sound, element, volume, range)
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void playSoundOnce(Sound sound, DVector position, float volume, float range)
		pBehaviorOneShotSpeaker.playSoundOnce(sound, position, volume, range)
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void playSoundOnce(Sound sound, DVector position, Quaternion orientation, \
	float volume, float range)
		pBehaviorOneShotSpeaker.playSoundOnce(sound, position, orientation, volume, range)
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void playSynthesizerOnce(SynthesizerInstance synthesizer, Element element, \
	float volume, float range)
		pBehaviorOneShotSpeaker.playSynthesizerOnce(synthesizer, element, volume, range)
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void playSynthesizerOnce(SynthesizerInstance synthesizer, DVector position, \
	float volume, float range)
		pBehaviorOneShotSpeaker.playSynthesizerOnce(synthesizer, position, volume, range)
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void playSynthesizerOnce(SynthesizerInstance synthesizer, DVector position, \
	Quaternion orientation, float volume, float range)
		pBehaviorOneShotSpeaker.playSynthesizerOnce(synthesizer, position, orientation, volume, range)
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void removeFinishedOneShotSpeakers()
		pBehaviorOneShotSpeaker.removeFinishedSpeakers()
	end
	
	/** \deprecated Use getBehaviorOneShotSpeaker(). */
	public func void removeAllOneShotSpeakers()
		pBehaviorOneShotSpeaker.removeAllSpeakers()
	end
	
	
	
	/** \brief Make elements think. */
	public func void think(float elapsed)
		pThinkingBehaviors.forEach(block GWBehavior each
			each.think(elapsed)
		end)
		
		pThinkers.forEach(block Element each
			each.think(elapsed)
		end)
	end
	
	/** \brief Make elements think after physics simulation. */
	public func void postThink(float elapsed)
		pThinkers.forEach(block Element each
			each.postThink(elapsed)
		end)
		
		pThinkingBehaviors.forEach(block GWBehavior each
			each.postThink(elapsed)
		end)
	end
	
	/**
	 * \brief Call Element.enterFrame() on registered elements then unregister all elements.
	 * \warning Do not call addEnterFrameOnce or removeEnterFrameOnce from inside enterFrame().
	 */
	public func void enterFrame()
		if pEnterFrameOnce.getCount() == 0
			return
		end
		
		pEnterFrameOnce.forEach(block Element each
			each.enterFrame()
		end)
		pEnterFrameOnce.removeAll()
	end
	
	/**
	 * \brief Update game world.
	 * \details Call once at beginning of frame update cycle. Afterwards world can
	 *          be rendered multiple times.
	 */
	public func void update(float elapsed)
		pThinkingBehaviors.forEach(block GWBehavior each
			each.update(elapsed)
		end)
		
		enterFrame()
		
		pWorld.update(elapsed)
		pTempDecalMgr.update(elapsed)
		
		think(elapsed)
		pWorld.detectCollisions(elapsed)
		postThink(elapsed)
	end
	
	/** \brief Update game world with debug timing. */
	public func void updateDebug(float elapsed, \
			Debugging.DebugPerformanceCounter debugUpdate, \
			Debugging.DebugPerformanceCounter debugThink, \
			Debugging.DebugPerformanceCounter debugCollisions, \
			Debugging.DebugPerformanceCounter debugPostThink)
		pBehaviors.forEach(block GWBehavior each
			each.update(elapsed)
		end)
		
		enterFrame()
		
		debugUpdate.start()
		pWorld.update(elapsed)
		debugUpdate.stop()
		pTempDecalMgr.update(elapsed)
		
		debugThink.start()
		think(elapsed)
		debugThink.stop()
		debugCollisions.start()
		pWorld.detectCollisions(elapsed)
		debugCollisions.stop()
		debugPostThink.start()
		postThink(elapsed)
		debugPostThink.stop()
	end
	
	
	
	/** \brief Next object ID from world file required for saving and remapping ID ranges. */
	public func UniqueID getNextObjectID()
		return pNextObjectID
	end
	
	/** \brief Set next object ID from world file required for saving and remapping ID ranges. */
	public func void setNextObjectID(UniqueID nextObjectID)
		pNextObjectID = nextObjectID
	end
	
	/** \brief Unique ID remapper. */
	public func UniqueIDRemapper getUniqueIDRemapper()
		return pUniqueIDRemapper
	end
	
	/** \brief Set Unique ID remapper. */
	public func void setUniqueIDRemapper(UniqueIDRemapper remapper)
		if remapper == null
			throw EInvalidParam.new()
		end
		pUniqueIDRemapper = remapper
	end
	
	
	
	/**
	 * \brief Stub used to create game world.
	 * \version 1.17
	 */
	public func StubGameWorld getStub()
		return pStub
	end
	
	/**
	 * \brief Set stub used to create game world.
	 * \version 1.17
	 */
	public func void setStub(StubGameWorld stub)
		pStub = stub
	end
	
	
	
	/**
	 * \brief Init game world from stub.
	 * \version 1.17
	 * 
	 * Subclass is required to super-call init() to init behaviors properly.
	 */
	public func void init(StubGameWorld stub)
		pBehaviors.forEach(block GWBehavior each
			each.init(stub)
		end)
		pBehaviorsInited = true
	end
	
	
	
	/**
	 * \brief Read from file.
	 * 
	 * Subclass has to super-call readFromFile() to save behaviors properly.
	 */
	public func void readFromFile(PersistencyEnvironment env, FileReader reader)
		if not pEnablePersistency
			return
		end
		
		select reader.readByte() // version
		case 0
			var Dictionary map = Dictionary.new()
			pBehaviors.forEach(block int index, GWBehavior each
				map.setAt((pBehaviors.getAt(index) cast GWBehavior).getBehaviorID(), each)
			end)
			
			var int i, dataLength, count = reader.readUShort()
			var GWBehavior behavior
			var String identifier
			
			for i = 0 to count
				identifier = reader.readString8()
				behavior = map.getAt(identifier, null) cast GWBehavior
				dataLength = reader.readInt()
				
				if behavior != null
					behavior.readFromFile(env, reader)
					
				elif pBehaviors.find(block int index, GWBehavior each
					if each.supportsBehaviorID(identifier)
						each.loadSupportedData(identifier, env, reader)
						return true
						
					else
						return false
					end
					
				end) == null
					reader.movePosition(dataLength)
				end
			end
			
		else
			throw EInvalidParam.new("unsupported version")
		end
	end
	
	/**
	 * \brief Write to file.
	 * 
	 * Subclass has to super-call writeToFile() to save behaviors properly.
	 */
	public func void writeToFile(PersistencyEnvironment env, FileWriter writer)
		if not pEnablePersistency
			return
		end
		
		writer.writeByte(0) // version
		
		var Array behaviors = pBehaviors.collect(block GWBehavior each
			return each.requiresPersistency()
		end)
		
		writer.writeUShort(behaviors.getCount())
		
		if behaviors.getCount() > 0
			var MemoryFile behaviorData = MemoryFile.new("behaviorData")
			
			behaviors.forEach(block GWBehavior each
				each.writeToFile(env, behaviorData.getWriter(false))
				writer.writeString8(each.getBehaviorID())
				writer.writeInt(behaviorData.getSize())
				writer.writeData(behaviorData.getReader())
			end)
		end
	end
	
	/**
	 * \brief Read element stubs from file.
	 * 
	 * Reads first the next object ID and Unique ID remapper. Then remaps the stub elements
	 * in the stub world. Then reads the element stubs.
	 */
	public func void readElementStubsFromFile(PersistencyEnvironment env, FileReader reader, \
	MutableID idGenerator, ElementClassList elementClassList, StubGameWorld stubWorld)
		select reader.readByte() // version
		case 0
			var UniqueID lastNextObjectID = UniqueID.readFromFile(reader)
			pUniqueIDRemapper = UniqueIDRemapper.readFromFile(reader)
			
			var UniqueID nextObjectID = stubWorld.getNextObjectID()
			if nextObjectID > lastNextObjectID
				stubWorld.setNewElementsRange(pUniqueIDRemapper.add(\
					lastNextObjectID, nextObjectID, idGenerator.toUniqueID()))
				idGenerator.incrementBy(nextObjectID - lastNextObjectID)
			end
			
			stubWorld.remapObjectIDs(pUniqueIDRemapper)
			stubWorld.readElementStubsFromFile(env, reader, elementClassList)
			
		else
			throw EInvalidParam.new("unsupported version")
		end
	end
	
	/**
	 * \brief Write element stubs to file.
	 * 
	 * Writes first the next object ID and Unique ID remapper. While loading the next object
	 * ID and mapper can be used to modify remapping in case the object ID range of the
	 * world changed in the mean time.
	 * 
	 * Ignores elements with element classes marked not persistable. For each element the
	 * element stub is written used to load or create the element.
	 * 
	 * Not persistable elements have to be loaded from a world file even if using a file reader. 
	 * 
	 * The two methods writeElementStubsToFile() and writeDynamicElementDataToFile() are
	 * both required to properly restore elements. They are not merged in one to allow
	 * preloading. For this to work element stubs have to be read first to start preloading.
	 * Once done the elements are created and their dynamic data read. The order of stubs
	 * has to stay the same for them to properly read their dynamic data.
	 */
	public func void writeElementStubsToFile(PersistencyEnvironment env, FileWriter writer)
		writer.writeByte(0) // version
		
		pNextObjectID.writeToFile(writer)
		pUniqueIDRemapper.writeToFile(writer)
		
		pElements.forEach(block Element each
			if each.getClass().getPersistable()
				each.getStub().writeToFile(writer)
			end
		end)
		writer.writeString8("") // empty classname is end of list marker
	end
	
	/**
	 * \brief Write dynamic element data to file.
	 * 
	 * Ignores elements with element classes marked not persistable. For each element the
	 * Element.writeToFile() method is called to save dynamic parameters.
	 * 
	 * The two methods writeElementStubsToFile() and writeDynamicElementDataToFile() are
	 * both required to properly restore elements. They are not merged in one to allow
	 * preloading. For this to work element stubs have to be read first to start preloading.
	 * Once done the elements are created and their dynamic data read. The order of stubs
	 * has to stay the same for them to properly read their dynamic data.
	 */
	public func void writeDynamicElementDataToFile(PersistencyEnvironment env, FileWriter writer)
		if env.getPersistency().getDebugEnableCanaryValue()
			pElements.forEach(block Element each
				if each.getClass().getPersistable()
					writer.writeString(Persistency.debugCanaryValue_BEGIN)
					each.writeToFile(env, writer)
					writer.writeString(Persistency.debugCanaryValue_END)
				end
			end)
			
		else
			pElements.forEach(block Element each
				if each.getClass().getPersistable()
					each.writeToFile(env, writer)
				end
			end)
		end
	end
	
	
	
	/** \brief Spawn point list. */
	public func SpawnPointList getSpawnPoints()
		return pSpawnPoints
	end
	
	/** \brief Rail list. */
	public func RailList getRailList()
		return pRailList
	end
	
	/** \brief Conversation actor list. */
	public func ConversationActorList getConvoActorList()
		return pConvoActorList
	end
	
	/** \brief Conversation coordinate system list. */
	public func ConversationCoordSystemList getConvoCoordSystemList()
		return pConvoCoordSystemList
	end
	
	/** \brief Anchored element list. */
	public func AnchoredElementList getAnchoredElementList()
		return pAnchoredElementList
	end
	
	
	
	/** \brief Temporary decal manager. */
	public func TemporaryDecalManager getTemporaryDecalManager()
		return pTempDecalMgr
	end
	
	/** \brief Set temporary decal manager. */
	public func void setTemporaryDecalManager(TemporaryDecalManager manager)
		if manager == null
			throw EInvalidParam.new()
		end
		pTempDecalMgr = manager
	end
	
	
	
	/**
	 * \brief Collect debug statistics.
	 * 
	 * Returns a dictionary with these values:
	 * - 'elements': Number of elements.
	 * - 'thinkers': Number of thinking elements.
	 * - 'enterFrameOnce': Number of enter frame once elements.
	 * - 'oneShotSpeakers': Number of one shot speakers.
	 * - 'spawnPoints': Number of spawn points.
	 * - 'temporaryDecals': Number of temporary decals.
	 * - 'resources.camera': Number of camera resources.
	 * - 'resources.speaker': Number of speaker resources.
	 * - 'resources.microphone': Number of microphone resources.
	 * - 'resources.networkState': Number of network state resources.
	 * - 'resources.component': Number of component resources.
	 * - 'resources.light': Number of light resources.
	 * - 'resources.collider': Number of collider resources.
	 * - 'resources.lumimeter': Number of lumimeter resources.
	 * - 'resources.touchSensor': Number of touch sensor resources.
	 * - 'resources.propField': Number of prop field resources.
	 * - 'resources.forceField': Number of force field resources.
	 * - 'resources.particleEmitter': Number of particle emitter instance resources.
	 * - 'resources.debugDrawer': Number of debug drawer resources.
	 * - 'resources.navigationSpace': Number of navigation space resources.
	 * - 'resources.navigationBlocker': Number of navigation blocker resources.
	 * - 'resources.navigator': Number of navigator resources.
	 * - 'resources.envMapProbe': Number of environment map probe resources.
	 */
	public func Dictionary debugStatistics()
		var Dictionary stats = Dictionary.new()
		stats.setAt("elements", pElements.getCount())
		stats.setAt("thinkers", pThinkers.getCount())
		stats.setAt("enterFrameOnce", pEnterFrameOnce.getCount())
		stats.setAt("oneShotSpeakers", pBehaviorOneShotSpeaker.getSpeakerCount())
		stats.setAt("spawnPoints", pSpawnPoints.getCount())
		stats.setAt("rails", pRailList.getCount())
		stats.setAt("temporaryDecals", pTempDecalMgr.getCount())
		stats.setAt("resources.camera", pWorld.getCameraCount())
		stats.setAt("resources.speaker", pWorld.getSpeakerCount())
		stats.setAt("resources.microphone", pWorld.getMicrophoneCount())
		stats.setAt("resources.networkState", pWorld.getNetworkStateCount())
		stats.setAt("resources.component", pWorld.getComponentCount())
		stats.setAt("resources.light", pWorld.getLightCount())
		stats.setAt("resources.collider", pWorld.getColliderCount())
		stats.setAt("resources.lumimeter", pWorld.getLumimeterCount())
		stats.setAt("resources.touchSensor", pWorld.getTouchSensorCount())
		stats.setAt("resources.propField", pWorld.getPropFieldCount())
		stats.setAt("resources.forceField", pWorld.getForceFieldCount())
		stats.setAt("resources.particleEmitter", pWorld.getParticleEmitterCount())
		stats.setAt("resources.debugDrawer", pWorld.getDebugDrawerCount())
		stats.setAt("resources.navigationSpace", pWorld.getNavigationSpaceCount())
		stats.setAt("resources.navigationBlocker", pWorld.getNavigationBlockerCount())
		stats.setAt("resources.navigator", pWorld.getNavigatorCount())
		stats.setAt("resources.envMapProbe", pWorld.getEnvMapProbeCount())
		return stats
	end
	
	/**
	 * \brief Retrieves some summary statistics.
	 * 
	 * Returns a dictionary with these values.
	 * - 'thinkers': Dictionary containing as keys the element class name of all
	 *               thinkers with value occurance count.
	 * - 'enterFrameOnce': Dictionary containing as keys the element class name of all
	 *                     enter frame once with value occurance count.
	 */
	public func Dictionary debugStatisticsSummary()
		var Dictionary summary, stats = Dictionary.new()
		var String key
		
		summary = Dictionary.new()
		pThinkers.forEach(block Element each
			key = each.getClass().getClassname()
			summary.setAt(key, summary.getAt(key, 0) cast int + 1)
		end)
		stats.setAt("thinkers", summary)
		
		summary = Dictionary.new()
		pEnterFrameOnce.forEach(block Element each
			key = each.getClass().getClassname()
			summary.setAt(key, summary.getAt(key, 0) cast int + 1)
		end)
		stats.setAt("enterFrameOnce", summary)
		
		return stats
	end
	
	/** \brief Print statistics to console. */
	public func void debugPrintStatistics(Console console)
		var Dictionary stats = debugStatistics()
		stats.getKeys().sorted().forEach(block String key
			console.addMessage("- " + key + ": " + stats.getAt(key))
		end)
	end
	
	/** \brief Print statistics summary to console. */
	public func void debugPrintStatisticsSummary(Console console)
		var Dictionary summary, stats = debugStatisticsSummary()
		stats.getKeys().sorted().forEach(block String key
			console.addMessage("- " + key + ":")
			summary = stats.getAt(key) cast Dictionary
			summary.getKeys().sorted().forEach(block String key2
				console.addMessage("  - " + key2 + ": " + summary.getAt(key2))
			end)
		end)
	end
end
