/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland PlÃ¼ss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Scenery

pin Dragengine.ConversationSystem
pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Utils


/**
 * \brief Game world.
 * 
 * A single simulation unit in the game. Simple games require usually only one game world
 * containing all elements of the currently loaded map or level. More complex games can use
 * multiple game worlds for example to simulate development of the game world outside the
 * currently visible section. Every game world wraps an engine world resource. Elements
 * removed from the game world using removeElement are not disposed of. This allows to move
 * elements between game worlds. Elements removed using removeAllElements though get disposed.
 */
class GameWorld
	private var World pWorld
	private var SafeArray pElements
	private var SafeArray pThinkers
	private var Dictionary pElementIDMap
	private var Array pEnterFrameOnce
	private var LayerMask pLayerMaskOneShotSpeaker
	private var Array pOneShotSpeakers
	private var SpawnPointList pSpawnPoints
	private var TemporaryDecalManager pTempDecalMgr
	private var CachedVegetation pCachedVegetation
	private var UniqueID pNextObjectID
	private var UniqueIDRemapper pUniqueIDRemapper
	private var Vector pGravity
	private var RailList pRailList
	private var ConversationActorList pConvoActorList
	private var ConversationCoordSystemList pConvoCoordSystemList
	private var AnchoredElementList pAnchoredElementList
	private var StubGameWorld pStub
	
	
	
	/** \brief Create game world. */
	public func new()
		pWorld = World.new()
		
		pElements = SafeArray.new()
		pThinkers = SafeArray.new()
		pElementIDMap = Dictionary.new()
		pEnterFrameOnce = Array.new()
		pLayerMaskOneShotSpeaker = LayerMask.newWith(BaseGameApp.WorldLayerBit.audio)
		pOneShotSpeakers = Array.new()
		pSpawnPoints = SpawnPointList.new()
		pTempDecalMgr = TemporaryDecalManager.new()
		pUniqueIDRemapper = UniqueIDRemapper.new()
		pGravity = Vector.new(0.0, -9.81, 0.0)
		pRailList = RailList.new()
		pConvoActorList = ConversationActorList.new()
		pConvoCoordSystemList = ConversationCoordSystemList.new()
		pAnchoredElementList = AnchoredElementList.new()
	end
	
	
	
	/** \brief Dispose of game world. */
	public func void dispose()
		/*
		// for debugging purpose this code here can be used
		removeAllElements()
		if pThinkers != null
			pThinkers.forEach(block Element each
				BaseGameApp.getApp().getConsole().addMessage("GameWorld.dispose: Object of class " + each.className() + " left behind thinker")
			end)
		end
		*/
		
		pElements.removeAll(block Element each
			each.setGameWorld(null)
			each.safeDispose()
		end)
		pElementIDMap = null
		
		pThinkers = null
		pEnterFrameOnce = null
		
		if pCachedVegetation != null
			pCachedVegetation.setWorld(null)
			pCachedVegetation = null
		end
		
		pConvoActorList = null
		pConvoCoordSystemList = null
		pAnchoredElementList = null
		pTempDecalMgr = null
		pOneShotSpeakers = null
		pSpawnPoints = null
		
		if pRailList != null
			pRailList.dispose()
			pRailList = null
		end
		
		pWorld = null
		pStub = null
	end
	
	
	
	/** \brief Engine world resource. */
	public func World getWorld()
		return pWorld
	end
	
	
	
	/** \brief Add Element. */
	public func void addElement(Element element)
		if element.getGameWorld() == this
			return // adding more than once is allowed to make scripts simpler and more robust
		end
		if element.getGameWorld() != null
			throw EInvalidParam.new()
		end
		
		pElements.add(element)
		element.setGameWorld(this)
		pElementIDMap.setAt(element.getID(), element)
	end
	
// 	public static var RuntimeMeter rtm = null
	/** \brief Remove Element without disposing it. */
	public func void removeElement(Element element)
		/*if rtm != null
			rtm.reset(0, 1)
			
			pElements.remove(element)
			rtm.counterAdd(0, 6)
			
			element.setGameWorld(null)
			rtm.counterAdd(0, 7)
			
			if pThinkers.has(element)
				BaseGameApp.getApp().getConsole().addMessage("GameWorld.removeElement: Object of class " + element.className() + " left behind thinker")
				pThinkers.remove(element)
			end
			var int index = pEnterFrameOnce.indexOf(element)
			if index != -1
				BaseGameApp.getApp().getConsole().addMessage("GameWorld.removeElement: Object of class " + element.className() + " left behind enter frame once")
				pEnterFrameOnce.removeFrom(index)
			end
			rtm.counterAdd(0, 8)
			return
		end*/
		
		pElements.remove(element)
		element.setGameWorld(null)
		pElementIDMap.removeIfExisting(element.getID())
		
		if pThinkers.has(element)
			BaseGameApp.getApp().getConsole().addMessage("GameWorld.removeElement: Object of class " + element.className() + " left behind thinker")
			pThinkers.remove(element)
		end
		
		var int index = pEnterFrameOnce.indexOf(element)
		if index != -1
			BaseGameApp.getApp().getConsole().addMessage("GameWorld.removeElement: Object of class " + element.className() + " left behind enter frame once")
			pEnterFrameOnce.removeFrom(index)
		end
	end
	
	/** \brief Remove all elements calling safeDispose() on them. */
	public func void removeAllElements()
		pElements.removeAll(block Element each
			each.setGameWorld(null)
			each.safeDispose()
		end)
		pElementIDMap.removeAll()
	end
	
	/** \brief Element is present. */
	public func bool hasElement(Element element)
		return pElements.has(element)
	end
	
	/** \brief Element with identifier or \em null if absent. */
	public func Element getElementWithID(UniqueID id)
		return pElementIDMap.getAt(id, null) cast Element
// 		return pElements.find(block Element each
// 			return each.getID().equals(id)
// 		end) cast Element
	end
	
	/** \brief Visit elements. */
	public func void visitElements(ElementVisitor visitor)
		pElements.forEach(block Element each
			each.visit(visitor)
		end)
	end
	
	/** \brief Visit elements with block with parameter Element. */
	public func void forEachElement(Block ablock)
		pElements.forEach(ablock)
	end
	
	/** \brief Find element with block with parameter Element. */
	public func Element findElement(Block ablock)
		return pElements.find(ablock) cast Element
	end
	
	
	
	/** \brief Add element requiring thinking on frame updates. */
	public func void addThinker(Element element)
		if element == null
			throw EInvalidParam.new()
		end
		pThinkers.addIfAbsent(element)
	end
	
	/** \brief Remove element requiring thinking on frame updates. */
	public func void removeThinker(Element element)
		pThinkers.removeIfPresent(element)
	end
	
	/** \brief Visit thinkers with block with parameter Element. */
	public func void forEachThinker(Block ablock)
		pThinkers.forEach(ablock)
	end
	
	
	
	/** \brief Call Element.enterFrame() on element once at start of next frame update. */
	public func void addEnterFrameOnce(Element element)
		if element == null
			throw EInvalidParam.new()
		end
		if not pEnterFrameOnce.has(element)
			pEnterFrameOnce.add(element)
		end
	end
	
	/** \brief Stop call Element.enterFrame() on element once at start of next frame update. */
	public func void removeEnterFrameOnce(Element element)
		var int index = pEnterFrameOnce.indexOf(element)
		if index != -1
			pEnterFrameOnce.removeFrom(index)
		end
	end
	
	
	
	/** \brief Cached vegetation. */
	public func CachedVegetation getCachedVegetation()
		return pCachedVegetation
	end
	
	/** \brief Set cached vegetation. */
	public func void setCachedVegetation(CachedVegetation cachedVegetation)
		pCachedVegetation = cachedVegetation
		if cachedVegetation != null
			cachedVegetation.setWorld(pWorld)
		end
	end
	
	/** \brief Gravity. */
	public func Vector getGravity()
		return pGravity
	end
	
	/** \brief Set gravity. */
	public func void setGravity(Vector gravity)
		if gravity == null
			throw EInvalidParam.new()
		end
		pGravity = gravity
	end
	
	
	
	/** \brief Layer mask to use for one shot speaker. */
	public func LayerMask getLayerMaskOneShotSpeaker()
		return pLayerMaskOneShotSpeaker
	end
	
	/** \brief Set layer mask to use for one shot speaker. */
	public func void setLayerMaskOneShotSpeaker(LayerMask layerMask)
		if layerMask == null
			throw EInvalidParam.new()
		end
		pLayerMaskOneShotSpeaker = layerMask
	end
	
	/**
	 * \brief Add one shot speaker.
	 * \details Plays a short sound once and will be deleted once finished playing.
	 */
	public func void addOneShotSpeaker(Speaker speaker)
		speaker.setLooping(false) // just in case somebody forgot it
		speaker.play()
		pWorld.addSpeaker(speaker)
		pOneShotSpeakers.add(speaker)
	end
	
	/**
	 * \brief Play sound once.
	 * \details Creates a speaker with the sound and parameters playing it once.
	 *          If sound it \em null nothing is done.
	 */
	public func void playSoundOnce(Sound sound, Element element, float volume, float range)
		playSoundOnce(sound, element.getPosition(), element.getOrientation(), volume, range)
	end
	
	/**
	 * \brief Play sound once.
	 * \details Creates a speaker with the sound and parameters playing it once.
	 *          If sound it \em null nothing is done.
	 */
	public func void playSoundOnce(Sound sound, DVector position, float volume, float range)
		playSoundOnce(sound, position, Quaternion.new(), volume, range)
	end
	
	/**
	 * \brief Play sound once.
	 * \details Creates a speaker with the sound and parameters playing it once.
	 *          If sound it \em null nothing is done.
	 */
	public func void playSoundOnce(Sound sound, DVector position, Quaternion orientation, \
	float volume, float range)
		if sound == null
			return
		end
		
		var Speaker speaker = Speaker.new()
		speaker.setSound(sound)
		speaker.setPosition(position)
		speaker.setOrientation(orientation)
		speaker.setLooping(false)
		speaker.setVolume(volume)
		speaker.setRange(range)
		speaker.setLayerMask(pLayerMaskOneShotSpeaker)
		speaker.play()
		
		pWorld.addSpeaker(speaker)
		pOneShotSpeakers.add(speaker)
	end
	
	/**
	 * \brief Play synthesizer instance once.
	 * \details Creates speaker with synthesizer instance and parameters playing it once.
	 *          If synthesizer is \em null nothing is done.
	 */
	public func void playSynthesizerOnce(SynthesizerInstance synthesizer, Element element, \
	float volume, float range)
		playSynthesizerOnce(synthesizer, element.getPosition(), \
			element.getOrientation(), volume, range)
	end
	
	/**
	 * \brief Play synthesizer instance once.
	 * \details Creates speaker with synthesizer instance and parameters playing it once.
	 *          If synthesizer is \em null nothing is done.
	 */
	public func void playSynthesizerOnce(SynthesizerInstance synthesizer, DVector position, \
	float volume, float range)
		playSynthesizerOnce(synthesizer, position, Quaternion.new(), volume, range)
	end
	
	/**
	 * \brief Play synthesizer instance once.
	 * \details Creates speaker with synthesizer instance and parameters playing it once.
	 *          If synthesizer is \em null nothing is done.
	 */
	public func void playSynthesizerOnce(SynthesizerInstance synthesizer, DVector position, \
	Quaternion orientation, float volume, float range)
		if synthesizer == null
			return
		end
		
		var Speaker speaker = Speaker.new()
		
		speaker.setSynthesizer(synthesizer)
		speaker.setPosition(position)
		speaker.setOrientation(orientation)
		speaker.setLooping(false)
		speaker.setVolume(volume)
		speaker.setRange(range)
		speaker.setLayerMask(pLayerMaskOneShotSpeaker)
		speaker.play()
		
		pWorld.addSpeaker(speaker)
		pOneShotSpeakers.add(speaker)
	end
	
	/**
	 * \brief Remove one shot speakers that finished playing.
	 */
	public func void removeFinishedOneShotSpeakers()
		pOneShotSpeakers.removeIf(block Speaker each
			if each.getStopped()
				pWorld.removeSpeaker(each)
				return true
				
			else
				return false
			end
		end)
	end
	
	/**
	 * \brief Stop and remove all one shot speakers.
	 */
	public func void removeAllOneShotSpeakers()
		pOneShotSpeakers.forEach(block Speaker each
			each.stop()
			pWorld.removeSpeaker(each)
		end)
		pOneShotSpeakers.removeAll()
	end
	
	
	
	/** \brief Make elements think. */
	public func void think(float elapsed)
		pThinkers.forEach(block Element each
			each.think(elapsed)
		end)
	end
	
	/** \brief Make elements think after physics simulation. */
	public func void postThink(float elapsed)
		pThinkers.forEach(block Element each
			each.postThink(elapsed)
		end)
	end
	
	/**
	 * \brief Call Element.enterFrame() on registered elements then unregister all elements.
	 * \warning Do not call addEnterFrameOnce or removeEnterFrameOnce from inside enterFrame().
	 */
	public func void enterFrame()
		if pEnterFrameOnce.getCount() == 0
			return
		end
		
		pEnterFrameOnce.forEach(block Element each
			each.enterFrame()
		end)
		pEnterFrameOnce.removeAll()
	end
	
	/**
	 * \brief Update game world.
	 * \details Call once at beginning of frame update cycle. Afterwards world can
	 *          be rendered multiple times.
	 */
	public func void update(float elapsed)
		enterFrame()
		
		pWorld.update(elapsed)
		pTempDecalMgr.update(elapsed)
		
		think(elapsed)
		pWorld.detectCollisions(elapsed)
		postThink(elapsed)
		
		removeFinishedOneShotSpeakers()
	end
	
	/** \brief Update game world with debug timing. */
	public func void updateDebug(float elapsed, \
			Debugging.DebugPerformanceCounter debugUpdate, \
			Debugging.DebugPerformanceCounter debugThink, \
			Debugging.DebugPerformanceCounter debugCollisions, \
			Debugging.DebugPerformanceCounter debugPostThink)
		enterFrame()
		
		debugUpdate.start()
		pWorld.update(elapsed)
		debugUpdate.stop()
		pTempDecalMgr.update(elapsed)
		
		debugThink.start()
		think(elapsed)
		debugThink.stop()
		debugCollisions.start()
		pWorld.detectCollisions(elapsed)
		debugCollisions.stop()
		debugPostThink.start()
		postThink(elapsed)
		debugPostThink.stop()
		
		removeFinishedOneShotSpeakers()
	end
	
	
	
	/** \brief Next object ID from world file required for saving and remapping ID ranges. */
	public func UniqueID getNextObjectID()
		return pNextObjectID
	end
	
	/** \brief Set next object ID from world file required for saving and remapping ID ranges. */
	public func void setNextObjectID(UniqueID nextObjectID)
		pNextObjectID = nextObjectID
	end
	
	/** \brief Unique ID remapper. */
	public func UniqueIDRemapper getUniqueIDRemapper()
		return pUniqueIDRemapper
	end
	
	/** \brief Set Unique ID remapper. */
	public func void setUniqueIDRemapper(UniqueIDRemapper remapper)
		if remapper == null
			throw EInvalidParam.new()
		end
		pUniqueIDRemapper = remapper
	end
	
	
	
	/**
	 * \brief Stub used to create game world.
	 * \version 1.17
	 */
	public func StubGameWorld getStub()
		return pStub
	end
	
	/**
	 * \brief Set stub used to create game world.
	 * \version 1.17
	 */
	public func void setStub(StubGameWorld stub)
		pStub = stub
	end
	
	
	
	/**
	 * \brief Init game world from stub.
	 * \version 1.17
	 * 
	 * Stub is stored in game world for referencing. Stub can be changed in certain
	 * situations. In general though the stub should be kept unchanged.
	 */
	public func void init(StubGameWorld stub)
	end
	
	
	
	/** \brief Read from file. */
	public func void readFromFile(PersistencyEnvironment env, FileReader reader)
	end
	
	/** \brief Write to file. */
	public func void writeToFile(PersistencyEnvironment env, FileWriter writer)
	end
	
	/**
	 * \brief Read element stubs from file.
	 * 
	 * Reads first the next object ID and Unique ID remapper. Then remaps the stub elements
	 * in the stub world. Then reads the element stubs.
	 */
	public func void readElementStubsFromFile(PersistencyEnvironment env, FileReader reader, \
	MutableID idGenerator, ElementClassList elementClassList, StubGameWorld stubWorld)
		select reader.readByte() // version
		case 0
			var UniqueID lastNextObjectID = UniqueID.readFromFile(reader)
			pUniqueIDRemapper = UniqueIDRemapper.readFromFile(reader)
			
			var UniqueID nextObjectID = stubWorld.getNextObjectID()
			if nextObjectID > lastNextObjectID
				stubWorld.setNewElementsRange(pUniqueIDRemapper.add(\
					lastNextObjectID, nextObjectID, idGenerator.toUniqueID()))
				idGenerator.incrementBy(nextObjectID - lastNextObjectID)
			end
			
			stubWorld.remapObjectIDs(pUniqueIDRemapper)
			stubWorld.readElementStubsFromFile(env, reader, elementClassList)
			
		else
			throw EInvalidParam.new("unsupported version")
		end
	end
	
	/**
	 * \brief Write element stubs to file.
	 * 
	 * Writes first the next object ID and Unique ID remapper. While loading the next object
	 * ID and mapper can be used to modify remapping in case the object ID range of the
	 * world changed in the mean time.
	 * 
	 * Ignores elements with element classes marked not persistable. For each element the
	 * element stub is written used to load or create the element.
	 * 
	 * Not persistable elements have to be loaded from a world file even if using a file reader. 
	 * 
	 * The two methods writeElementStubsToFile() and writeDynamicElementDataToFile() are
	 * both required to properly restore elements. They are not merged in one to allow
	 * preloading. For this to work element stubs have to be read first to start preloading.
	 * Once done the elements are created and their dynamic data read. The order of stubs
	 * has to stay the same for them to properly read their dynamic data.
	 */
	public func void writeElementStubsToFile(PersistencyEnvironment env, FileWriter writer)
		writer.writeByte(0) // version
		
		pNextObjectID.writeToFile(writer)
		pUniqueIDRemapper.writeToFile(writer)
		
		pElements.forEach(block Element each
			if each.getClass().getPersistable()
				each.getStub().writeToFile(writer)
			end
		end)
		writer.writeString8("") // empty classname is end of list marker
	end
	
	/**
	 * \brief Write dynamic element data to file.
	 * 
	 * Ignores elements with element classes marked not persistable. For each element the
	 * Element.writeToFile() method is called to save dynamic parameters.
	 * 
	 * The two methods writeElementStubsToFile() and writeDynamicElementDataToFile() are
	 * both required to properly restore elements. They are not merged in one to allow
	 * preloading. For this to work element stubs have to be read first to start preloading.
	 * Once done the elements are created and their dynamic data read. The order of stubs
	 * has to stay the same for them to properly read their dynamic data.
	 */
	public func void writeDynamicElementDataToFile(PersistencyEnvironment env, FileWriter writer)
		if env.getPersistency().getDebugEnableCanaryValue()
			pElements.forEach(block Element each
				if each.getClass().getPersistable()
					writer.writeString(Persistency.debugCanaryValue_BEGIN)
					each.writeToFile(env, writer)
					writer.writeString(Persistency.debugCanaryValue_END)
				end
			end)
			
		else
			pElements.forEach(block Element each
				if each.getClass().getPersistable()
					each.writeToFile(env, writer)
				end
			end)
		end
	end
	
	
	
	/** \brief Spawn point list. */
	public func SpawnPointList getSpawnPoints()
		return pSpawnPoints
	end
	
	/** \brief Rail list. */
	public func RailList getRailList()
		return pRailList
	end
	
	/** \brief Conversation actor list. */
	public func ConversationActorList getConvoActorList()
		return pConvoActorList
	end
	
	/** \brief Conversation coordinate system list. */
	public func ConversationCoordSystemList getConvoCoordSystemList()
		return pConvoCoordSystemList
	end
	
	/** \brief Anchored element list. */
	public func AnchoredElementList getAnchoredElementList()
		return pAnchoredElementList
	end
	
	
	
	/** \brief Temporary decal manager. */
	public func TemporaryDecalManager getTemporaryDecalManager()
		return pTempDecalMgr
	end
	
	/** \brief Set temporary decal manager. */
	public func void setTemporaryDecalManager(TemporaryDecalManager manager)
		if manager == null
			throw EInvalidParam.new()
		end
		pTempDecalMgr = manager
	end
	
	
	
	/**
	 * \brief Collect debug statistics.
	 * 
	 * Returns a dictionary with these values:
	 * - 'elements': Number of elements.
	 * - 'thinkers': Number of thinking elements.
	 * - 'enterFrameOnce': Number of enter frame once elements.
	 * - 'oneShotSpeakers': Number of one shot speakers.
	 * - 'spawnPoints': Number of spawn points.
	 * - 'temporaryDecals': Number of temporary decals.
	 * - 'resources.camera': Number of camera resources.
	 * - 'resources.speaker': Number of speaker resources.
	 * - 'resources.microphone': Number of microphone resources.
	 * - 'resources.networkState': Number of network state resources.
	 * - 'resources.component': Number of component resources.
	 * - 'resources.light': Number of light resources.
	 * - 'resources.collider': Number of collider resources.
	 * - 'resources.lumimeter': Number of lumimeter resources.
	 * - 'resources.touchSensor': Number of touch sensor resources.
	 * - 'resources.propField': Number of prop field resources.
	 * - 'resources.forceField': Number of force field resources.
	 * - 'resources.particleEmitter': Number of particle emitter instance resources.
	 * - 'resources.debugDrawer': Number of debug drawer resources.
	 * - 'resources.navigationSpace': Number of navigation space resources.
	 * - 'resources.navigationBlocker': Number of navigation blocker resources.
	 * - 'resources.navigator': Number of navigator resources.
	 * - 'resources.envMapProbe': Number of environment map probe resources.
	 */
	public func Dictionary debugStatistics()
		var Dictionary stats = Dictionary.new()
		stats.setAt("elements", pElements.getCount())
		stats.setAt("thinkers", pThinkers.getCount())
		stats.setAt("enterFrameOnce", pEnterFrameOnce.getCount())
		stats.setAt("oneShotSpeakers", pOneShotSpeakers.getCount())
		stats.setAt("spawnPoints", pSpawnPoints.getCount())
		stats.setAt("rails", pRailList.getCount())
		stats.setAt("temporaryDecals", pTempDecalMgr.getCount())
		stats.setAt("resources.camera", pWorld.getCameraCount())
		stats.setAt("resources.speaker", pWorld.getSpeakerCount())
		stats.setAt("resources.microphone", pWorld.getMicrophoneCount())
		stats.setAt("resources.networkState", pWorld.getNetworkStateCount())
		stats.setAt("resources.component", pWorld.getComponentCount())
		stats.setAt("resources.light", pWorld.getLightCount())
		stats.setAt("resources.collider", pWorld.getColliderCount())
		stats.setAt("resources.lumimeter", pWorld.getLumimeterCount())
		stats.setAt("resources.touchSensor", pWorld.getTouchSensorCount())
		stats.setAt("resources.propField", pWorld.getPropFieldCount())
		stats.setAt("resources.forceField", pWorld.getForceFieldCount())
		stats.setAt("resources.particleEmitter", pWorld.getParticleEmitterCount())
		stats.setAt("resources.debugDrawer", pWorld.getDebugDrawerCount())
		stats.setAt("resources.navigationSpace", pWorld.getNavigationSpaceCount())
		stats.setAt("resources.navigationBlocker", pWorld.getNavigationBlockerCount())
		stats.setAt("resources.navigator", pWorld.getNavigatorCount())
		stats.setAt("resources.envMapProbe", pWorld.getEnvMapProbeCount())
		return stats
	end
	
	/**
	 * \brief Retrieves some summary statistics.
	 * 
	 * Returns a dictionary with these values.
	 * - 'thinkers': Dictionary containing as keys the element class name of all
	 *               thinkers with value occurance count.
	 * - 'enterFrameOnce': Dictionary containing as keys the element class name of all
	 *                     enter frame once with value occurance count.
	 */
	public func Dictionary debugStatisticsSummary()
		var Dictionary summary, stats = Dictionary.new()
		var String key
		
		summary = Dictionary.new()
		pThinkers.forEach(block Element each
			key = each.getClass().getClassname()
			summary.setAt(key, summary.getAt(key, 0) cast int + 1)
		end)
		stats.setAt("thinkers", summary)
		
		summary = Dictionary.new()
		pEnterFrameOnce.forEach(block Element each
			key = each.getClass().getClassname()
			summary.setAt(key, summary.getAt(key, 0) cast int + 1)
		end)
		stats.setAt("enterFrameOnce", summary)
		
		return stats
	end
	
	/** \brief Print statistics to console. */
	public func void debugPrintStatistics(Console console)
		var Dictionary stats = debugStatistics()
		stats.getKeys().sorted().forEach(block String key
			console.addMessage("- " + key + ": " + stats.getAt(key))
		end)
	end
	
	/** \brief Print statistics summary to console. */
	public func void debugPrintStatisticsSummary(Console console)
		var Dictionary summary, stats = debugStatisticsSummary()
		stats.getKeys().sorted().forEach(block String key
			console.addMessage("- " + key + ":")
			summary = stats.getAt(key) cast Dictionary
			summary.getKeys().sorted().forEach(block String key2
				console.addMessage("  - " + key2 + ": " + summary.getAt(key2))
			end)
		end)
	end
end
