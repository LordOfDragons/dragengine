/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Scenery

pin Dragengine.Preloading
pin Dragengine.LoadSave
pin Dragengine.Utils
pin Dragengine.TriggerSystem


/**
 * \brief Composable animator for element class.
 * 
 * Provides animator support to element class without subclassing from a specific class.
 * Sets the animator to use by an animator instance. Optionally an animation object can
 * be defined overwriting the one used int he animator. The playback parameters influence
 * the playback speed and if the animator is played back looping or once. Optionally an
 * activate playback trigger can be used to switch playback on and off.
 */
class ECComposeAnimator
	/** \brief Playback support for elements. */
	public class Playback
		private var AnimatorInstance pInstance
		private var AnimatorController pController
		private var float pPlaySpeed
		private var bool pPlaying
		
		
		
		/** \brief Create playback. */
		public func new(AnimatorInstance instance, String playbackController)
			pInstance = instance
			pPlaySpeed = 1
			pPlaying = false
			
			setControllerNamed(playbackController)
		end
	
		
		
		/** \brief Playback speed. */
		public func float getPlaySpeed()
			return pPlaySpeed
		end
		
		/** \brief Set playback speed. */
		public func void setPlaySpeed(float playSpeed)
			pPlaySpeed = playSpeed
		end
		
		/** \brief Animator instance or \em null if not available. */
		public func AnimatorInstance getInstance()
			return pInstance
		end
		
		/** \brief Playback controller or \em null if not available. */
		public func AnimatorController getController()
			return pController
		end
		
		/** \brief Set playback controller from index if valid. */
		public func void setControllerIndex(int index)
			if pInstance == null or index < 0 or index >= pInstance.getControllerCount()
				return
			end
			pController = pInstance.getControllerAt(index)
		end
		
		/** \brief Set playback controller by name if valid. */
		public func void setControllerNamed(String name)
			if pInstance == null
				return
			end
			pController = pInstance.getControllerNamed(name)
		end
		
		
		
		/** \brief Is playing back. */
		public func bool getPlaying()
			return pPlaying
		end
		
		/** \brief Set if playing back. */
		public func void setPlaying(bool playing)
			pPlaying = playing
		end
		
		/** \brief Is looping. */
		public func bool getLooping()
			return pController != null and not pController.getClamp()
		end
		
		/** \brief Set if looping. */
		public func void setLooping(bool looping)
			if pController != null
				pController.setClamp(not looping)
			end
		end
		
		/** \brief Playback time. */
		public func float getTime()
			return pController != null if pController.getValue() else 0.0
		end
		
		/** \brief Set playback time. */
		public func void setTime(float time)
			if pController != null
				pController.setValue(time)
			end
		end
		
		/** \brief Playback is at beginning. */
		public func bool isAtBegin()
			return pController != null if pController.isAtLower() else true
		end
		
		/** \brief Playback is at end. */
		public func bool isAtEnd()
			return pController != null if pController.isAtUpper() else true
		end
		
		/** \brief Rewind. */
		public func void rewind()
			if pController == null
				return
			end
			
			if pPlaySpeed > 0
				pController.setToLower()
				
			else
				pController.setToUpper()
			end
		end
		
		
		
		/**
		 * \brief Update animator.
		 * 
		 * Advances the controller by the elapsed time multiplied by the play speeed
		 * and calls AnimatorInstance.apply().
		 */
		public func void update(float elapsed)
			if not pPlaying or pController == null
				return
			end
			
			pController.increment(elapsed * pPlaySpeed)
			
			pInstance.apply()
			
			if pController.getClamp() and pController.isAtUpper()
				setPlaying(false)
			end
		end
		
		/** \brief Apply animation. */
		public func void apply()
			if pInstance != null
				pInstance.apply()
			end
		end
		
		
		
		/** \brief Read element from file. */
		public func void readFromFile(PersistencyEnvironment env, FileReader reader)
			select reader.readByte() // version
			case 0
				var PersistencyFlags flags = PersistencyFlags.new(1, reader)
				setPlaying(flags.getAt(0))
				setTime(reader.readFloat())
				
			else
				throw EInvalidParam.new("unsupported version")
			end
		end
		
		/** \brief Write element to file. */
		public func void writeToFile(PersistencyEnvironment env, FileWriter writer)
			writer.writeByte(0) // version
			
			var PersistencyFlags flags = PersistencyFlags.new(1)
			flags.setAt(0, getPlaying())
			flags.writeToFile(writer)
			writer.writeFloat(getTime())
		end
	end
	
	
	
	private var ECPAnimator pAnimator
	private var ECPAnimation pAnimation
	private var ECPFloat pPlaySpeed
	private var ECPBoolean pPlaying
	private var ECPString pPlaybackController
	private var String pPrefix
	
	
	
	/**
	 * \brief Create composable element class.
	 * 
	 * Adds all properties to \em ownerClass. If you do not want a property to be configurable
	 * using XML subclassing use ownerClass.removeProperty() to remove them.
	 */
	public func new(ElementClass ownerClass, Loaders loaders) \
	this(ownerClass, loaders, "animator.")
	end
	
	/**
	 * \brief Create composable element class.
	 * 
	 * Adds all properties to \em ownerClass. If you do not want a property to be configurable
	 * using XML subclassing use ownerClass.removeProperty() to remove them.
	 */
	public func new(ElementClass ownerClass, Loaders loaders, String prefix)
		if prefix == null
			throw EInvalidParam.new()
		end
		
		pAnimator = ECPAnimator.new(prefix + "animator", loaders.getAnimator())
		ownerClass.addProperty(pAnimator)
		
		pAnimation = ECPAnimation.new(prefix + "animation")
		ownerClass.addProperty(pAnimation)
		
		pPlaySpeed = ECPFloat.new(prefix + "playSpeed", 1)
		ownerClass.addProperty(pPlaySpeed)
		
		pPlaying = ECPBoolean.new(prefix + "playing", false)
		ownerClass.addProperty(pPlaying)
		
		pPlaybackController = ECPString.new(prefix + "playbackController", "playback")
		ownerClass.addProperty(pPlaybackController)
		
		pPrefix = prefix
	end
	
	
	
	/** \brief Animator resource. */
	public func ECPAnimator getAnimator()
		return pAnimator
	end
	
	/** \brief Animation resource. */
	public func ECPAnimation getAnimation()
		return pAnimation
	end
	
	/** \brief Play speed. */
	public func ECPFloat getPlaySpeed()
		return pPlaySpeed
	end
	
	/** \brief Animation is playing. */
	public func ECPBoolean getPlaying()
		return pPlaying
	end
	
	/** \brief Playback controller name. */
	public func ECPString getPlaybackController()
		return pPlaybackController
	end
	
	/** \brief Property prefix. */
	public func String getPrefix()
		return pPrefix
	end
	
	
	
	/**
	 * \brief Initialize animator instance for element from stub.
	 * 
	 * Assigns the animator and animation to the instance. If at least one controller is
	 * present then the first controller is initialized as playback controller. The element
	 * is responsible to assign a Component to the animator instance.
	 */
	public func AnimatorInstance createAnimatorInstance(Element element, StubElement stub)
		var Animator animator = pAnimator.getAnimator()
		var Animation animation = pAnimation.getAnimation()
		var String value
		
		// animator resource
		value = stub.getPropertyValueFor(pAnimator.getName(), "")
		if not value.empty()
			try
				animator = pAnimator.getLoader().loadFromFile(value)
				
			catch Exception e
				throw ELoadResourceFailed.new(value, element.getClass().getClassname())
			end
		end
		
		// animation resource
		value = stub.getPropertyValueFor(pAnimation.getName(), "")
		if not value.empty()
			try
				animation = Animation.new(value)
				
			catch Exception e
				throw ELoadResourceFailed.new(value, element.getClass().getClassname())
			end
		end
		
		if animator == null
			return null
		end
		
		// create animator instance
		var AnimatorInstance instance = AnimatorInstance.new()
		instance.setAnimator(animator)
		instance.setAnimation(animation)
		return instance
	end
	
	/** \brief Create playback helper. */
	public func Playback createPlayback(AnimatorInstance instance, StubElement stub)
		var Playback playback = Playback.new(instance, pPlaybackController.getValue(stub))
		playback.setPlaySpeed(pPlaySpeed.getValue(stub))
		playback.setPlaying(pPlaying.getValue(stub))
		return playback
	end
	
	/** \brief Create playing trigger expression from stub or \em null if not used. */
	public func TSTriggerExpression createTriggerPlaying(Element element, StubElement stub)
		return createTriggerPlaying(element, stub, "")
	end
	
	/** \brief Create playing trigger expression from stub or \em null if not used. */
	public func TSTriggerExpression createTriggerPlaying(Element element, StubElement stub, String defaultValue)
		var String value = stub.getPropertyValueFor(pPrefix + "trigger", defaultValue)
		
		if value.empty()
			return null
			
		else
			return element.getClass().getTriggerExpressionParser().stringToExpression(value)
		end
	end
end
