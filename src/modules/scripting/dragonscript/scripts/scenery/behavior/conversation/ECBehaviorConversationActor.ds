/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Scenery

pin Dragengine.BehaviorTreeSystem
pin Dragengine.ConversationSystem
pin Dragengine.Gui.Designers
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.SpeechAnimations
pin Dragengine.Utils.StyledText.Definition


/**
 * \brief Behavior adding conversation actor support to actors.
 * 
 * Provides ConversationActor with basic properties set depending on what behaviors are present
 * before this behavior. In addition supports for other behaviors to modify and extend the
 * ConversationActor namely adding game and condition commands or modify sub title boxes using
 * listener support.
 * 
 * To use this class add these behaviors to the actor:
 * - ECBehaviorConversationActor
 * 
 * Supports these behaviors if present:
 * - ECBehaviorComponent
 * - ECBehaviorLocomotion
 * - ECBehaviorParameterTable
 * 
 * Basic ConversationActor is set up like this:
 * - ParameterTable: ECBehaviorParameterTable if present
 * - SpeechAnimationPlayback: SpeechAnimationPlayback using ECBehaviorComponent if present
 * - GesturePlayback: ConversationGesturePlayback using ECBehaviorComponent if present
 * - FacePosePlayback: ConversationFacePosePlayback using ECBehaviorComponent if present
 * - HeadLookAtPlayback: ConversationHeadLookAtPlayback using ECBehaviorLocomotion if present
 * - EyesLookAtPlayback: CharacterEyesLookAtPlayback using ECBehaviorComponent if present
 * - SubtitleTheme: Set to null to use playback sub title box gui theme.
 * - Name: Set from element class property "convoActor.name".
 * 
 * - setVoiceSpeaker: Assign a speaker used for voice acting
 * 
 * This behavior does not update itself automatically during thinking because locomotion
 * handling in actors needs a specific order to work correctly:
 * - ECBehaviorConversationActor.updateLocomotion(elapsed)
 * - update locomotion using actor action, player input and other means
 * - ECBehaviorConversationActor.updateAnimator(elapsed, actor.getAnimatorInstance())
 * - apply actor animator instance to component
 * - ECBehaviorConversationActor.applyAnimations()
 * 
 * ECBehaviorConversationActor.updateLocomotion() has to be called before calling
 * Locomotion.update() since the HeadLookAtPlayback modifies the locomotion goal parameters.
 * 
 * ECBehaviorConversationActor.updateAnimator() has to be called before applying animations
 * since playback instances use the base animator instance controllers as input.
 * 
 * It is possible to use this behavior on non-actor elements. In this case add first a behavior
 * providing animator support and assign it to the behavior. Then this behavior will register
 * and update in the right time. Supported are these behaviors:
 * - ECBehaviorActorAnimated
 * - ECBehaviorAnimated
 * - ECBehaviorTwoStateAnimated
 * 
 * \par Version 1.5 Additions
 * 
 * Behavior supports re-mapping bone names in response to ConversationActor.getMatrix() and
 * ConversationActor.getInverseMatrix() . Define bone mappings using setBoneMapping(). The
 * mappings are persistent until changed. Bone mappings are useful for various situations
 * including the following ones:
 * - Use element with mismatching bone names. Using bone mapping the required conversation
 *   bone names are mapped to the actual rig bone name without needing to change the
 *   conversation scripts.
 * - Dynamically change the meaning of a target bone. This can be used to refer to either
 *   the left or right hand of an actor by using a virtual bone name. Script code can change
 *   the mapping for the bone at any time to make conversation scripts always refer to the
 *   right actor hand.
 * 
 * \par Version 1.19 Additions
 * 
 * ECBehaviorBehaviorTree behaviors can be added to the behavior using
 * addBehaviorTree(ECBehaviorBehaviorTree). This will add behavior tree actions and conditions
 * to all added behavior tree contexts. The following actions and conditions are added.
 * 
 * - Condition "conversationActor.inConversation"
 * 
 * Determines if conversation actor is in a conversation.
 * 
 * This is an example of an action that can only run if the actor is in a conversation:
 * \code{.xml}
 * <action name='myAction' id='doing something'>
 *    <condition>conversationActor.inConversation</condition>
 * </action>
 * \endcode
 * 
 * - Condition "conversationActor.notInConversation"
 * 
 * Determines if conversation actor is not in a conversation.
 * 
 * This is an example of an action that can only run if the actor is not in a conversation:
 * \code{.xml}
 * <action name='myAction' id='doing something'>
 *    <condition>conversationActor.notInConversation</condition>
 * </action>
 * \endcode
 */
class ECBehaviorConversationActor extends DefaultECBehavior
	/** \brief Listener for behavior instance events. */
	interface Listener
		/** \brief Actor is doing something blocking if conversation actions wait for this actor. */
		func bool wait(Instance instance)
		
		/** \brief Actor entered conversation. */
		func void enterConversation(Instance instance)
		
		/** \brief Actor left conversation. */
		func void leaveConversation(Instance instance)
		
		/**
		 * \brief Modify sub title text created by behavior.
		 * 
		 * Multiple listeners can modify sub title text by either modifying the widget
		 * pass to the listener or creating a new one.
		 */
		func SubTitleBoxText modifySubTitleText(Instance instance, \
			SubTitleBoxText widget, UnicodeString text, StringID style)
	end
	
	/**
	 * \brief Listener for behavior instance events.
	 * \version 1.9
	 */
	interface Listener2 implements Listener
		/**
		 * \brief Actor speech has been started by CActionActorSpeak.
		 * \version 1.9
		 * 
		 * Called after setting up actor speech and before advancing conversation playback.
		 * Allows sub class to apply additional game actions at begin of actor speech started
		 * by instance of CActionActorSpeak. This method is always called no matter if the
		 * action set up any speech parameters or not. Use the action parameter to figure out
		 * if this is the case.
		 * 
		 * \param action Action starting speech or null if called otherwise.
		 */
		func void beginActorSpeech(Instance instance, CActionActorSpeak action)
	end
	
	/** \brief Default implementation of behavior instance listener. */
	class DefaultListener implements Listener2
		/** \brief Create default listener. */
		public func new()
		end
		
		/**
		 * \brief Actor is doing something blocking if conversation actions wait for this actor.
		 * 
		 * Default implementation returns false.
		 */
		public func bool wait(Instance instance)
			return false
		end
		
		/** \brief Actor entered conversation. */
		public func void enterConversation(Instance instance)
		end
		
		/** \brief Actor left conversation. */
		public func void leaveConversation(Instance instance)
		end
		
		/**
		 * \brief Modify sub title text created by behavior.
		 * 
		 * Multiple listeners can modify sub title text by either modifying the widget
		 * pass to the listener or creating a new one.
		 * 
		 * Default implementation returns \em widget.
		 */
		public func SubTitleBoxText modifySubTitleText(Instance instance, \
		SubTitleBoxText widget, UnicodeString text, StringID style)
			return widget
		end
		
		/**
		 * \brief Actor speech has been started by CActionActorSpeak.
		 * \version 1.9
		 * 
		 * Called after setting up actor speech and before advancing conversation playback.
		 * Allows sub class to apply additional game actions at begin of actor speech started
		 * by instance of CActionActorSpeak. This method is always called no matter if the
		 * action set up any speech parameters or not. Use the action parameter to figure out
		 * if this is the case.
		 * 
		 * \param action Action starting speech or null if called otherwise.
		 */
		public func void beginActorSpeech(Instance instance, CActionActorSpeak action)
		end
	end
	
	/** \brief Factory creating listeners. */
	interface ListenerFactory
		/** \brief Create listener. */
		func Listener createListener(Instance instance)
	end
	
	/** \brief Factory creating listeners using block. */
	class BlockListenerFactory implements ListenerFactory
		private var Block pBlock
		
		/** \brief Create factory using block receiving Instance as parameter returning Listener. */
		public func new(Block blockFactory)
			if blockFactory == null
				throw ENullPointer.new()
			end
			pBlock = blockFactory
		end
		
		/** \brief Create listener. */
		public func Listener createListener(Instance instance)
			return pBlock.run(instance) cast Listener
		end
	end
	
	/** \brief Conversation command. */
	interface ConversationCommand
		/**
		 * \brief Conversation command.
		 * \param arguments. Array of String tokens parsed from send command.
		 */
		func void runCommand(Instance instance, Array arguments)
	end
	
	/** \brief Conversation condition. */
	interface ConversationCondition
		/**
		 * \brief Evaluate conversation condition.
		 * \param arguments. Array of String tokens parsed from send command.
		 */
		func bool evaluateCondition(Instance instance, Array arguments)
	end
	
	/** \brief Behavior conversation actor. */
	public class BehaviorConversationActor extends ConversationActor
		private var Instance pInstance
		
		public func new(Instance instance, StringID id) super(id)
			pInstance = instance
		end
		
		public func void dispose()
			pInstance = null
		end
		
		public func Instance getInstance()
			return pInstance
		end
		
		public func bool wait()
			return pInstance.onWait()
		end
		
		public func void command(String command)
			pInstance.runCommand(command)
		end
		
		public func bool conditionCommand(String command)
			return pInstance.evaluateCondition(command)
		end
		
		public func void beginActorSpeech(CActionActorSpeak action)
			pInstance.onBeginActorSpeech(action)
		end
		
		public func void enterConversation()
			pInstance.onEnterConversation()
		end
		
		public func void leaveConversation()
			pInstance.onLeaveConversation()
		end
		
		public func DMatrix getMatrix()
			return pInstance.getElement().getElementMatrix()
		end
		
		public func DMatrix getMatrix(String bone)
			var DMatrix matrix = pInstance.getElement().getElementMatrix()
			if bone != null
				var ECBehaviorComponent.Instance component = pInstance.getComponent()
				if component != null
					matrix = component.getComponent().getBoneMatrix(\
						pInstance.mapBone(bone)).toDMatrix() * matrix
				end
			end
			return matrix
		end
		
		public func DMatrix getInverseMatrix()
			return pInstance.getElement().getInverseElementMatrix()
		end
		
		public func DMatrix getInverseMatrix(String bone)
			var DMatrix matrix = pInstance.getElement().getInverseElementMatrix()
			if bone != null
				var ECBehaviorComponent.Instance component = pInstance.getComponent()
				if component != null
					matrix = matrix * component.getComponent().getBoneInverseMatrix(\
						pInstance.mapBone(bone)).toDMatrix()
				end
			end
			return matrix
		end
		
		public func SubTitleBoxText createSubTitleText(UnicodeString text, StringID style)
			return pInstance.createSubTitleText(text, style)
		end
	end
	
	/**
	 * \brief Behavior factory.
	 * \ref 1.25
	 * 
	 * Automatically assigns these behaviors if present before adding:
	 * - Optional: \ref ECBehaviorActorAnimated
	 * - Optional: \ref ECBehaviorAnimated
	 * - Optional: \ref ECBehaviorTwoStateAnimated
	 * - Optional: \ref ECBehaviorLocomotion
	 * - Optional: \ref ECBehaviorParameterTable
	 * 
	 * Example XML element class:
	 * \code{.xml}
	 * <behavior type='ECBehaviorConversationActor'>
	 *   <!-- optional: use actor animated with id instead of empty string -->
	 *   <string name='actorAnimated'>second</string>
	 * 
	 *   <!-- optional: use animated with id instead of empty string -->
	 *   <string name='animated'>second</string>
	 * 
	 *   <!-- optional: use two state animated with id instead of empty string -->
	 *   <string name='twoStateAnimated'>second</string>
	 * 
	 *   <!-- optional: use BaseGameApp subtitle theme. game can add more supported values.
	 *                  default is 'default'. also supported is value 'path:/path/to/theme.guitheme' -->
	 *   <string name='subtitleTheme'>default</string>
	 * </behavior>
	 * \endcode
	 */
	class Factory implements BehaviorFactory
		func new()
		end
		
		func String factoryId()
			return "ECBehaviorConversationActor"
		end
		
		func ECBehavior addBehavior(BehaviorElementClass eclass, String id, Dictionary parameters)
			var ECBehaviorConversationActor behavior = ECBehaviorConversationActor.new(eclass)
			
			behavior.setActorAnimated(eclass.sharedFactoryHelper.optionalActorAnimated(eclass, parameters))
			behavior.setAnimated(eclass.sharedFactoryHelper.optionalAnimated(eclass, parameters))
			behavior.setTwoStateAnimated(eclass.sharedFactoryHelper.optionalTwoStateAnimated(eclass, parameters))
			behavior.setLocomotion(ECBehaviorLocomotion.getBehaviorIn(eclass))
			behavior.setParameterTable(ECBehaviorParameterTable.getBehaviorIn(eclass))
			
			if parameters.has("subtitleTheme")
				behavior.setSubtitleTheme(getSubtitleThemeFor(parameters.getAt("subtitleTheme") cast String))
			end
			
			return behavior
		end
		
		/**
		 * \brief Subtitle gui theme matching value.
		 * 
		 * Default implementation returns \ref WindowSubTitle#getGuiTheme()
		 * on \ref BaseGameApp#getWindowSubTitle() for value 'default', loads gui theme if value
		 * begins with 'path:' or null for all other values. Overwrite to accept other values.
		 */
		func GuiTheme getSubtitleThemeFor(String value)
			return BehaviorElementClass.sharedFactoryHelper.subtitleTheme(value)
		end
	end
	
	
	
	/** \brief Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		/** \brief Actor animated behavior listener. */
		private class ActorAnimatedListener extends ECBehaviorActorAnimated.DefaultListener
			private var Instance pInstance
			
			public func new(Instance instance)
				pInstance = instance
			end
			
			public func void updateControllers(ECBehaviorActorAnimated.Instance instance, float elapsed)
				pInstance.updateAnimators(elapsed, instance.getAnimatorInstance())
			end
			
			public func void animationApplied(ECBehaviorActorAnimated.Instance instance)
				pInstance.applyAnimations()
			end
		end
		
		/** \brief Animated behavior listener. */
		private class AnimatedListener extends ECBehaviorAnimated.DefaultListener
			private var Instance pInstance
			
			public func new(Instance instance)
				pInstance = instance
			end
			
			public func void updateControllers(ECBehaviorAnimated.Instance instance, float elapsed)
				pInstance.updateLocomotion(elapsed)
				pInstance.updateAnimators(elapsed, instance.getAnimatorInstance())
			end
			
			public func void animationApplied(ECBehaviorAnimated.Instance instance)
				pInstance.applyAnimations()
			end
		end
		
		/** \brief Animated behavior listener. */
		private class TwoStateAnimatedListener extends ECBehaviorTwoStateAnimated.DefaultListener
			private var Instance pInstance
			
			public func new(Instance instance)
				pInstance = instance
			end
			
			public func void updateControllers(ECBehaviorTwoStateAnimated.Instance instance, float elapsed)
				pInstance.updateLocomotion(elapsed)
				pInstance.updateAnimators(elapsed, instance.getAnimatorInstance())
			end
			
			public func void animationApplied(ECBehaviorTwoStateAnimated.Instance instance)
				pInstance.applyAnimations()
			end
		end
		
		/** \brief Behavior tree condition "conversationActor.inConversation". */
		class BTCInConversation implements BTCondition
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func bool evaluateCondition(BTContext context, Dictionary parameters)
				return pInstance.isInConversation()
			end
		end
		
		/** \brief Behavior tree condition "conversationActor.notInConversation". */
		class BTCNotInConversation implements BTCondition
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func bool evaluateCondition(BTContext context, Dictionary parameters)
				return pInstance.isNotInConversation()
			end
		end
		
		
		private var ECBehaviorConversationActor pECBehavior
		
		private var ECBehaviorComponent.Instance pComponent
		private var ECBehaviorParameterTable.Instance pParameterTable
		private var ECBehaviorActorAnimated.Instance pActorAnimated
		private var ECBehaviorAnimated.Instance pAnimated
		private var ECBehaviorTwoStateAnimated.Instance pTwoStateAnimated
		private var ECBehaviorLocomotion.Instance pLocomotion
		
		private var ConversationTagResolver pTagResolver
		private var CommandLineParser pCommandParser
		private var GuiTheme pSubtitleTheme
		private var String pSubtitleSelectorId
		private var Dictionary pCommands
		private var Dictionary pConditions
		private var Dictionary pBoneMappings
		private var bool pRegisterConversationActor
		private var BehaviorConversationActor pConversationActor
		
		private var Array pListeners
		
		
		
		/** \brief Create behavior instance. */
		public func new(ECBehaviorConversationActor ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pSubtitleTheme = ecbehavior.getSubtitleTheme()
			pCommands = Dictionary.new()
			pConditions = Dictionary.new()
			pBoneMappings = Dictionary.new()
			pListeners = Array.new()
		end
		
		/** \brief Dispose of behavior instance. */
		public func void dispose()
			if pConversationActor != null
				if pConversationActor.getPlayback() != null
					pConversationActor.getPlayback().removeActor(pConversationActor)
				end
				
				// just in case somebody uses playback subclass with strong references
				pConversationActor.setEyesLookAtPlayback(null)
				pConversationActor.setFacePosePlayback(null)
				pConversationActor.setGesturePlayback(null)
				pConversationActor.setHeadLookAtPlayback(null)
				pConversationActor.setSpeechAnimationPlayback(null)
				
				pConversationActor = null
			end
			
			pParameterTable = null
			pComponent = null
			pActorAnimated = null
			pAnimated = null
			pTwoStateAnimated = null
			pListeners = null
			pConditions = null
			pCommands = null
			pBoneMappings = null
			pTagResolver = null
			
			super.dispose()
		end
		
		
		
		/** \brief Initialize behavior from stub. */
		public func void init(StubElement stub)
			var BehaviorElement element = getElement()
			
			if pECBehavior.getActorAnimated() != null
				pActorAnimated = pECBehavior.getActorAnimated().instance(element)
				pComponent = pActorAnimated.getComponent()
			end
			if pECBehavior.getAnimated() != null
				pAnimated = pECBehavior.getAnimated().instance(element)
				pComponent = pAnimated.getComponent()
			end
			if pECBehavior.getTwoStateAnimated() != null
				pTwoStateAnimated = pECBehavior.getTwoStateAnimated().instance(element)
				pComponent = pTwoStateAnimated.getComponent()
			end
			if pECBehavior.getLocomotion() != null
				pLocomotion = pECBehavior.getLocomotion().instance(element)
			end
			if pECBehavior.getParameterTable() != null
				pParameterTable = pECBehavior.getParameterTable().instance(element)
			end
			
			pCommandParser = CommandLineParser.new()
			pTagResolver = ConversationTagResolver.new()
			pSubtitleSelectorId = pECBehavior.getSubtitleSelectorId().getValue(stub)
			pRegisterConversationActor = pECBehavior.getRegisterConversationActor().getValue(stub)
			
			var StringID id = pECBehavior.getActorId().getValue(stub)
			if id != null
				pConversationActor = createConversationActor(id, stub)
				initConversationActor(stub)
				initTagResolver(stub)
				
				if pActorAnimated != null
					pActorAnimated.addListener(ActorAnimatedListener.new(this))
				end
				if pAnimated != null
					pAnimated.addListener(AnimatedListener.new(this))
				end
				if pTwoStateAnimated != null
					pTwoStateAnimated.addListener(TwoStateAnimatedListener.new(this))
				end
			end
			
			pECBehavior.createListeners(this)
			
			pECBehavior.forEachBehaviorTree(block ECBehaviorBehaviorTree each
				var BTContext context = each.instance(element).getContext()
				context.setCondition("conversationActor.inConversation", BTCInConversation.new(this))
				context.setCondition("conversationActor.notInConversation", BTCNotInConversation.new(this))
			end)
		end
		
		/** \brief Create conversation actor. */
		protected func BehaviorConversationActor createConversationActor(StringID id, StubElement stub)
			return BehaviorConversationActor.new(this, id)
		end
		
		/** \brief Init conversation actor. */
		protected func void initConversationActor(StubElement stub)
			pConversationActor.setAliasID(pECBehavior.getAliasId().getValue(stub))
			pConversationActor.setName(pECBehavior.getName().getValue(stub))
			
			if pParameterTable != null
				pConversationActor.setParameterTable(pParameterTable.getParameterTable())
			end
			
			var CodecPropertyString codec = getElement().getClass().getCodecPropertyString()
			var DMatrix rotatorMatrix = DMatrix.newTranslation(DVector.new(\
				pECBehavior.getHeadRotatorOffset().getVector(stub, codec)))
			
			if pLocomotion != null
				var Locomotion locomotion = pLocomotion.getLocomotion()
				
				// set head look at playback. since by default the BaseActor class has no component
				// assigned the head rotator is set to be located 1.65m above ground which is where
				// the camera is located by default
				var ConversationHeadLookAtPlayback hlap = ConversationHeadLookAtPlayback.new()
				hlap.setLocomotion(locomotion)
				hlap.setBoneRotator(pECBehavior.getHeadRotatorBone().getValueOrNull(stub))
				hlap.setRotatorMatrix(rotatorMatrix)
				pConversationActor.setHeadLookAtPlayback(hlap)
			end
			
			if pComponent != null
				var Component component = pComponent.getComponent()
				
				// set speech animation playback
				var SpeechAnimationPlayback sap = SpeechAnimationPlayback.new()
				sap.getAnimatorInstance().setComponent(component)
				pConversationActor.setSpeechAnimationPlayback(sap)
				
				// set gesture playback
				var ConversationGesturePlayback gp = ConversationGesturePlayback.new()
				gp.getAnimatorInstance().setComponent(component)
				pConversationActor.setGesturePlayback(gp)
				
				// set face pose playback
				var ConversationFacePosePlayback fpp = ConversationFacePosePlayback.new()
				fpp.getAnimatorInstance().setComponent(component)
				pConversationActor.setFacePosePlayback(fpp)
				
				// set eyes look at playback. the same rotator matrix is used although there a component
				// needs to be present for eyes looking at something to actually work
				var CharacterEyesLookAtPlayback elap = CharacterEyesLookAtPlayback.new()
				elap.getAnimatorInstance().setComponent(component)
				elap.setRotatorMatrix(rotatorMatrix)
				pConversationActor.setEyesLookAtPlayback(elap)
			end
		end
		
		/** \brief Initialize tag resolver. */
		protected func void initTagResolver(StubElement stub)
		end
		
		
		
		/** \brief Behavior. */
		public func ECBehaviorConversationActor getECBehavior()
			return pECBehavior
		end
		
		/** \brief Component behavior. */
		public func ECBehaviorComponent.Instance getComponent()
			return pComponent
		end
		
		/** \brief Parameter table behavior or null. */
		public func ECBehaviorParameterTable.Instance getParameterTable()
			return pParameterTable
		end
		
		/** \brief Actor animated behavior or null. */
		public func ECBehaviorActorAnimated.Instance getActorAnimated()
			return pActorAnimated
		end
		
		/** \brief Animated behavior or null. */
		public func ECBehaviorAnimated.Instance getAnimated()
			return pAnimated
		end
		
		/** \brief Two-State Animated behavior or null. */
		public func ECBehaviorTwoStateAnimated.Instance getTwoStateAnimated()
			return pTwoStateAnimated
		end
		
		/** \brief Locomotion behavior or null. */
		public func ECBehaviorLocomotion.Instance getLocomotion()
			return pLocomotion
		end
		
		
		
		/** \brief Tag resolver. */
		public func ConversationTagResolver getTagResolver()
			return pTagResolver
		end
		
		/** \brief Set tag resolver. */
		public func void setTagResolver(ConversationTagResolver resolver)
			if resolver == null
				throw EInvalidParam.new()
			end
			pTagResolver = resolver
		end
		
		/**
		 * \brief Gui theme to use for sub title box creation.
		 * 
		 * If \em null uses the playback sub title box gui theme.
		 */
		public func GuiTheme getSubtitleTheme()
			return pSubtitleTheme
		end
		
		/**
		 * \brief Set gui theme to use for sub title box creation.
		 * 
		 * If \em guiTheme is \em null uses the playback sub title box gui theme.
		 */
		public func void setSubtitleTheme(GuiTheme guiTheme)
			pSubtitleTheme = guiTheme
		end
		
		/**
		 * \brief Sub title style selector ID.
		 * 
		 * If not empty string sub title related styles look like this where selectorId is this
		 * parameter and style the optional style provided to createSubTitleText:
		 * - SubTitleBoxText{.<selectorId>}{.<style>}
		 * - Label.SubTitleBoxText.Text{.<selectorId>}{.<style>}
		 * - Label.SubTitleBoxText.Name{.<selectorId>}{.<style>}
		 */
		public func String getSubtitleSelectorId()
			return pSubtitleSelectorId
		end
		
		/**
		 * \brief Set style selector identifier to use or null if not used.
		 * 
		 * If not empty string sub title related styles look like this where selectorId is this
		 * parameter and style the optional style provided to createSubTitleText:
		 * - SubTitleBoxText{.<selectorId>}{.<style>}
		 * - Label.SubTitleBoxText.Text{.<selectorId>}{.<style>}
		 * - Label.SubTitleBoxText.Name{.<selectorId>}{.<style>}
		 */
		public func void setSubtitleSelectorId(String selectorId)
			pSubtitleSelectorId = selectorId
		end
		
		/** \brief Command parser. */
		public func CommandLineParser getCommandParser()
			return pCommandParser
		end
		
		/** \brief Set command parser. */
		public func void setCommandParser(CommandLineParser parser)
			if parser == null
				throw EInvalidParam.new()
			end
			pCommandParser = parser
		end
		
		/** \brief Register conversation actor with game world. */
		public func bool getRegisterConversationActor()
			return pRegisterConversationActor
		end
		
		/** \brief Conversation actor. */
		public func ConversationActor getConversationActor()
			return pConversationActor
		end
		
		
		
		/** \brief Count of conversation commands. */
		public func int getCommandCount()
			return pCommands.getCount()
		end
		
		/** \brief Supported command names as Array of String. */
		public func Array getCommandNames()
			return pCommands.getKeys()
		end
		
		/** \brief Named command or null if absent. */
		public func ConversationCommand getCommandNamed(String name)
			return pCommands.getAt(name, null) cast ConversationCommand
		end
		
		/** \brief Add command replacing command with same name if present. */
		public func void addCommand(String name, ConversationCommand command)
			if name == null or command == null
				throw EInvalidParam.new()
			end
			pCommands.setAt(name, command)
		end
		
		
		
		/** \brief Count of conversation condition. */
		public func int getConditionCount()
			return pConditions.getCount()
		end
		
		/** \brief Supported condition names as Array of String. */
		public func Array getConditionNames()
			return pConditions.getKeys()
		end
		
		/** \brief Named condition or null if absent. */
		public func ConversationCondition getConditionNamed(String name)
			return pConditions.getAt(name, null) cast ConversationCondition
		end
		
		/** \brief Add condition replacing condition with same name if present. */
		public func void addCondition(String name, ConversationCondition condition)
			if name == null or condition == null
				throw EInvalidParam.new()
			end
			pConditions.setAt(name, condition)
		end
		
		
		
		/**
		 * \brief Count of bone mappings.
		 * \version 1.5
		 */
		public func int getBoneMappingCount()
			return pBoneMappings.getCount()
		end
		
		/**
		 * \brief Mapped bone or \em bone if no matching mapping is present.
		 * \version 1.5
		 */
		public func String mapBone(String bone)
			return pBoneMappings.getAt(bone, bone) cast String
		end
		
		/**
		 * \brief Set bone mapping.
		 * \version 1.5
		 */
		public func void setBoneMapping(String bone, String mappedBone)
			if bone == null or mappedBone == null
				throw EInvalidParam.new()
			end
			pBoneMappings.setAt(bone, mappedBone)
		end
		
		/**
		 * \brief Remove bone mapping if present.
		 * \version 1.5
		 */
		public func void removeBoneMapping(String bone)
			pBoneMappings.removeIfExisting(bone)
		end
		
		/**
		 * \brief Remove all bone mappings.
		 * \version 1.5
		 */
		public func void removeAllBoneMappings()
			pBoneMappings.removeAll()
		end
		
		/**
		 * \brief Visit bone mappings with block.
		 * \version 1.5
		 * 
		 * Block receives as first argument String bone and as second String mappedBone.
		 */
		public func void forEachBoneMapping(Block ablock)
			pBoneMappings.forEach(ablock)
		end
		
		
		
		/** \brief Clear all playback after adding to game world or spawning. */
		public func void clearAllPlayback()
			if pConversationActor != null
				pConversationActor.clearAllPlayback()
			end
		end
		
		/** \brief Update playback changing locomotion. */
		public func void updateLocomotion(float elapsed)
			if pConversationActor != null
				pConversationActor.updateBeforeLocomotion(elapsed)
			end
		end
		
		/** \brief Update playback changing animators. */
		public func void updateAnimators(float elapsed, ECBehaviorActorAnimated.Instance behavior)
			updateAnimators(elapsed, behavior.getAnimatorInstance())
		end
		
		public func void updateAnimators(float elapsed, AnimatorInstance sourceAnimatorInstance)
			if pConversationActor != null
				pConversationActor.updateAfterLocomotion(elapsed, sourceAnimatorInstance)
			end
		end
		
		/** \brief Apply animations. */
		public func void applyAnimations()
			if pConversationActor != null
				pConversationActor.applyAnimations()
			end
		end
		
		/** \brief Actor is in a conversation. */
		public func bool isInConversation()
			return pConversationActor != null and pConversationActor.getPlayback() != null
		end
		
		/** \brief Actor is not in a conversation. */
		public func bool isNotInConversation()
			return pConversationActor == null or pConversationActor.getPlayback() == null
		end
		
		
		
		/** \brief Ask listeners if conversation actions waiting for actor should block. */
		public func bool onWait()
			return pListeners.find(block Listener each
				return each.wait(this)
			end) != null
		end
		
		/** \brief Command send by the conversation script. */
		public func void runCommand(String command)
			runCommand(pCommandParser.parseCommand(command))
		end
		
		public func void runCommand(Array arguments)
			if arguments.getCount() == 0
				throw EInvalidParam.new("arguments is empty")
			end
			
			var String name = arguments.getAt(0) cast String
			var ConversationCommand command = pCommands.getAt(name, null) cast ConversationCommand
			if command == null
				throw EInvalidParam.new("Command with name '" + name + "' not found")
			end
			
			command.runCommand(this, arguments)
		end
		
		/** \brief Evaluate condition send by the conversation script. */
		public func bool evaluateCondition(String command)
			return evaluateCondition(pCommandParser.parseCommand(command))
		end
		
		public func bool evaluateCondition(Array arguments)
			if arguments.getCount() == 0
				throw EInvalidParam.new("arguments is empty")
			end
			
			var String name = arguments.getAt(0) cast String
			var ConversationCondition condition = pConditions.getAt(name, null) cast ConversationCondition
			if condition == null
				throw EInvalidParam.new("Condition with name '" + name + "' not found")
			end
			
			return condition.evaluateCondition(this, arguments)
		end
		
		/**
		 * \brief Actor speech has been started by CActionActorSpeak.
		 * \version 1.9
		 * 
		 * Called after setting up actor speech and before advancing conversation playback.
		 * Allows sub class to apply additional game actions at begin of actor speech started
		 * by instance of CActionActorSpeak. This method is always called no matter if the
		 * action set up any speech parameters or not. Use the action parameter to figure out
		 * if this is the case.
		 * 
		 * \param action Action starting speech or null if called otherwise.
		 */
		public func void onBeginActorSpeech(CActionActorSpeak action)
			pListeners.forEachCastable(block Listener2 each
				each.beginActorSpeech(this, action)
			end)
		end
		
		/** \brief Actor entered a conversation. */
		public func void onEnterConversation()
			pListeners.forEach(block Listener each
				each.enterConversation(this)
			end)
		end
		
		/**
		 * \brief Actor left a conversation.
		 * 
		 * Calls leaveConversationTasks() then notifies listeners.
		 */
		public func void onLeaveConversation()
			leaveConversationTasks()
			pListeners.forEach(block Listener each
				each.leaveConversation(this)
			end)
		end
		
		/**
		 * \brief Leave conversation tasks required to get actor back to working condition.
		 * 
		 * Default implementation does these actions:
		 * - Clear speech animation if existing
		 * - Clear head look-at playback if existing
		 * - Clear face poses if existing
		 * - Clear eye look-at playback if existing
		 */
		public func void leaveConversationTasks()
			var SpeechAnimationPlayback sap = pConversationActor.getSpeechAnimationPlayback()
			if sap != null
				sap.removeAllPhonemes()
			end
			
			var ConversationLookAtPlayback hlap = pConversationActor.getHeadLookAtPlayback()
			if hlap != null
				hlap.clearLookAtState()
			end
			
			var ConversationFacePosePlayback fpp = pConversationActor.getFacePosePlayback()
			if fpp != null
				fpp.removeAllPoses()
			end
			
			var ConversationLookAtPlayback elap = pConversationActor.getEyesLookAtPlayback()
			if elap != null
				elap.clearLookAtState()
			end
		end
		
		/**
		 * \brief Create sub title for actor matching speech style.
		 * 
		 * Calls createSubTitleTextWidget() then allows listeners to modify it.
		 */
		public func SubTitleBoxText createSubTitleText(UnicodeString text, StringID style)
			var ObjectReference stbt = ObjectReference.new(createSubTitleTextWidget(text, style))
			pListeners.forEach(block Listener each
				stbt.set(each.modifySubTitleText(this, stbt.get() cast SubTitleBoxText, text, style))
			end)
			return stbt.get() cast SubTitleBoxText
		end
		
		/**
		 * \brief Create sub title widget for actor matching speech style.
		 * 
		 * Default implementation uses sub title gui theme font and white color creating
		 * an instance of SubTitleBoxText with it.
		 * 
		 * Overwrite to use individual fonts and colors for actors and speak type or modifying
		 * the text for example to replace game specific variables or formating hints.
		 * 
		 * \param text Text to speak.
		 * \param style Identifier of style to adjust font, color or sub title in general.
		 */
		public func SubTitleBoxText createSubTitleTextWidget(UnicodeString text, StringID style)
			var String nameUtf8 = pConversationActor.getName().toString()
			var StyledTextDefinition styledName, styledText
			var String textUtf8 = text.toString()
			var Image portraitImage
			var Video portraitVideo
			
			if nameUtf8.empty()
				nameUtf8 = null
			end
			
			var String selector = ""
			if not pSubtitleSelectorId.empty()
				selector = selector + "." + pSubtitleSelectorId
			end
			if style != null
				selector = selector + "." + style
			end
			var String selectorText = "Label.SubTitleBoxText.Text" + selector
			
			if textUtf8.find('{') != -1
				var GuiTheme guiTheme = pSubtitleTheme
				if guiTheme == null
					guiTheme = pConversationActor.getPlayback().getSubTitle().getGuiTheme()
				end
				
				var DefaultLabelDesigner designer = guiTheme.getWidgetDesigner(selectorText) cast DefaultLabelDesigner
				
				var STDStyle pageStyle = STDStyle.new("page", designer.getLabelDesignNormal())
				
				var STDStyle defaultStyle = STDStyle.new("text", pageStyle)
				defaultStyle.setMargins(RectArea.new())
				
				styledText = pTagResolver.resolveTags(textUtf8, pageStyle, defaultStyle)
				textUtf8 = null
			end
			
			var SubTitleBoxTextBorder stbt = createBareSubTitleTextBorder(textUtf8, nameUtf8, \
				styledText, styledName, portraitImage, portraitVideo, SubTitleBoxTextBorder.Placement.above)
			
			stbt.setDesignerSelector("SubTitleBoxText" + selector)
			if stbt.getLabelName() != null
				stbt.getLabelName().setDesignerSelector("Label.SubTitleBoxText.Name" + selector)
			end
			if stbt.getLabelText() != null
				stbt.getLabelText().setDesignerSelector(selectorText)
			end
			
			return stbt
		end
		
		/**
		 * \brief Create bare sub title border.
		 * \version 1.16
		 * 
		 * For subclass use to replace widget without rewriting entire createSubTitleTextWidget().
		 */
		protected func SubTitleBoxTextBorder createBareSubTitleTextBorder(String textUtf8,\
		String nameUtf8, StyledTextDefinition styledText, StyledTextDefinition styledName,\
		Image portraitImage, Video portraitVideo, SubTitleBoxTextBorder.Placement placement)
			return SubTitleBoxTextBorder.new(textUtf8, nameUtf8, styledText, styledName,\
				portraitImage, portraitVideo, placement)
		end
		
		
		
		/** \brief Add listener. */
		public func void addListener(Listener listener)
			if listener == null
				throw EInvalidParam.new()
			end
			pListeners.add(listener)
		end
		
		/** \brief Remove listener. */
		public func void removeListener(Listener listener)
			pListeners.remove(listener)
		end
		
		
		
		/** \brief Add to game world. */
		public func void addToGameWorld()
			if pConversationActor == null
				return
			end
			
			pConversationActor.clearAllPlayback()
			if pRegisterConversationActor
				getElement().getGameWorld().getConvoActorList().add(pConversationActor)
			end
		end
		
		/** \brief Remove from game world. */
		public func void removeFromGameWorld()
			if pConversationActor == null
				return
			end
			
			if pRegisterConversationActor
				getElement().getGameWorld().getConvoActorList().remove(pConversationActor.getID())
			end
			pConversationActor.clearAllPlayback()
		end
		
		
		
		/** \brief Read behavior from file. */
		public func void readFromFile(PersistencyEnvironment env, FileReader reader)
			select reader.readByte() // version
			case 0
				pSubtitleSelectorId = reader.readString8()
				if pConversationActor != null
					pConversationActor.readFromFile(env, reader)
				end
				
			else
				throw EInvalidParam.new("unsupported version")
			end
		end
		
		/** \brief Write behavior to file. */
		public func void writeToFile(PersistencyEnvironment env, FileWriter writer)
			writer.writeByte(0) // version
			
			writer.writeString8(pSubtitleSelectorId)
			if pConversationActor != null
				pConversationActor.writeToFile(env, writer)
			end
		end
	end
	
	
	
	private var ECPStringID pActorId
	private var ECPStringID pAliasId
	private var ECPUnicodeString pName
	private var ECPString pSubtitleSelectorId
	private var ECPString pHeadRotatorBone
	private var ECPVector pHeadRotatorOffset
	private var ECPBoolean pRegisterConversationActor
	private var ECBehaviorActorAnimated pActorAnimated
	private var ECBehaviorAnimated pAnimated
	private var ECBehaviorTwoStateAnimated pTwoStateAnimated
	private var ECBehaviorLocomotion pLocomotion
	private var ECBehaviorParameterTable pParameterTable
	private var GuiTheme pSubtitleTheme
	private var Array pListenerFactories
	private var Array pBehaviorTrees
	
	
	
	/** \brief Create behavior element class. */
	public func new(BehaviorElementClass eclass) this(eclass, "convoActor.")
	end
	
	public func new(BehaviorElementClass eclass, String prefix) super(eclass)
		if getBehaviorIn(eclass) != null
			throw BEMultipleInstanceException.new(eclass, this)
		end
		
		var BaseGameApp app = BaseGameApp.getApp()
		if app != null
			pSubtitleTheme = app.getWindowSubTitle().getGuiTheme()
		end
		
		pListenerFactories = Array.new()
		pBehaviorTrees = Array.new()
		
		pActorId = ECPStringID.new(prefix + "id", null)
		eclass.addProperty(pActorId)
		
		pAliasId = ECPStringID.new(prefix + "aliasId", null)
		eclass.addProperty(pAliasId)
		
		pName = ECPUnicodeString.new(prefix + "name", UnicodeString.newFromUTF8(""))
		eclass.addProperty(pName)
		
		pSubtitleSelectorId = ECPString.new(prefix + "subtitleSelector", "")
		eclass.addProperty(pSubtitleSelectorId)
		
		pHeadRotatorBone = ECPString.new(prefix + "headRotatorBone", "")
		eclass.addProperty(pHeadRotatorBone)
		
		pHeadRotatorOffset = ECPVector.new(prefix + "headRotatorOffset", Vector.new(0, -1.65, 0))
		eclass.addProperty(pHeadRotatorOffset)
		
		pRegisterConversationActor = ECPBoolean.new(prefix + "registerConvoActor", false)
		eclass.addProperty(pRegisterConversationActor)
		
		eclass.addBehavior(this)
	end
	
	/** \brief Dispose of behavior. */
	public func void dispose()
		pBehaviorTrees = null
		pActorAnimated = null
		pAnimated = null
		pTwoStateAnimated = null
		pLocomotion = null
		pParameterTable = null
		pListenerFactories = null
		super.dispose()
	end
	
	
	
	/** \brief Actor identifier. */
	public func ECPStringID getActorId()
		return pActorId
	end
	
	/** \brief Alias identifier. */
	public func ECPStringID getAliasId()
		return pAliasId
	end
	
	/** \brief Name shown in sub title box. */
	public func ECPUnicodeString getName()
		return pName
	end
	
	/** \brief SUb title style selector ID. */
	public func ECPString getSubtitleSelectorId()
		return pSubtitleSelectorId
	end
	
	/** \brief Head rotator bone or empty string to not use. */
	public func ECPString getHeadRotatorBone()
		return pHeadRotatorBone
	end
	
	/** \brief Head rotator offset used for Head-Look-At handling. */
	public func ECPVector getHeadRotatorOffset()
		return pHeadRotatorOffset
	end
	
	/** \brief Register conversation actor with game world. */
	public func ECPBoolean getRegisterConversationActor()
		return pRegisterConversationActor
	end
	
	/** \brief Attach to actor animated behavior or null. */
	public func ECBehaviorActorAnimated getActorAnimated()
		return pActorAnimated
	end
	
	/** \brief Set actor animated behavior to attach to or null. */
	public func void setActorAnimated(ECBehaviorActorAnimated actorAnimated)
		pActorAnimated = actorAnimated
	end
	
	/** \brief Attach to animated behavior or null. */
	public func ECBehaviorAnimated getAnimated()
		return pAnimated
	end
	
	/** \brief Set animated behavior to attach to or null. */
	public func void setAnimated(ECBehaviorAnimated animated)
		pAnimated = animated
	end
	
	/** \brief Attach to animated behavior or null. */
	public func ECBehaviorTwoStateAnimated getTwoStateAnimated()
		return pTwoStateAnimated
	end
	
	/** \brief Set animated behavior to attach to or null. */
	public func void setTwoStateAnimated(ECBehaviorTwoStateAnimated animated)
		pTwoStateAnimated = animated
	end
	
	/** \brief Locomotion behavior or null. */
	public func ECBehaviorLocomotion getLocomotion()
		return pLocomotion
	end
	
	/** \brief Set locomotion behavior or null. */
	public func void setLocomotion(ECBehaviorLocomotion locomotion)
		pLocomotion = locomotion
	end
	
	/** \brief Parameter table behavior or null. */
	public func ECBehaviorParameterTable getParameterTable()
		return pParameterTable
	end
	
	/** \brief Set parameter table behavior or null. */
	public func void setParameterTable(ECBehaviorParameterTable parameterTable)
		pParameterTable = parameterTable
	end
	
	/** \brief Gui theme to use for sub title box creation. */
	public func GuiTheme getSubtitleTheme()
		return pSubtitleTheme
	end
	
	/** \brief Set gui theme to use for sub title box creation. */
	public func void setSubtitleTheme(GuiTheme guiTheme)
		pSubtitleTheme = guiTheme
	end
	
	/**
	 * \brief Add behavior behavior tree to add actions and conditions to.
	 * \version 1.19
	 */
	func void addBehaviorTree(ECBehaviorBehaviorTree behavior)
		if behavior == null
			throw ENullPointer.new("behavior")
		end
		pBehaviorTrees.add(behavior)
	end
	
	/**
	 * \brief Visit behavior behavior trees to add actions and conditions to.
	 * \version 1.19
	 * \param ablock Block with parameter ECBehaviorBehaviorTree.
	 */
	func void forEachBehaviorTree(Block ablock)
		pBehaviorTrees.forEach(ablock)
	end
	
	
	
	/** \brief Add listener factory. */
	public func void addListenerFactory(ListenerFactory factory)
		if factory == null
			throw ENullPointer.new()
		end
		pListenerFactories.add(factory)
	end
	
	/**
	 * \brief Add listener factory using block.
	 * 
	 * Block receives as parameter Instance and returns Listener.
	 */
	public func void addListenerFactory(Block blockFactory)
		pListenerFactories.add(BlockListenerFactory.new(blockFactory))
	end
	
	/** \brief Visit listener factories with block with argument ListenerFactory. */
	public func void forEachListenerFactory(Block ablock)
		pListenerFactories.forEach(ablock)
	end
	
	/** \brief Create listeners from factories adding them to behavior instance. */
	public func void createListeners(Instance instance)
		pListenerFactories.forEach(block ListenerFactory each
			instance.addListener(each.createListener(instance))
		end)
	end
	
	
	
	/** \brief Get instance in element from owner element class. */
	public func Instance instance(BehaviorElement element)
		return element.getInstanceAt(getInstanceIndex()) cast Instance
	end
	
	
	
	/**
	 * \brief Convenience method to get instance from conversation actor.
	 * 
	 * Checks if conversation actor is instance of BehaviorConversationActor.
	 * If true returns ECBehaviorConversationActor.Instance owning the conversation
	 * actor. If false returns null.
	 */
	public static func Instance instanceFromConvoActor(ConversationActor convoActor)
		if convoActor castable BehaviorConversationActor
			return (convoActor cast BehaviorConversationActor).getInstance()
			
		else
			return null
		end
	end
	
	
	
	/**
	 * \brief Get behavior in element class or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElementClass contains a behavior
	 * of type ECBehaviorConversationActor.
	 */
	static public func ECBehaviorConversationActor getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBehaviorConversationActor each
			return true
		end) cast ECBehaviorConversationActor
	end
	
	/**
	 * \brief Get instance in element or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElement contains a behavior instance
	 * of type ECBehaviorConversationActor.Instance .
	 */
	static public func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	
	
	/** \brief Create Behavior instance. */
	public func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
