/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Scenery

pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Utils


/**
 * \brief Behavior adding inverse kinematic support to actors.
 * 
 * IK is typically used for situations where actors touch specific points on an object while
 * interacting with them and the exact position or orientation is not well defined. This can
 * be used for example if the actor pulls a lever but the lever can be on different heights
 * above the ground. Using the IK behavior this can be solved without duplicating coding.
 * 
 * To use this behavior add it to the element class after ECBehaviorActorAnimated. By default
 * the behavior is disabled. To use IK enable/disable the behavior from the actor action
 * at the appropriate time. Once enabled the behavior tries to find in ECBehaviorActorAnimated
 * the animator controllers to input the IK parameters. All controllers are optional and will
 * be updated only if present. Assign to the behavior the target position to track. The
 * behavior actively tracks the element each frame update so dynamic targets are possible.
 * The target is defined using an Element instance with optional local matrix and bone name.
 * Bone name is supported if target is castable to BehaviorElement and supports
 * ECBehaviorComponent.
 * 
 * The behavior supports 3 controllers to input IK information to the animator.
 * 
 * The IK Position Controller is used to set position of the target relative to the component
 * assigned to the animator. The position is assigned as "vector value".
 * 
 * The IK Rotation Controller is used to set orientation of the target relative to the
 * component assigned to the animator. The orientation is assigned as "vector value".
 * 
 * The IK Height Controller is used to set the height of the target above the ground. This
 * is the same value as "position.getY()" but assigned as single "value". This controller
 * allows to fine tune animators to different target heights above ground. To get the best
 * results you usually have to use an animation for reaching at objects in upright and
 * crouched position. Using this controller you can blend between such animations
 * (typically a group rule with selector link).
 * 
 * The Pan Controller is used to set the horizontal panning of the target. This is the
 * same value as "position.getX()" but assigned as a single "value". This controller allows
 * to fine tune animators to different horizontal distances along a wall. To get the best
 * results you usually have to use an animation for reaching at objects at the far left
 * and right position on the wall. Using this controller you can blend betwen such animations
 * (typically a group rule with selector link).
 * 
 * The Distance Controller is used to set the distance of the target. This is the same value
 * as "position.getZ()" but assigned as a single "value". This controller allows to fine tune
 * animators to different distances in front of the actor. To get the best results you usually
 * have to use an animation for reaching at objects at far and close distance in front of the
 * actor. Using this controller you can blend betwen such animations (typically a group rule
 * with selector link).
 * 
 * The Azimuth Controller is used to set the location of the target relative to the actor
 * expressed as angle. This is the same value as "DEMath.atan2(-position.getX(), position.getZ())"
 * but assigned as a single "value". The value has a range from -180 to 180 with positive values
 * located on the left side of the actor. This controller allows to fine tune animators to
 * different locations around the actor. It is possible to simulate this angle in an animator
 * by using a properly shaped link curve on the pan or distance controller. Using the azimuth
 * controller though is simpler and leaves the link curve shape open for fine control. To get
 * the best results you usually have to use an animation for reaching at objects at the front,
 * left and right side of the actor and optionally at the back side. Using this controller you
 * can blend betwen such animations (typically a group rule with selector link).
 * 
 * The Elevation Controller is used to set the location of the target relative to the actor
 * expressed as angle. This is the same value as "DEMath.atan2(position.getY(), position.getZ())"
 * but assigned as a single "value". The value has a range from -90 to 90 with positive values
 * located upwards. This controller allows to fine tune animators to different locations around
 * the actor. It is possible to simulate this angle in an animator by using a properly shaped
 * link curve on the pan or distance controller. Using the elevation controller though is
 * simpler and leaves the link curve shape open for fine control. To get the best results you
 * usually have to use an animation for reaching at objects at the up, level and down position.
 * Using this controller you can blend betwen such animations (typically a group rule with
 * selector link).
 * 
 * For the height, pan, distance, azimuth and elevation controller a reference matrix can be
 * set. This indicates the coordinate system to use in the actor to calculate these values.
 * By default this is the identity matrix locating the coordinate system at the feet of the
 * actor pointing in the same direction as the actor. For using azimuth and elevation you
 * usually have to set the reference matrix near the shoulders to get meaningful values.
 * If a reference bone is set the reference matrix is relative to this bone.
 * 
 * Behavior can be added multiple times allowing to handle multiple IK targets per actor.
 * 
 * Element class property prefix is "actorIK" or "actorIK(id)".
 * 
 * These element class properties are supported:
 * - actorIK{(id)}.controllerIKPosition : ECBString. Name of IK Position Controller
 * - actorIK{(id)}.controllerIKRotation : ECBString. Name of IK Rotation Controller
 * - actorIK{(id)}.controllerIKHeight : ECBString. Name of IK Height Controller
 * - actorIK{(id)}.controllerIKPan: ECBString. Name of IK Pan Controller
 * - actorIK{(id)}.controllerIKDistance: ECBString. Name of IK Distance Controller
 * - actorIK{(id)}.controllerIKAzimuth: ECBString. Name of IK Azimuth Controller
 * - actorIK{(id)}.controllerIKElevation: ECBString. Name of IK Elevation Controller
 */
class ECBehaviorActorIK extends DefaultECBehavior
	/** \brief Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		/** \brief Update controllers listener. */
		private class UpdateControllers extends ECBehaviorActorAnimated.DefaultListener
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func void updateControllers(ECBehaviorActorAnimated.Instance instance, float elapsed)
				if pInstance.getEnabled()
					pInstance.updateControllers(elapsed)
				end
			end
			
			func void animatorChanged(ECBehaviorActorAnimated.Instance instance)
				if pInstance.getEnabled()
					pInstance.findControllers()
				end
			end
		end
		
		
		var ECBehaviorActorIK pECBehavior
		var ECBehaviorActorAnimated.Instance pActorAnimated
		var Component pComponent
		
		var String pNameControllerIKPosition
		var String pNameControllerIKRotation
		var String pNameControllerIKHeight
		var String pNameControllerIKPan
		var String pNameControllerIKDistance
		var String pNameControllerIKAzimuth
		var String pNameControllerIKElevation
		
		var AnimatorController pControllerIKPosition
		var AnimatorController pControllerIKRotation
		var AnimatorController pControllerIKHeight
		var AnimatorController pControllerIKPan
		var AnimatorController pControllerIKDistance
		var AnimatorController pControllerIKAzimuth
		var AnimatorController pControllerIKElevation
		
		var bool pEnabled
		
		var Element pTargetElement
		var DMatrix pTargetMatrix
		var String pTargetBone
		var ECBehaviorComponent.Instance pTargetComponent
		
		var Matrix pReferenceMatrix, pInverseReferenceMatrix
		var String pReferenceBone
		var int pIndexReferenceBone
		
		var bool pUseReference
		
		var ElementResolver pElementResolver
		
		
		
		/** \brief Create behavior instance. */
		func new(ECBehaviorActorIK ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			
			pEnabled = false
			pTargetMatrix = DMatrix.new()
			pReferenceMatrix = Matrix.new()
			pInverseReferenceMatrix = Matrix.new()
			
			pActorAnimated = ecbehavior.getActorAnimated().instance(element)
		end
		
		/** \brief Dispose of behavior instance. */
		func void dispose()
			pActorAnimated = null
			pTargetElement = null
			pTargetComponent = null
			pElementResolver = null
			
			super.dispose()
		end
		
		
		
		/** \brief Initialize behavior from stub. */
		func void init(StubElement stub)
			pNameControllerIKPosition = pECBehavior.getControllerIKPosition().getValue(stub)
			pNameControllerIKRotation = pECBehavior.getControllerIKRotation().getValue(stub)
			pNameControllerIKHeight = pECBehavior.getControllerIKHeight().getValue(stub)
			pNameControllerIKPan = pECBehavior.getControllerIKPan().getValue(stub)
			pNameControllerIKDistance = pECBehavior.getControllerIKDistance().getValue(stub)
			pNameControllerIKAzimuth = pECBehavior.getControllerIKAzimuth().getValue(stub)
			pNameControllerIKElevation = pECBehavior.getControllerIKElevation().getValue(stub)
			
			pComponent = pActorAnimated.getComponent().getComponent()
			
			pActorAnimated.addListener(UpdateControllers.new(this))
		end
		
		
		
		/** \brief Behavior. */
		func ECBehaviorActorIK getECBehavior()
			return pECBehavior
		end
		
		/** \brief Actor animated behavior. */
		func ECBehaviorActorAnimated.Instance getActorAnimated()
			return pActorAnimated
		end
		
		
		
		/** \brief Name of IK Position Controller. */
		func String getNameControllerIKPosition()
			return pNameControllerIKPosition
		end
		
		/** \brief Set name of IK Position Controller or null. */
		func void setNameControllerIKPosition(String name)
			pNameControllerIKPosition = name
		end
		
		/** \brief Name of IK Rotation Controller. */
		func String getNameControllerIKRotation()
			return pNameControllerIKRotation
		end
		
		/** \brief Set name of IK Rotation Controller or null. */
		func void setNameControllerIKRotation(String name)
			pNameControllerIKRotation = name
		end
		
		/** \brief Name of IK Height Controller. */
		func String getNameControllerIKHeight()
			return pNameControllerIKHeight
		end
		
		/** \brief Set name of IK Height Controller or null. */
		func void setNameControllerIKHeight(String name)
			pNameControllerIKHeight = name
		end
		
		/**
		 * \brief Name of IK Pan Controller.
		 * \version 1.21
		 */
		func String getNameControllerIKPan()
			return pNameControllerIKPan
		end
		
		/**
		 * \brief Set name of IK Pan Controller or null.
		 * \version 1.21
		 */
		func void setNameControllerIKPan(String name)
			pNameControllerIKPan = name
		end
		
		/**
		 * \brief Name of IK Distance Controller.
		 * \version 1.21
		 */
		func String getNameControllerIKDistance()
			return pNameControllerIKDistance
		end
		
		/**
		 * \brief Set name of IK Distance Controller or null.
		 * \version 1.21
		 */
		func void setNameControllerIKDistance(String name)
			pNameControllerIKDistance = name
		end
		
		/**
		 * \brief Name of IK Azimuth Controller.
		 * \version 1.21
		 */
		func String getNameControllerIKAzimuth()
			return pNameControllerIKAzimuth
		end
		
		/**
		 * \brief Set name of IK Azimuth Controller or null.
		 * \version 1.21
		 */
		func void setNameControllerIKAzimuth(String name)
			pNameControllerIKAzimuth = name
		end
		
		/**
		 * \brief Name of IK Elevation Controller.
		 * \version 1.21
		 */
		func String getNameControllerIKElevation()
			return pNameControllerIKElevation
		end
		
		/**
		 * \brief Set name of IK Elevation Controller or null.
		 * \version 1.21
		 */
		func void setNameControllerIKElevation(String name)
			pNameControllerIKElevation = name
		end
		
		
		
		/** \brief IK Position Controller or null if not found. */
		func AnimatorController getControllerIKPosition()
			return pControllerIKPosition
		end
		
		/** \brief IK Rotation Controller or null if not found. */
		func AnimatorController getControllerIKRotation()
			return pControllerIKRotation
		end
		
		/** \brief IK Height Controller or null if not found. */
		func AnimatorController getControllerIKHeight()
			return pControllerIKHeight
		end
		
		/**
		 * \brief IK Pan Controller or null if not found.
		 * \version 1.21
		 */
		func AnimatorController getControllerIKPan()
			return pControllerIKPan
		end
		
		/**
		 * \brief IK Distance Controller or null if not found.
		 * \version 1.21
		 */
		func AnimatorController getControllerIKDistance()
			return pControllerIKDistance
		end
		
		/**
		 * \brief IK Azimuth Controller or null if not found.
		 * \version 1.21
		 */
		func AnimatorController getControllerIKAzimuth()
			return pControllerIKAzimuth
		end
		
		/**
		 * \brief IK Elevation Controller or null if not found.
		 * \version 1.21
		 */
		func AnimatorController getControllerIKElevation()
			return pControllerIKElevation
		end
		
		
		
		/** \brief IK handling is enabled. */
		func bool getEnabled()
			return pEnabled
		end
		
		/** \brief Set if IK handling is enabled. */
		func void setEnabled(bool enabled)
			if enabled == pEnabled
				return
			end
			
			pEnabled = enabled
			
			findControllers()
		end
		
		/** \brief Disable behavior and clear target. */
		func void disable()
			setEnabled(false)
			clearTarget()
		end
		
		
		
		/**
		 * \brief Reference matrix.
		 * \version 1.21
		 */
		func Matrix getReferenceMatrix()
			return pReferenceMatrix
		end
		
		/**
		 * \brief Set reference matrix.
		 * \version 1.21
		 */
		func void setReferenceMatrix(Matrix matrix)
			if matrix == null
				throw ENullPointer.new()
			end
			
			pReferenceMatrix = matrix
			pInverseReferenceMatrix = matrix.getInverse()
		end
		
		/**
		 * \brief Set reference matrix from position.
		 * \version 1.21
		 */
		func void setReferenceMatrix(Vector position)
			pReferenceMatrix = Matrix.newTranslation(position)
			pInverseReferenceMatrix = Matrix.newTranslation(-position)
		end
		
		/**
		 * \brief Reference bone or null.
		 * \version 1.21
		 */
		func String getReferenceBone()
			return pReferenceBone
		end
		
		/**
		 * \brief Set reference bone or null.
		 * \version 1.21
		 */
		func void setReferenceBone(String bone)
			pReferenceBone = bone
			
			if bone != null and pComponent != null
				pIndexReferenceBone = pComponent.indexOfBoneNamed(bone)
				
			else
				pIndexReferenceBone = -1
			end
		end
		
		/**
		 * \brief Clear reference.
		 * \version 1.21
		 * 
		 * Sets reference matrix to identity matrix and reference bone to null.
		 */
		func void clearReference()
			pReferenceMatrix = Matrix.new()
			pInverseReferenceMatrix = Matrix.new()
			pReferenceBone = null
		end
		
		
		
		/** \brief Target element or null. */
		func Element getTargetElement()
			return pTargetElement
		end
		
		/** \brief Target matrix. */
		func DMatrix getTargetMatrix()
			return pTargetMatrix
		end
		
		/** \brief Set target matrix. */
		func void setTargetMatrix(DMatrix matrix)
			if matrix == null
				throw ENullPointer.new()
			end
			pTargetMatrix = matrix
		end
		
		/** \brief Set target matrix from position. */
		func void setTargetMatrix(Vector position)
			pTargetMatrix = DMatrix.newTranslation(DVector.new(position))
		end
		
		/** \brief Target bone or null. */
		func String getTargetBone()
			return pTargetBone
		end
		
		/** \brief Set target bone or null. */
		func void setTargetBone(String bone)
			pTargetBone = bone
		end
		
		/** \brief Target component behavior or null. */
		func ECBehaviorComponent.Instance getTargetComponent()
			return pTargetComponent
		end
		
		/** \brief Clear target. */
		func void clearTarget()
			pTargetElement = null
			pTargetMatrix = DMatrix.new()
			pTargetBone = null
			pTargetComponent = null
		end
		
		/** \brief Set target to static world position. */
		func void setTarget(DMatrix matrix)
			pTargetElement = null
			pTargetMatrix = matrix
			pTargetBone = null
			pTargetComponent = null
		end
		
		/** \brief Set target to track element position. */
		func void setTarget(Element element)
			setTarget(element, null, DMatrix.new())
		end
		
		/** \brief Set target to track position relative to element. */
		func void setTarget(Element element, Vector position)
			setTarget(element, null, position)
		end
		
		/** \brief Set target to track coordinate system relative to element. */
		func void setTarget(Element element, DMatrix matrix)
			setTarget(element, null, matrix)
		end
		
		/** \brief Set target to track position relative to element bone. */
		func void setTarget(Element element, String bone)
			setTarget(element, bone, DMatrix.new())
		end
		
		/** \brief Set target to track position relative to element bone. */
		func void setTarget(Element element, String bone, Vector position)
			setTarget(element, bone, DMatrix.newTranslation(DVector.new(position)))
		end
		
		/** \brief Set target to track coordinate system relative to element bone. */
		func void setTarget(Element element, String bone, DMatrix matrix)
			pTargetElement = element
			pTargetMatrix = matrix
			pTargetBone = bone
			pTargetComponent = null
			if element castable BehaviorElement
				pTargetComponent = ECBehaviorComponent.getInstanceIn(element cast BehaviorElement)
			end
		end
		
		
		
		/** \brief Find controllers. */
		func void findControllers()
			pControllerIKPosition = null
			pControllerIKRotation = null
			pControllerIKHeight = null
			pControllerIKPan = null
			pControllerIKDistance = null
			pControllerIKAzimuth = null
			pControllerIKElevation = null
			
			if pNameControllerIKPosition != null
				pControllerIKPosition = pActorAnimated.getControllerNamed(pNameControllerIKPosition)
			end
			if pNameControllerIKRotation != null
				pControllerIKRotation = pActorAnimated.getControllerNamed(pNameControllerIKRotation)
			end
			if pNameControllerIKHeight != null
				pControllerIKHeight = pActorAnimated.getControllerNamed(pNameControllerIKHeight)
			end
			if pNameControllerIKPan != null
				pControllerIKPan = pActorAnimated.getControllerNamed(pNameControllerIKPan)
			end
			if pNameControllerIKDistance != null
				pControllerIKDistance = pActorAnimated.getControllerNamed(pNameControllerIKDistance)
			end
			if pNameControllerIKAzimuth != null
				pControllerIKAzimuth = pActorAnimated.getControllerNamed(pNameControllerIKAzimuth)
			end
			if pNameControllerIKElevation != null
				pControllerIKElevation = pActorAnimated.getControllerNamed(pNameControllerIKElevation)
			end
			
			pUseReference = pControllerIKHeight != null or pControllerIKPan != null\
				or pControllerIKDistance != null or pControllerIKAzimuth != null\
				or pControllerIKElevation != null
		end
		
		/** \brief Update controllers. */
		func void updateControllers(float elapsed)
			var Matrix matrix = (calculateTargetMatrix() * pComponent.getInverseMatrix()).toMatrix()
			
			var Vector position = matrix.getPosition()
			if pControllerIKPosition != null
				pControllerIKPosition.setVector(position)
			end
			if pControllerIKRotation != null
				pControllerIKRotation.setRotation(matrix.getEulerAngles())
			end
			
			if pUseReference
				matrix = matrix * calculateInverseReferenceMatrix()
				position = matrix.getPosition()
				
				if pControllerIKHeight != null
					pControllerIKHeight.setValue(position.getY())
				end
				if pControllerIKDistance != null
					pControllerIKDistance.setValue(position.getZ())
				end
				if pControllerIKAzimuth != null
					pControllerIKAzimuth.setValue(DEMath.atan2(-position.getX(), position.getZ()))
				end
				if pControllerIKElevation != null
					pControllerIKElevation.setValue(DEMath.atan2(position.getY(), position.getZ()))
				end
			end
		end
		
		/** \brief Calculate target matrix in world space. */
		func DMatrix calculateTargetMatrix()
			var DMatrix matrix = pTargetMatrix
			
			if pTargetElement != null
				if pTargetComponent != null
					var Component component = pTargetComponent.getComponent()
					if pTargetBone != null
						matrix = matrix * component.getBoneMatrix(pTargetBone).toDMatrix()
					end
					matrix = matrix * component.getMatrix()
					
				else
					matrix = matrix * pTargetElement.getElementMatrix()
				end
			end
			
			return matrix
		end
		
		/** \brief Calculate inverse reference matrix in component space. */
		func Matrix calculateInverseReferenceMatrix()
			var Matrix matrix = pInverseReferenceMatrix
			
			if pIndexReferenceBone != -1 and pComponent != null
				matrix = matrix * pComponent.boneGetInverseMatrix(pIndexReferenceBone)
			end
			
			return matrix
		end
		
		
		
		/** \brief Element resolver used during loading or \em null if not set. */
		func ElementResolver getElementResolver()
			return pElementResolver
		end
		
		
		
		/** \brief Frame update started. */
		func void enterFrame()
			if pElementResolver != null
				pElementResolver.resolve(getElement().getGameWorld())
				pElementResolver = null
			end
		end
		
		
		
		/** \brief Read behavior from file. */
		func void readFromFile(PersistencyEnvironment env, FileReader reader)
			select reader.readByte() // version
			case 0
				var PersistencyFlags flags = PersistencyFlags.new(3, reader)
				
				pEnabled = flags.getAt(0)
				pTargetMatrix = DMatrix.readFromFile(reader)
				if flags.getAt(1)
					pTargetBone = reader.readString8()
				end
				
				if flags.getAt(2)
					pElementResolver = ElementResolver.new()
					pElementResolver.add(reader, block Element element
						pTargetElement = element
						if element castable BehaviorElement
							pTargetComponent = ECBehaviorComponent.getInstanceIn(element cast BehaviorElement)
						end
					end)
					setRequiresEnterFrame(true)
				end
				
			else
				throw EInvalidParam.new("unsupported version")
			end
		end
		
		/** \brief Write behavior to file. */
		func void writeToFile(PersistencyEnvironment env, FileWriter writer)
			writer.writeByte(0)
			
			var PersistencyFlags flags = PersistencyFlags.new(3)
			flags.setAt(0, pEnabled)
			flags.setAt(1, pTargetBone != null)
			flags.setAt(2, pTargetElement != null)
			flags.writeToFile(writer)
			
			pTargetMatrix.writeToFile(writer)
			if pTargetBone != null
				writer.writeString8(pTargetBone)
			end
			
			if pTargetElement != null
				ElementResolver.writeToFile(writer, pTargetElement)
			end
		end
	end
	
	
	
	var ECBehaviorActorAnimated pActorAnimated
	var ECPString pControllerIKPosition
	var ECPString pControllerIKRotation
	var ECPString pControllerIKHeight
	var ECPString pControllerIKPan
	var ECPString pControllerIKDistance
	var ECPString pControllerIKAzimuth
	var ECPString pControllerIKElevation
	
	
	
	/** \brief Create behavior element class. */
	func new(BehaviorElementClass eclass, ECBehaviorActorAnimated actorAnimated)\
	this(eclass, actorAnimated, "")
	end
	
	func new(BehaviorElementClass eclass, ECBehaviorActorAnimated actorAnimated, String id)\
	this(eclass, actorAnimated, id, id.empty() if "actorIK" else "actorIK(" + id + ")")
	end
	
	func new(BehaviorElementClass eclass, ECBehaviorActorAnimated actorAnimated, \
	String id, String subId) this(eclass, actorAnimated, id, subId, subId + ".")
	end
	
	func new(BehaviorElementClass eclass, ECBehaviorActorAnimated actorAnimated, \
	String id, String subId, String prefix) super(eclass, id)
		if actorAnimated == null
			throw ENullPointer.new("actorAnimated")
		end
		
		pActorAnimated = actorAnimated
		
		pControllerIKPosition = ECPString.new(prefix + "controllerIKPosition", "ik.position")
		eclass.addProperty(pControllerIKPosition)
		
		pControllerIKRotation = ECPString.new(prefix + "controllerIKRotation", "ik.rotation")
		eclass.addProperty(pControllerIKRotation)
		
		pControllerIKHeight = ECPString.new(prefix + "controllerIKHeight", "ik.height")
		eclass.addProperty(pControllerIKHeight)
		
		pControllerIKPan = ECPString.new(prefix + "controllerIKPan", "ik.pan")
		eclass.addProperty(pControllerIKPan)
		
		pControllerIKDistance = ECPString.new(prefix + "controllerIKDistance", "ik.distance")
		eclass.addProperty(pControllerIKDistance)
		
		pControllerIKAzimuth = ECPString.new(prefix + "controllerIKAzimuth", "ik.azimuth")
		eclass.addProperty(pControllerIKAzimuth)
		
		pControllerIKElevation = ECPString.new(prefix + "controllerIKElevation", "ik.elevation")
		eclass.addProperty(pControllerIKElevation)
		
		eclass.addBehavior(this)
	end
	
	/** \brief Dispose of behavior. */
	func void dispose()
		pActorAnimated = null
		super.dispose()
	end
	
	
	
	/** \brief Actor animated behavior. */
	func ECBehaviorActorAnimated getActorAnimated()
		return pActorAnimated
	end
	
	/** \brief IK Position Controller name. */
	func ECPString getControllerIKPosition()
		return pControllerIKPosition
	end
	
	/** \brief IK Rotation Controller name. */
	func ECPString getControllerIKRotation()
		return pControllerIKRotation
	end
	
	/** \brief IK Height Controller name. */
	func ECPString getControllerIKHeight()
		return pControllerIKHeight
	end
	
	/**
	 * \brief IK Pan Controller name.
	 * \version 1.21
	 */
	func ECPString getControllerIKPan()
		return pControllerIKPan
	end
	
	/**
	 * \brief IK Distance Controller name.
	 * \version 1.21
	 */
	func ECPString getControllerIKDistance()
		return pControllerIKDistance
	end
	
	/**
	 * \brief IK Azimuth Controller name.
	 * \version 1.21
	 */
	func ECPString getControllerIKAzimuth()
		return pControllerIKAzimuth
	end
	
	/**
	 * \brief IK Elevation Controller name.
	 * \version 1.21
	 */
	func ECPString getControllerIKElevation()
		return pControllerIKElevation
	end
	
	
	
	/** \brief Get instance in element from owner element class. */
	func Instance instance(BehaviorElement element)
		return element.getInstanceAt(getInstanceIndex()) cast Instance
	end
	
	
	
	/**
	 * \brief Get behavior in element class or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElementClass contains a behavior
	 * of type ECBehaviorComponent.
	 */
	static func ECBehaviorActorIK getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBehaviorActorIK each
			return true
		end) cast ECBehaviorActorIK
	end
	
	/**
	 * \brief Get behavior with id in element class or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElementClass contains a behavior
	 * of type ECBehaviorActorIK with specific identifier.
	 */
	static func ECBehaviorActorIK getBehaviorIn(BehaviorElementClass eclass, String id)
		return eclass.findBehavior(block ECBehaviorActorIK each
			return each.getID().equals(id)
		end) cast ECBehaviorActorIK
	end
	
	/**
	 * \brief Get list of all behaviors in element.
	 * 
	 * Returns list contains ECBehaviorActorIK behaviors in the order they have
	 * been created in the element.
	 */
	static func Array getAllBehaviorsIn(BehaviorElementClass eclass)
		return eclass.collectBehaviors(block ECBehaviorActorIK each
			return true
		end)
	end
	
	
	
	/**
	 * \brief Get instance in element or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElement contains a behavior instance
	 * of type ECBehaviorActorIK.Instance . If more than one instance is present returns
	 * the first instance.
	 */
	static func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	/**
	 * \brief Get instance with id in element or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElement contains a behavior instance
	 * of type ECBehaviorActorIK.Instance with specific identifier.
	 */
	static func Instance getInstanceIn(BehaviorElement element, String id)
		return element.findInstance(block Instance each
			return each.getECBehavior().getID().equals(id)
		end) cast Instance
	end
	
	/**
	 * \brief Get list of all instances in element.
	 * 
	 * Returns list contains ECBehaviorActorIK.Instance instances in the order they have
	 * been created in the element.
	 */
	static func Array getAllInstancesIn(BehaviorElement element)
		return element.collectInstances(block Instance each
			return true
		end)
	end
	
	
	
	/** \brief Create Behavior instance. */
	func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
