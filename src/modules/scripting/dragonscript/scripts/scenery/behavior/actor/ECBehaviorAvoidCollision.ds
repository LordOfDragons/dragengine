/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Scenery

pin Dragengine.BehaviorTreeSystem
pin Dragengine.ConversationSystem
pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Preloading
pin Dragengine.Utils
pin Dragengine.StateMachineSystem


/**
 * \brief Behavior adding support to actors to avoid collisions with ECBehaviorAvoidedByActor.
 * 
 * Behavior attaches to ECBehaviorActorMover to modify walking path while moving.
 * 
 * To use this behavior add it to the element class and make sure to call setShapesSphere()
 * to set up the collision test shapes. The best time to do this is either in
 * BehaviorElement.init() or inside BaseActorAction if you need to change them per action.
 * 
 * Requires these behaviors to be present:
 * - ECBehaviorColliderAI
 * - ECBehaviorLocomotion
 * - ECBehaviorActorMover
 * - ECBehaviorNavigator
 * 
 * Uses these behaviors if present.
 * - ECBehaviorRideOn
 * - ECBehaviorBehaviorTree
 * 
 * The following behavior tree actions are added if an ECBehaviorBehaviorTree is presen:
 * 
 * \par Action "avoidCollision.set"
 * 
 * Set behavior parameters. Supports these optional action parameters:
 * - waitBehindObstacles: calls setWaitBehindObstacles(). Value: "true", "false".
 * - enabled: calls setEnabled(). Value: "true", "false".
 * 
 * This is an example of using this action:
 * \code{.xml}
 * <action name='avoidCollision.set'>
 *    <parameter name='waitBehindObstacles'>true</parameter>
 *    <parameter name='enabled'>true</parameter>
 * </action>
 * \endcode
 * 
 * \see https://developer.dragondreams.ch/wiki/doku.php/dragengine:modules:dragonscript:behavior_avoidcollision
 */
class ECBehaviorAvoidCollision extends DefaultECBehavior
	/**
	 * \brief Behavior factory.
	 * \version 1.25
	 * 
	 * Automatically assigns these behaviors if present before adding:
	 * - Required: \ref ECBehaviorActorMover
	 * - Optional: \ref ECBehaviorRideOn
	 * - Optional: \ref ECBehaviorBehaviorTree
	 * 
	 * Example XML element class:
	 * \code{.xml}
	 * <behavior type='ECBehaviorAvoidCollision'>
	 *   <!-- optional: set collision filter. default value '3:0 1 2 3' which means
	 *                  category BaseGameApp.CollisionFilterBit.actorAI
	 *                  filter BaseGameApp.CollisionFilterBit.geometry,
	 *                         BaseGameApp.CollisionFilterBit.dynamic,
	 *                         BaseGameApp.CollisionFilterBit.actorAI.
	 *                  format is '', 'category' or 'category:filter' where category and filter
	 *                  are a list of bits to set. -->
	 *   <string name='collisionFilter'>3:0 1 2 3</string>
	 * 
	 *   <!-- optional: add behavior trees. default adds all behavior trees. -->
	 *   <list name='behaviorTrees'>
	 *     <string/> <!-- add behavior with empty identifier -->
	 *     <string>default</string> <!-- add behavior with 'default' identifier -->
	 *   </list>
	 * 
	 *   <!-- optional: add state machines. default adds all state machines. -->
	 *   <list name='stateMachines'>
	 *     <string/> <!-- add behavior with empty identifier -->
	 *     <string>default</string> <!-- add behavior with 'default' identifier -->
	 *   </list>
	 * </behavior>
	 * \endcode
	 * 
	 * Element class properties added by the behavior can also be set directly inside the tag
	 * be removing the property name prefix and starting with a "." (for example ".propertyName").
	 */
	class Factory implements BehaviorFactory
		func new()
		end
		
		func String factoryId()
			return "ECBehaviorAvoidCollision"
		end
		
		func ECBehavior addBehavior(BehaviorElementClass eclass, String id, Dictionary parameters)
			if not id.empty()
				throw EInvalidParam.new("id is not empty string")
			end
			var ECBehaviorAvoidCollision behavior = ECBehaviorAvoidCollision.new(eclass,\
				ECBehaviorActorMover.getBehaviorIn(eclass), ECBehaviorRideOn.getBehaviorIn(eclass))
			
			eclass.sharedFactoryHelper.allBTSM(behavior.getBTSMs(), eclass, parameters)
			
			if parameters.has("collisionFilter")
				behavior.getCollisionFilter().setCollisionFilter(ElementClass.getSharedCodecPropertyString().\
					decodeCollisionFilter(parameters.getAt("collisionFilter") cast String))
			end
			
			eclass.sharedFactoryHelper.setPropertiesFromParameters(eclass, parameters, "avoidCollision")
			return behavior
		end
	end
	
	/** \brief Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		/** \brief Listen to actor mover events. */
		private class MoverEvents extends ECBehaviorActorMover.DefaultListener
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func void startMoving(ECBehaviorActorMover.Instance instance)
				pInstance.clearAvoiding()
			end
			
			func void stopMoving(ECBehaviorActorMover.Instance instance)
				pInstance.clearAvoiding()
			end
			
			func void modifyMoveTowards(ECBehaviorActorMover.Instance instance, DVector position, float elapsed)
				pInstance.onModifyMoveTowards(position, elapsed)
			end
		end
		
		/** \brief Ridable changed. */
		private class RidableChanged extends ECBehaviorRideOn.DefaultListener
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func void ridableChanged(ECBehaviorRideOn.Instance instance)
				pInstance.onRidableChanged()
			end
		end
		
		/** \brief Visitor for testing element for collision. */
		private class AvoidElement extends ElementVisitor
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func void visitBehaviorElement(BehaviorElement element)
				pInstance.avoidBehaviorElement(element)
			end
		end
		
		/**
		 * \brief Behavior tree action "avoidCollision.set".
		 * \version 1.19
		 */
		private class BTASet extends BTSMActionCondition
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func BTResult runActionShared(Object context, Dictionary parameters)
				var Object value = parameters.getAt("waitBehindObstacles", null)
				if value != null
					pInstance.setWaitBehindObstacles(value.equals("true"))
				end
				
				value = parameters.getAt("enabled", null)
				if value != null
					pInstance.setEnabled(value.equals("true"))
				end
				
				return BTResult.success
			end
		end
		
		/**
		 * \brief Behavior tree action "avoidCollision.update".
		 * \version 1.26
		 */
		private class BTAUpdate extends BTSMActionCondition
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func BTResult runActionShared(Object context, Dictionary parameters)
				if parameters.has("stop")
					pInstance.clearAvoiding()
				end
				
				return BTResult.success
			end
		end
		
		/**
		 * \brief Behavior tree action/condition "avoidCollision.check".
		 * \version 1.26
		 */
		private class BTACheck extends BTSMActionCondition
			var Instance pInstance
			var String pPrefix
			
			func new(Instance instance, String prefix)
				pInstance = instance
				pPrefix = prefix
			end
			
			func BTResult runActionShared(Object context, Dictionary parameters)
				return check("", parameters) if BTResult.success\
					else (parameters.has("wait") if BTResult.running else BTResult.failure)
			end
			
			func bool evaluateConditionShared(Object context, Dictionary parameters)
				return check(pPrefix, parameters)
			end
			
			func bool check(String prefix, Dictionary parameters)
				var bool result = true
				var Object value
				
				value = parameters.getAt(prefix + "waitBehindObstacles", null)
				if value != null
					result &= pInstance.getWaitBehindObstacles() == value.equals("true")
				end
				
				value = parameters.getAt(prefix + "enabled", null)
				if value != null
					result &= pInstance.getEnabled() == value.equals("true")
				end
				
				value = parameters.getAt(prefix + "avoiding", null)
				if value != null
					result &= pInstance.getDeviationTime() > 0
				end
				
				value = parameters.getAt(prefix + "avoiding.time.less", null)
				if value != null
					result &= pInstance.getDeviationTime() < (value cast String).toFloat()
				end
				
				value = parameters.getAt(prefix + "avoiding.time.greater", null)
				if value != null
					result &= pInstance.getDeviationTime() > (value cast String).toFloat()
				end
				
				return result
			end
		end
		
		
		
		var ECBehaviorAvoidCollision pECBehavior
		var ECBehaviorActorMover.Instance pActorMover
		var ECBehaviorRideOn.Instance pRideOn
		var ECBehaviorRidable.Instance pRidable
		
		var ColliderCollisionTest pCCTAvoidCollision
		var ColliderCollisionTest pCCTCheckLeft
		var ColliderCollisionTest pCCTCheckRight
		var ElementVisitor pAvoidElement
		var float pAvoidTimeContactCollision
		var bool pWaitBehindObstacles
		var float pCheckOffset
		var float pRadius
		var bool pEnabled
		
		var float pSpeedMultiplier
		var float pDeviationAngle
		var float pDeviationTime
		
		var float pCheckInterval
		var float pCheckTimer
		
		var ElementResolver pElementResolver
		var ECComposeBTSM.Instance pBTSMs
		
		
		
		/** \brief Create behavior instance. */
		func new(ECBehaviorAvoidCollision ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			
			pAvoidElement = AvoidElement.new(this)
			pAvoidTimeContactCollision = 0.5 // 1
			pWaitBehindObstacles = false
			pCheckOffset = 0.4
			pRadius = 0.4
			pEnabled = true
			
			pSpeedMultiplier = 1
			pDeviationAngle = 0
			pDeviationTime = 0
			
			
			// to calculate the check interval a detection distance of 3m is assumed with a
			// walking speed of 1.25m. we want to get a check at least every 1/4 to 1/3 detection
			// distance to avoid problems. for walking speed this is around 0.5s check interval.
			// for running speed of 4m a check interval of 0.15s should work.
			pCheckInterval = 0.5
			pCheckTimer = 0
			
			pActorMover = ecbehavior.getActorMover().instance(element)
			
			setRequiresThink(true)
		end
		
		/** \brief Dispose of behavior instance. */
		func void dispose()
			pRidable = null
			pRideOn = null
			pActorMover = null
			pElementResolver = null
			pAvoidElement = null
			pBTSMs = null
			
			super.dispose()
		end
		
		
		
		/** \brief Initialize from stub. */
		func void init(StubElement stub)
			var BehaviorElement element = getElement()
			
			if pECBehavior.getRideOn() != null
				pRideOn = pECBehavior.getRideOn().instance(element)
			end
			
			var Collider collider = pActorMover.getLocomotion().getColliderAI().getCollider()
			if collider == null
				return
			end
			
			// create collision tests
			var CollisionFilter collisionFilter = pECBehavior.getCollisionFilter().getCollisionFilter()
			pRadius = pECBehavior.getRadius().getValue(stub)
			
			pCCTAvoidCollision = ColliderCollisionTest.new(collisionFilter, Vector.new(), Vector.new())
			pCCTAvoidCollision.setCollider(ColliderVolume.new())
			pCCTAvoidCollision.setLocalDirection(false)
			pCCTAvoidCollision.setEnabled(false)
			collider.addCollisionTest(pCCTAvoidCollision)
			collider.addIgnoreCollider(pCCTAvoidCollision.getCollider())
			
			pCCTCheckLeft = ColliderCollisionTest.new(collisionFilter, Vector.new(), Vector.new())
			pCCTCheckLeft.setCollider(ColliderVolume.new())
			pCCTCheckLeft.setLocalDirection(false)
			pCCTCheckLeft.setEnabled(false)
			collider.addCollisionTest(pCCTCheckLeft)
			collider.addIgnoreCollider(pCCTCheckLeft.getCollider())
			
			pCCTCheckRight = ColliderCollisionTest.new(collisionFilter, Vector.new(), Vector.new())
			pCCTCheckRight.setCollider(ColliderVolume.new())
			pCCTCheckRight.setLocalDirection(false)
			pCCTCheckRight.setEnabled(false)
			collider.addCollisionTest(pCCTCheckRight)
			collider.addIgnoreCollider(pCCTCheckRight.getCollider())
			
			// add listeners
			pActorMover.addListener(MoverEvents.new(this))
			
			if pRideOn != null
				pRideOn.addListener(RidableChanged.new(this))
			end
			
			if pECBehavior.getBTSMs().hasAny()
				var String prefix = pECBehavior.getPrefix()
				pBTSMs = ECComposeBTSM.Instance.new(element, pECBehavior.getBTSMs())
				pBTSMs.addAllAction(prefix, "set", BTASet.new(this))
				pBTSMs.addAllAction(prefix, "update", BTAUpdate.new(this))
				pBTSMs.addAllActionCondition(prefix, "check", BTACheck.new(this, prefix))
				pBTSMs.dropBTContexts()
			end
		end
		
		
		
		/** \brief Behavior. */
		func ECBehaviorAvoidCollision getECBehavior()
			return pECBehavior
		end
		
		/** \brief Actor mover behavior. */
		func ECBehaviorActorMover.Instance getActorMover()
			return pActorMover
		end
		
		/** \brief Ride on behavior. */
		func ECBehaviorRideOn.Instance getRideOn()
			return pRideOn
		end
		
		
		
		/** \brief Avoid collider collision test. */
		func ColliderCollisionTest getCCTAvoidCollision()
			return pCCTAvoidCollision
		end
		
		/** \brief Check left collider collision test. */
		func ColliderCollisionTest getCCTCheckLeft()
			return pCCTCheckLeft
		end
		
		/** \brief Check right collider collision test. */
		func ColliderCollisionTest getCCTCheckRight()
			return pCCTCheckRight
		end
		
		/** \brief Avoid element visitor. */
		func ElementVisitor getAvoidElement()
			return pAvoidElement
		end
		
		/** \brief Set avoid element visitor. */
		func void setAvoidElement(ElementVisitor visitor)
			pAvoidElement = visitor
		end
		
		/** \brief Avoid time contact collision. */
		func float getAvoidTimeContactCollision()
			return pAvoidTimeContactCollision
		end
		
		/** \brief Set avoid time contact collision. */
		func void setAvoidTimeContactCollision(float time)
			pAvoidTimeContactCollision = DEMath.max(time, 0.0)
		end
		
		/** \brief Wait behind obstacles instead of moving around them. */
		func bool getWaitBehindObstacles()
			return pWaitBehindObstacles
		end
		
		/** \brief Set wait behind obstacles instead of moving around them. */
		func void setWaitBehindObstacles(bool moveAroundActors)
			pWaitBehindObstacles = moveAroundActors
		end
		
		/** \brief Avoid radius. */
		func float getRadius()
			return pRadius
		end
		
		/** \brief Set avoid radius. */
		func void setRadius(float radius)
			pRadius = DEMath.max(radius, 0.0)
		end
		
		/** \brief Collision avoiding is enabled. */
		func bool getEnabled()
			return pEnabled
		end
		
		/** \brief Set if collision avoiding is enabled. */
		func void setEnabled(bool enabled)
			if enabled == pEnabled
				return
			end
			
			pEnabled = enabled
			
			if not enabled
				disarmTest()
				clearAvoiding()
			end
			setRequiresThink(enabled)
		end
		
		/** \brief Check offset. */
		func float getCheckOffset()
			return pCheckOffset
		end
		
		/** \brief Set check offset. */
		func void setCheckOffset(float offset)
			pCheckOffset = DEMath.max(offset, 0.0)
		end
		
		/** \brief Check interval in seconds. */
		func float getCheckInterval()
			return pCheckInterval
		end
		
		/** \brief Set check interval in seconds. */
		func void setCheckInterval(float interval)
			pCheckInterval = DEMath.max(interval, 0.0)
		end
		
		/** \brief Check timer. */
		func float getCheckTimer()
			return pCheckTimer
		end
		
		/** \brief Set check timer. */
		func void setCheckTimer(float timer)
			pCheckTimer = timer
		end
		
		
		
		/** \brief Speed multiplier. */
		func float getSpeedMultiplier()
			return pSpeedMultiplier
		end
		
		/** \brief Set speed multiplier. */
		func void setSpeedMultiplier(float multiplier)
			pSpeedMultiplier = multiplier
		end
		
		/** \brief Deviation angle. */
		func float getDeviationAngle()
			return pDeviationAngle
		end
		
		/** \brief Set deviation angle. */
		func void setDeviationAngle(float angle)
			if pRidable != null
				angle -= pRidable.getCollider().getCollider().getOrientation().getEulerAngles().getY()
			end
			pDeviationAngle = DEMath.normalize(angle, -180.0, 180.0)
		end
		
		/** \brief Deviation time. */
		func float getDeviationTime()
			return pDeviationTime
		end
		
		/** \brief Set deviation time. */
		func void setDeviationTime(float time)
			pDeviationTime = time
		end
		
		/** \brief Clear avoiding. */
		func void clearAvoiding()
			var bool notify = pDeviationTime > 0
			
			pSpeedMultiplier = 1
			pDeviationAngle = 0
			pDeviationTime = 0
			
			if notify and pBTSMs != null
				pBTSMs.runEvent(pECBehavior.getPrefix(), "stop")
			end
		end
		
		
		
		/** \brief Rideable the actor is standing upon or \em null. */
		func ECBehaviorRidable.Instance getRidable()
			return pRidable
		end
		
		/**
		 * \brief Ridable changed.
		 * 
		 * Called by RidableChanged. If overwritten do not forget to super-call.
		 */
		func void onRidableChanged()
			var ECBehaviorRidable.Instance ridable = pRideOn.getRidable()
			if pDeviationTime <= 0
				pRidable = ridable
				return
			end
			
			if pRidable != null
				pDeviationAngle += pRidable.getCollider().getCollider().getOrientation().getEulerAngles().getY()
			end
			
			pRidable = ridable
			
			if ridable != null
				pDeviationAngle -= ridable.getCollider().getCollider().getOrientation().getEulerAngles().getY()
			end
		end
		
		
		
		/**
		 * \brief Set sphere collision test collider shapes.
		 * 
		 * Uses sphere shape located a distance above ground.
		 */
		func void setShapesSphere(float radius, float distanceAboveGround)
			var ShapeList shape = ShapeList.new()
			shape.addSphere(Vector.new(0, distanceAboveGround, 0), radius)
			(pCCTAvoidCollision.getCollider() cast ColliderVolume).setShape(shape)
			(pCCTCheckLeft.getCollider() cast ColliderVolume).setShape(shape)
			(pCCTCheckRight.getCollider() cast ColliderVolume).setShape(shape)
			
			pCheckOffset = radius * 2 + 0.05
		end
		
		/** \brief Add colliders required for avoiding as colliders to ignore. */
		func void addIgnoreCollidersTo(Collider collider)
			collider.addIgnoreCollider(pCCTAvoidCollision.getCollider())
			collider.addIgnoreCollider(pCCTCheckLeft.getCollider())
			collider.addIgnoreCollider(pCCTCheckRight.getCollider())
		end
		
		/**
		 * \brief Add collider to ignore to colliders required for avoiding.
		 * \version 1.17
		 */
		func void addIgnoreCollider(Collider collider)
			pCCTAvoidCollision.getCollider().addIgnoreCollider(collider)
			pCCTCheckLeft.getCollider().addIgnoreCollider(collider)
			pCCTCheckRight.getCollider().addIgnoreCollider(collider)
		end
		
		/**
		 * \brief Mutually ignore colliders.
		 * \version 1.17
		 * 
		 * Same as calling addIgnoreCollidersTo() and addIgnoreCollider() for the same collider.
		 * Use this call to make sure the given collider is ignored by all colliders required
		 * or avoiding and vice versa. The ECBehaviorColliderAI reachable from
		 * ECBehaviorActorMover is automatically made mutually ignore.
		 */
		func void mutualIgnoreColliders(Collider collider)
			addIgnoreCollidersTo(collider)
			addIgnoreCollider(collider)
		end
		
		
		
		/** \brief Collision test is armed. */
		func bool isTestArmed()
			return pCCTAvoidCollision.getEnabled()
		end
		
		/** \brief Arm collision test with direction. */
		func void armTest(Vector direction)
			pCCTAvoidCollision.setDirection(direction)
			pCCTAvoidCollision.setEnabled(true)
			
			// direction is not local. we need to calculate the correct offset using the direction and the up vector
			var Matrix checkMatrix
			
			if DEMath.fabs(direction.getY()) < 0.999
				checkMatrix = Matrix.newVU(direction, Vector.new(0, 1, 0))
				
			else
				checkMatrix = Matrix.new()
			end
			
			pCCTCheckLeft.setDirection(direction)
			pCCTCheckLeft.setOrigin(checkMatrix * Vector.new(-pCheckOffset, 0, 0))
			pCCTCheckLeft.setEnabled(true)
			
			pCCTCheckRight.setDirection(direction)
			pCCTCheckRight.setOrigin(checkMatrix * Vector.new(pCheckOffset, 0, 0))
			pCCTCheckRight.setEnabled(true)
		end
		
		/** \brief Disarm collision test. */
		func void disarmTest()
			pCCTAvoidCollision.setEnabled(false)
			pCCTCheckLeft.setEnabled(false)
			pCCTCheckRight.setEnabled(false)
		end
		
		
		
		/**
		 * \brief Avoid collision if enabled and a collision has been found.
		 * 
		 * Called by think().
		 */
		func void update(float elapsed)
			if not pEnabled
				return
			end
			
			pDeviationTime -= elapsed
			
			// if a collision test has been done the last frame evaluate it
			if isTestArmed()
				avoidCollision(elapsed)
				disarmTest()
			end
			
			// update timer. if elapsed trigger a collision test unless not moving. the test
			// direction depends on the moving orientation but not the movement speed. for this
			// reason the running state of the actor is used to pick the suitable interval
			pCheckTimer += elapsed
			if pCheckTimer < pCheckInterval
				return
			end
			
			// trigger a collision test for the next frame update if the actor has a mover goal
			// and is moving not too slow
			pCheckTimer = 0
			startTests(elapsed)
		end
		
		
		
		/** \brief Avoid collision if required. */
		func void avoidCollision(float elapsed)
			clearAvoiding()
			
			if not pCCTAvoidCollision.getHasCollision()
				return
			end
			
			//checkTargetBlocked()
			avoidElement(pCCTAvoidCollision.hitCollider(0).getOwner() cast Element)
		end
		
		/** \brief Start collision tests for the next interval if applicable. */
		func void startTests(float elapsed)
			if pActorMover.hasNoGoal() or pActorMover.getSpeed() < 0.01
				clearAvoiding()
				return
			end
			
			// find the velocity to check. we can not use the locomotion moving orientation
			// for this since this has been modified by our deviation angle. doing so would
			// cause the test to find no collision and the deviating is cancelled although
			// still required to be used. we could store the relative deviation angle and
			// test again but it is simpler to use the next path point of the actor mover.
			// this avoids storing the relative deviation angle and gives us the correct
			// orientation
			var DVector nextPathPoint = pActorMover.getWorldNextPathPoint()
			if nextPathPoint == null
				// this should never happen but better safe than sorry
				clearAvoiding()
				return
			end
			
			var DVector actorPosition = pActorMover.getLocomotion().getColliderAI().getCollider().getPosition()
			var DVector targetDirection = nextPathPoint - actorPosition
			if targetDirection.getLength() < 0.1
				// we are nearly at the target. no sense in trying to deviate now
				clearAvoiding()
				return
			end
			
			var Vector velocity = targetDirection.normalize().toVector() * pActorMover.getSpeed()
			
			// calculate the test direction. by default the actor would look ahead 2 or 3 seconds.
			// if the mover navigation path has a path point closer than this time frame the time
			// frame is reduced. if this is not done actors would try to avoid obstacles although
			// their direction changes before the obstacle would be a problem resulting in actors
			// getting stuck for no obvious reason
			var Locomotion locomotion = pActorMover.getLocomotion().getLocomotion()
			var float frameMovementDistance = locomotion.getAbsMovingSpeed() * elapsed
				// actor moves during the frame before collision tests are done
			var Vector direction = velocity * 2
			//direction = locomotion.getMovingDirectionVector() * 3
			// using getMovingDirectionVector() requires using setLocalDirection() on CCT
			var float directionLen = direction.getLength()
			direction = direction / directionLen
			
			if pActorMover.hasNextPathPoint()
				directionLen = DEMath.min(directionLen, \
					pActorMover.getWorldDistanceNextPoint() - frameMovementDistance)
			end
			
			directionLen = DEMath.min(directionLen, pActorMover.getDistanceToGoal() \
				- pActorMover.getGoalDistance() - frameMovementDistance)
			if directionLen < 0.1
				clearAvoiding()
				return
			end
			
			armTest(direction * directionLen)
		end
		
		
		
		/**
		 * \brief Avoid collision with an element if deemded necessary.
		 * 
		 * Default implementation does nothing if element is null. Otherwise uses avoid-element
		 * visitor on element to apply element specific avoiding.
		 */
		protected func void avoidElement(Element element)
			if element != null
				element.visit(pAvoidElement)
			end
		end
		
		/**
		 * \brief Avoid behavior element.
		 * 
		 * Called by AvoidElement visitor. Default implementation calls avoidAvoidedByActor
		 * for all ECBehaviorAvoidedByActor instances present in the element.
		 */
		func void avoidBehaviorElement(BehaviorElement element)
			// try to avoid the actor
			element.forEachInstance(block ECBehaviorAvoidedByActor.Instance each
				avoidAvoidedByActor(each)
			end)
		end
		
		/**
		 * \brief Avoid actor.
		 */
		func void avoidAvoidedByActor(ECBehaviorAvoidedByActor.Instance behavior)
			if not behavior.shouldBeAvoided()
				return // do not avoid but prevent actor from detecting elements behind
			end
			
			if pWaitBehindObstacles
				waitBehindAvoidedByActor(behavior)
				
			else
				moveAroundAvoidedByActor(behavior)
			end
		end
		
		
		
		/**
		 * \brief Move around avoided by actor.
		 */
		func void moveAroundAvoidedByActor(ECBehaviorAvoidedByActor.Instance behavior)
			// if moving slowly do not avoid collision
			var float actorSpeed = pActorMover.getSpeed()
			if actorSpeed < 0.01
				return
			end
			
			var Vector norActorVelocity = Matrix.newRotationY(pActorMover.getLocomotion() \
				.getLocomotion().getMovingOrientation()).getViewVector()
			var Vector actorVelocity = norActorVelocity * actorSpeed
			
			// if hit normal is pointing away do not avoid
			var float hitAngle = DEMath.acos(norActorVelocity * pCCTAvoidCollision.hitNormalWorld(0))
			if /* pCCTAvoidCollision.hitDistance(0) > 0.01 and */ hitAngle < 100
// 				BaseGameApp.getApp().getConsole().addMessage("moveAroundAvoidedByActor "\
// 					+ getElement().getPosition() + ": return hitAngle=" + hitAngle)
				return
			end
			
			// find the collider to use
			var Collider collider = bestColliderFor(behavior)
			
			// if the element is behind actor in respect to velocity do not avoid
			var Vector colliderVelocity = collider.getLinearVelocity()
			var DVector actorPosition = pActorMover.getLocomotion().getColliderAI().getCollider().getPosition()
			var DVector connection = collider.getPosition() - actorPosition
			if actorVelocity * connection.toVector() <= 0
// 				BaseGameApp.getApp().getConsole().addMessage("moveAroundAvoidedByActor "\
// 					+ getElement().getPosition() + ": return behind=" + (actorVelocity * connection.toVector()))
				return
			end
			
			// if collider is moving use relative speed to calculate a hit-distance threshold.
			// the threshold ensures actors avoid a moving collider only from more up close.
			// this check also skips avoiding if collider moves faster than actor:
			//    speedDiff = actorSpeed - (norActorVelocity * velocity)
			//    hitDistanceThreshold = speedDiff / actorSpeed
			if pCCTAvoidCollision.getCollisionAt(0).getDistance()\
			>= 1.0 - (norActorVelocity * colliderVelocity) / actorSpeed
// 				BaseGameApp.getApp().getConsole().addMessage("moveAroundAvoidedByActor "\
// 					+ getElement().getPosition() + ": return relSpeed=("\
// 					+ pCCTAvoidCollision.getCollisionAt(0).getDistance() + ","\
// 					+ (1.0 - (norActorVelocity * colliderVelocity) / actorSpeed) + ")")
				return
			end
			
			// if close to the hit point do contact collision avoid
			/*
			if pCCTAvoidCollision.hitDistance(0) < 0.01
				contactCollision()
				return
			end
			*/
			
			// if element is crossing our path without walking to or away from us wait behind it.
			// works only if the collider is moving. avoids actors walking around an obstacle
			// which they can better avoid by just waiting a second or two.
			var float crossAngle = 0
			if colliderVelocity.getLength() > 0.01
				crossAngle = DEMath.acos(norActorVelocity * colliderVelocity.normalize())
// 				if crossAngle > 20 and crossAngle < 160
				if crossAngle > 60 and crossAngle < 120 // 30 degrees spread around 90 degrees
					waitBehindAvoidedByActor(behavior)
// 					BaseGameApp.getApp().getConsole().addMessage("moveAroundAvoidedByActor "\
// 						+ getElement().getPosition() + ": return crossing=" + crossAngle)
					return
				end
			end
			
			// if the other element also supports ECBehaviorAvoidCollision check who should
			// avoid the other. If the other element is already avoiding apply wait behind
			// to slow down before continue moving. speed multiplier is negative if the
			// other actor is backing off a bit to make it easier for use to get around
			
			var ECBehaviorAvoidCollision.Instance otherAvoidCollision = \
				ECBehaviorAvoidCollision.getInstanceIn(behavior.getElement())
			if otherAvoidCollision != null and otherAvoidCollision.pDeviationTime > 0\
			and otherAvoidCollision.pSpeedMultiplier > 0
				waitBehindAvoidedByActor(behavior)
// 				BaseGameApp.getApp().getConsole().addMessage("moveAroundAvoidedByActor "\
// 					+ getElement().getPosition() + ": return bothAvoid=("\
// 					+ otherAvoidCollision.pDeviationTime + "," + otherAvoidCollision.pSpeedMultiplier + ")")
				return
			end
			
			
			// moving orientation
			var float movingOrientation = pActorMover.getLocomotion().getLocomotion().getMovingOrientation()
			
			// find border point pairs for testing. first point has smaller rotation angle in
			// world space than second point.
			var Pair borderPoints = getPointsBorder(\
				getShapeCorners(behavior, collider.getMatrix()), actorPosition)
			
			// test pairs. results in the distance to the tangent position and the absolute
			// deviation angle for passing by the left and right side
			var float avoidDistance = pRadius + behavior.getRadius()
			
			var DVector colliderLeft = borderPoints.getSecond() cast DVector
			var DVector leftVector = colliderLeft - actorPosition
			var float leftDist = leftVector.getLength()
			var float leftAngle = DEMath.atan2(-leftVector.getX(), leftVector.getZ())
			leftAngle += avoidDistance < leftDist - 0.001 if DEMath.asin(avoidDistance / leftDist) else 90
			leftAngle = DEMath.normalize(leftAngle - movingOrientation + 360, -180.0, 180.0)
// 			leftAngle = DEMath.clamp(leftAngle, 0.0, 80.0)
			
			var DVector colliderRight = borderPoints.getFirst() cast DVector
			var DVector rightVector = colliderRight - actorPosition
			var float rightDist = rightVector.getLength()
			var float rightAngle = DEMath.atan2(-rightVector.getX(), rightVector.getZ())
			rightAngle -= avoidDistance < rightDist if DEMath.asin(avoidDistance / rightDist) else 90
			rightAngle = DEMath.normalize(movingOrientation - rightAngle + 360, -180.0, 180.0)
// 			rightAngle = DEMath.clamp(rightAngle, 0.0, 80.0)
			
			// choose the side to evade to. use the side with the smaller absolute deviation angle.
			// use navigation space to rule out sides if impassable. then use left and right check
			// to disable evading into the respective direction if a collision is found and the
			// collision object is not the object to avoid
			var bool useLeftSide
			
			var Collider colliderAvoid = pCCTAvoidCollision.hitCollider(0)
			var float distanceAvoid = pCCTAvoidCollision.hitDistance(0)
			
			var bool canEvadeLeft = not pCCTCheckLeft.getHasCollision() \
				or Collider.equals(pCCTCheckLeft.hitCollider(0), colliderAvoid) \
				or pCCTCheckLeft.hitDistance(0) > distanceAvoid
			
			var bool canEvadeRight = not pCCTCheckRight.getHasCollision() \
				or Collider.equals(pCCTCheckRight.hitCollider(0), colliderAvoid) \
				or pCCTCheckRight.hitDistance(0) > distanceAvoid
			
			if not canEvadeLeft and not canEvadeRight
				// NOTE this check can result in problems if the actor ends up in specific locked
				//      positions where he would be able to get out of it by doing sharp deviating
				//      but the left/right check hits an obstacle right next to it. in such
				//      situations the actor should be bold and just try deviating. not sure how
				//      to solve this properly
				if crossAngle < 90
					waitBehindAvoidedByActor(behavior)
					
				else
					useLeftSide = DEMath.probability(0.5)
				end
				
			else
				select navSpaceEvadeSide(actorPosition, movingOrientation, \
				leftAngle, leftDist, rightAngle, rightDist)
				case -1 // no side possible
					if crossAngle < 90
						waitBehindAvoidedByActor(behavior)
						
					else
						useLeftSide = DEMath.probability(0.5)
					end
					
				case 0 // both possible
					if canEvadeLeft and canEvadeRight
						useLeftSide = leftAngle < rightAngle
						
					else
						useLeftSide = canEvadeLeft
					end
					
				case 1 // only left possible
					useLeftSide = canEvadeLeft
					
				case 2 // only right possible
					useLeftSide = not canEvadeRight
				end
			end
			
			// calculate the deviation parameters to use
			var float deviationAngle = useLeftSide if leftAngle else -rightAngle
			
			var float distance = useLeftSide if leftDist else rightDist
			if distance > avoidDistance
				distance = DEMath.sqrt(distance * distance - avoidDistance * avoidDistance)
				
			else
				distance = pRadius
			end
			
			// apply deviation
			pDeviationAngle = movingOrientation + deviationAngle
			pDeviationTime = DEMath.max(distance / pActorMover.getSpeed(), 1.0)
			
			if pBTSMs != null
				pBTSMs.runEvent(pECBehavior.getPrefix(), "avoid")
			end
		end
		
		/**
		 * \brief Calculate shape corner points transformed to world space 2D coordinates.
		 * 
		 * If shape has no size 1 point is returned. If shape has size 4 points are returned.
		 */
		protected func Array getShapeCorners(ECBehaviorAvoidedByActor.Instance behavior, DMatrix matrix)
			var DVector origin = DVector.new(behavior.getOrigin())
			var Vector2 size = behavior.getSize()
			var Array points = Array.new()
			
			if Vector2.new().equals(size)
				points.add(matrix * origin)
				
			else
				var float sx = size.getX()
				var float sy = size.getY()
				points.add(matrix * (origin + DVector.new(-sx, 0, sy)))
				points.add(matrix * (origin + DVector.new(sx, 0, sy)))
				points.add(matrix * (origin + DVector.new(sx, 0, -sy)))
				points.add(matrix * (origin + DVector.new(-sx, 0, -sy)))
			end
			
			return points
		end
		
		/**
		 * \brief Get point with smallest and largest angle relative to origin Y-axis.
		 * 
		 * \returns Pair with smallest point as first and largest point as second.
		 */
		protected func Pair getPointsBorder(Array points, DVector origin)
			var DVector smallestPoint, largestPoint, point, vector
			var float smallestAngle, largestAngle, angle
			var int i, count = points.getCount()
			
			for i = 0 to count
				point = points.getAt(i) cast DVector
				vector = point - origin
				angle = DEMath.atan2(-vector.getX(), vector.getZ())
				
				if smallestPoint == null or DEMath.normalize(angle - smallestAngle + 360.0, -180.0, 180.0) < 0
					smallestPoint = point
					smallestAngle = angle
				end
				
				if largestPoint == null or DEMath.normalize(angle - largestAngle + 360.0, -180.0, 180.0) > 0
					largestPoint = point
					largestAngle = angle
				end
			end
			
			return Pair.new(smallestPoint, largestPoint)
		end
		
		/**
		 * \brief Determine side to evade using navigation space.
		 * 
		 * Evaluates the left and right side using deviation angle and deviation distance. If both
		 * sides are possible compares the costs. The angles are positive in the respective direction.
		 * 
		 * \retval -1 No side is possible to evade to.
		 * \retval 0 Evade to both sides is equally recommended.
		 * \retval 1 Evade to the left side is recommended.
		 * \retval 2 Evade to the right side is recommended.
		 */
		protected func int navSpaceEvadeSide(DVector position, float orientation, \
		float leftAngle, float leftDistance, float rightAngle, float rightDistance)
			// get nearest points on navigation spaces
			var Navigator navigator = pActorMover.getNavigator().getNavigator()
			
			var NavigationInfo niLeft = navigator.nearestPoint(position + DMatrix.newRotationY(\
				orientation + leftAngle).getViewVector() * leftDistance, 0.1)
			var NavigationInfo niRight = navigator.nearestPoint(position + DMatrix.newRotationY(\
				orientation - rightAngle).getViewVector() * rightDistance, 0.1)
			
			if niLeft == null and niRight == null
				return -1
				
			elif niLeft == null
				return 2
				
			elif niRight == null
				return 1
			end
			
			// both sides are possible so compare the costs
			var float fixCostRight = navigator.getTypeFixCost(niRight.getCostType())
			var float fixCostLeft = navigator.getTypeFixCost(niLeft.getCostType())
			var float costPerMeterRight = navigator.getTypeCostPerMeter(niRight.getCostType())
			var float costPerMeterLeft = navigator.getTypeCostPerMeter(niLeft.getCostType())
			
			if fixCostRight < fixCostLeft
				return 2
				
			elif fixCostLeft < fixCostRight
				return 1
				
			elif costPerMeterRight < costPerMeterLeft
				return 2
				
			elif costPerMeterLeft < costPerMeterRight
				return 1
				
			else
				return 0
			end
		end
		
		/** \brief Get out of contact collision. */
		protected func void contactCollision()
			// if the actor is not moving enough do nothing
			var float moveSpeed = pActorMover.getSpeed()
			if moveSpeed < 0.01
				return // this should not happen
			end
			
			var Locomotion locomotion = pActorMover.getLocomotion().getLocomotion()
			var Vector linearVelocity = Matrix.newRotationY(locomotion.getMovingOrientation()).getViewVector() * moveSpeed
			
			// to get out of the collision a plane using the ground projected hit normal is used
			var Vector hitNormal = pCCTAvoidCollision.hitNormalWorld(0).compSelect(true, false, true)
			
			// if the actor is moving away from the hit plane do nothing
			var float dotMoving = linearVelocity * hitNormal
			if dotMoving >= 0
				return
			end
			
			// the corrective angle is the angle between the moving direction and hit normal.
			// we only need to figure out now in what direction to apply it. the correct calculation
			// is dot(cross(hitNormal, up), linearVelocity). since hitNormal though has been projected
			// to the ground this boils down to dot((hitNormal. furthermore we add a little extra
			// to the avoid angle to make sure, thus 90 - safetyGap.
			var float deviationAngle = DEMath.acos(dotMoving / (hitNormal.getLength() * moveSpeed)) - 80
			
			if (Vector.new(0, 1, 0) % hitNormal) * linearVelocity < 0
				deviationAngle = -deviationAngle
			end
			
			// apply avoiding parameters
			pDeviationAngle = locomotion.getOrientation() + deviationAngle
			pDeviationTime = pAvoidTimeContactCollision
			
			if pBTSMs != null
				pBTSMs.runEvent(pECBehavior.getPrefix(), "avoid")
			end
		end
		
		
		
		/**
		 * \brief Wait behind element.
		 * \warning For use by avoid element visitor only.
		 */
		func void waitBehindAvoidedByActor(ECBehaviorAvoidedByActor.Instance behavior)
			// calculate relative velocity along connection between ai and hit collider
			var Collider collider = bestColliderFor(behavior)
			var Vector connection = (collider.getPosition() - pActorMover.getLocomotion() \
				.getColliderAI().getCollider().getPosition()).toVector()
			var float connDistance = connection.getLength()
			connection = connection / connDistance
			
			var Vector linearVelocity = Matrix.newRotationY(pActorMover.getLocomotion() \
				.getLocomotion().getMovingOrientation()).getViewVector() * pActorMover.getSpeed()
			var float moveSpeed = connection * linearVelocity
			if moveSpeed < 0
// 				BaseGameApp.getApp().getConsole().addMessage("wbaba ms<0: " + Array.newWith(\
// 					getElement().getID(), moveSpeed))
				return // moving out of collision
			end
			
			var float colliderSpeed = DEMath.max(connection * collider.getLinearVelocity(), 0.0)
			if moveSpeed <= colliderSpeed
// 				BaseGameApp.getApp().getConsole().addMessage("wbaba ms<cs: " + Array.newWith(\
// 					getElement().getID(), moveSpeed, colliderSpeed))
				return // same speed or slower
			end
			
			var float angle = DEMath.acos(moveSpeed / pActorMover.getSpeed())
			if angle > 85
// 				BaseGameApp.getApp().getConsole().addMessage("wbaba a>85: " + Array.newWith(\
// 					getElement().getID(), moveSpeed, colliderSpeed, angle))
				return // actor is just shrugging along obtacle
			end
			
			// if behind obstacle and bumping into it back off for a short time
			if pCCTAvoidCollision.hitDistance(0) < 0.01
// 				BaseGameApp.getApp().getConsole().addMessage("wbaba bump: " + Array.newWith(\
// 					moveSpeed, colliderSpeed, angle, pCCTAvoidCollision.hitDistance(0)))
				var bool doBackOff = true
				
				// if the avoided obstacle has avoid collision behavior too check if it is
				// also trying to back off already. if this is the case go on like normal
				var ECBehaviorAvoidCollision.Instance otherAvoidCollision = \
					ECBehaviorAvoidCollision.getInstanceIn(behavior.getElement())
				if otherAvoidCollision != null and otherAvoidCollision.pDeviationTime > 0\
				and otherAvoidCollision.pSpeedMultiplier < 0
					doBackOff = false
				end
				
				if doBackOff
					pDeviationAngle = pActorMover.getLocomotion().getLocomotion()\
						.getMovingOrientation() + DEMath.random(-30.0, 30.0)
					pDeviationTime = DEMath.random(0.25, 0.5)
					pSpeedMultiplier = -0.5
					
					if pBTSMs != null
						pBTSMs.runEvent(pECBehavior.getPrefix(), "avoid")
					end
					return
				end
			end
			
			// actor is moving faster than obstacle. adjust speed relative to distance. if the
			// actor is farther away the adjustment is small. if the actor is closer to the
			// obstacle the adjustment is higher. a linear step function is fine enough for
			//  avoid getting in contact with the obstacle if possible
			var float moverSpeed = pActorMover.getSpeed()
			var float minDistance = behavior.getRadius() + pRadius + moverSpeed * 0.25
			var float maxDistance = minDistance + moverSpeed * 0.5
			
			pSpeedMultiplier = DEMath.linearStep(connDistance, \
				minDistance, maxDistance, colliderSpeed / moverSpeed, 1.0)
// 			BaseGameApp.getApp().getConsole().addMessage("wbaba avoid: " + Array.newWith(\
// 				getElement().getID(), moveSpeed, colliderSpeed, angle, \
// 				pCCTAvoidCollision.hitDistance(0)) + Array.newWith(moverSpeed, \
// 				minDistance, maxDistance, pSpeedMultiplier, behavior.getElement().getID()))
		end
		
		/**
		 * \brief Wait behind object contact collision.
		 * \warning For use by avoid element visitor only.
		 */
		func void waitBehindContactCollision()
			// the ai collider linear velocity is not of much help since it is reduced to 0 length due
			// to collision. also the actor locomotion linear velocity is not useful since it can be
			// also 0 if the speed multiplier drops to 0. to figure out if the collider is in front or
			// behind the actor the orientation is used. if not in front continue moving otherwise stop
			var float movingOrientation = pActorMover.getLocomotion().getLocomotion().getMovingOrientation()
			
			/*
			var ColliderVolume actorCollider = pActor.getColliderAI().getCollider()
			var DVector connection = collider.getPosition() - actorCollider.getPosition()
			var float connectionOrientation = DEMath.atan2(-connection.getX(), connection.getZ())
			var float deviation = DEMath.fabs(DEMath.normalize(\
				movingOrientation - connectionOrientation, -180.0, 180.0))
			if deviation > 84.0 // 90 - 6~10 degrees seems fine
				return
			end
			*/
			
			// apply avoiding parameters
			pDeviationAngle = movingOrientation + 180
			pDeviationTime = 0.25
			
			if pBTSMs != null
				pBTSMs.runEvent(pECBehavior.getPrefix(), "avoid")
			end
		end
		
		
		
		/**
		 * \brief Find best collider for avoided by actor behavior.
		 * 
		 * Uses ECBehaviorColliderAI if present otherwise ECBehaviorCollider.
		 */
		func Collider bestColliderFor(ECBehaviorAvoidedByActor.Instance behavior)
			var BehaviorElement element = behavior.getElement()
			
			var ECBehaviorColliderAI.Instance colliderAI = ECBehaviorColliderAI.getInstanceIn(element)
			if colliderAI != null
				return colliderAI.getCollider()
			end
			
			var ECBehaviorCollider.Instance collider = ECBehaviorCollider.getInstanceIn(element)
			if collider != null
				return collider.getCollider()
			end
			
			return null
		end
		
		
		
		/** \brief Apply avoiding to actor mover. */
		func void onModifyMoveTowards(DVector position, float elapsed)
			var Locomotion locomotion = pActorMover.getLocomotion().getLocomotion()
			locomotion.setAnalogMovingSpeed(locomotion.getAnalogMovingSpeed() * pSpeedMultiplier)
			
			if pDeviationTime <= 0
				return
			end
			
			var float orientation = pDeviationAngle
			if pRidable != null
				orientation += pRidable.getCollider().getCollider().getOrientation().getEulerAngles().getY()
			end
			
			var float turnAngle = DEMath.normalize(orientation - locomotion.getOrientation(), -180.0, 180.0)
			
			/*
			// by disabling this check actors can do potentially sharp turns to avoid obstacles.
			// it is better to have this behavior instead of actors getting stuck because the
			// limit prevents them from doing the required deviation
			
			if pActorMover.getEnableLimitTurnAngle()
				var float limit = pActorMover.getLimitTurnAngle()
				turnAngle = DEMath.clamp(turnAngle, -limit, limit)
			end
			*/
			
			locomotion.setLookHorizontalGoal(turnAngle)
			locomotion.setTurnHorizontal(turnAngle)
			locomotion.setAnalogMovingHorizontalGoal(turnAngle)
			
			// if conversation actor head look-at is running clear it since conversation
			// look-at overrides deviation handling potentially causing troubles. we can
			// accept this if the turn angle is not too large though
			if DEMath.fabs(turnAngle) > 20
				var ECBehaviorConversationActor.Instance convoActor = pActorMover.getConversationActor()
				if convoActor != null
					var ConversationLookAtPlayback hlap = convoActor.getConversationActor().getHeadLookAtPlayback()
					if hlap != null
						hlap.clearLookAtState()
					end
				end
			end
		end
		
		
		
		/** \brief Think about what to do for the next frame update. */
		func void think(float elapsed)
			update(elapsed)
		end
		
		
		
		/** \brief Element resolver used during loading or \em null if not set. */
		func ElementResolver getElementResolver()
			return pElementResolver
		end
		
		/** \brief Frame update started. */
		func void enterFrame()
			if pElementResolver != null
				pElementResolver.resolve(getElement().getGameWorld())
				pElementResolver = null
			end
		end
		
		/** \brief Remove element from game world. */
		func void removeFromGameWorld()
			clearAvoiding()
		end
		
		/** \brief Read behavior from file. */
		func void readFromFile(PersistencyEnvironment env, FileReader reader)
			select reader.readByte() // version
			case 0
				var PersistencyFlags flags = PersistencyFlags.new(3, reader)
				pWaitBehindObstacles = flags.getAt(0)
				pEnabled = flags.getAt(1)
				
				pSpeedMultiplier = reader.readFloat()
				pDeviationAngle = reader.readFloat()
				pDeviationTime = reader.readFloat()
				
				if flags.getAt(2)
					pElementResolver = ElementResolver.new()
					pElementResolver.addBehaviorAllowFail(reader, block ECBehaviorRidable.Instance behavior
						pRidable = behavior
					end)
					setRequiresEnterFrame(true)
				end
				
			else
				throw EInvalidParam.new("unsupported version")
			end
			
			setRequiresThink(pEnabled)
		end
		
		/**
		 * \brief Write behavior to file.
		 * 
		 * If relative collider is present the goal position is transformed to world spaces before
		 * being written. The relative collider is not saved. During loading the  base actor is
		 * responsible to restore the relative collider. This has to be done any.
		 */
		func void writeToFile(PersistencyEnvironment env, FileWriter writer)
			writer.writeByte(0) // version
			
			var PersistencyFlags flags = PersistencyFlags.new(3)
			flags.setAt(0, pWaitBehindObstacles)
			flags.setAt(1, pEnabled)
			flags.setAt(2, pRidable != null)
			flags.writeToFile(writer)
			
			writer.writeFloat(pSpeedMultiplier)
			writer.writeFloat(pDeviationAngle)
			writer.writeFloat(pDeviationTime)
			
			if pRidable != null
				ElementResolver.writeToFileBehavior(writer, pRidable)
			end
		end
	end
	
	
	
	var ECComposeCollisionFilter pCollisionFilter
	var ECBehaviorActorMover pActorMover
	var ECBehaviorRideOn pRideOn
	var ECPFloat pRadius
	var ECComposeBTSM pBTSMs
	var String pPrefix
	
	
	
	/**
	 * \brief Create behavior element class.
	 * 
	 * These values are optional and can be null: \em rideOn.
	 */
	func new(BehaviorElementClass eclass, ECBehaviorActorMover actorMover, \
	ECBehaviorRideOn rideOn) this(eclass, actorMover, rideOn, "avoidCollision.")
	end
	
	func new(BehaviorElementClass eclass, ECBehaviorActorMover actorMover, \
	ECBehaviorRideOn rideOn, String prefix) super(eclass)
		if actorMover == null
			throw ENullPointer.new("actorMover")
		end
		if getBehaviorIn(eclass) != null
			throw BEMultipleInstanceException.new(eclass, this)
		end
		
		pPrefix = prefix
		pActorMover = actorMover
		pRideOn = rideOn
		pBTSMs = ECComposeBTSM.new()
		
		var LayerMask cfCategory = LayerMask.newWith(BaseGameApp.CollisionFilterBit.actorAI)
		
		var LayerMask cfFilter = LayerMask.new()
		cfFilter.setBit(BaseGameApp.CollisionFilterBit.geometry)
		cfFilter.setBit(BaseGameApp.CollisionFilterBit.dynamic)
		cfFilter.setBit(BaseGameApp.CollisionFilterBit.actorAI)
		
		pCollisionFilter = ECComposeCollisionFilter.new(CollisionFilter.new(cfCategory, cfFilter))
		
		pRadius = ECPFloat.new(prefix + "radius", 0.4, 0)
		eclass.addProperty(pRadius)
		
		eclass.addBehavior(this)
	end
	
	/** \brief Dispose of behavior. */
	func void dispose()
		pActorMover = null
		pRideOn = null
		pBTSMs = null
		super.dispose()
	end
	
	
	
	/**
	 * \brief Prefix.
	 * \version 1.26
	 */
	func String getPrefix()
		return pPrefix
	end
	
	/** \brief Actor mover behavior. */
	func ECBehaviorActorMover getActorMover()
		return pActorMover
	end
	
	/** \brief RideOn behavior or null. */
	func ECBehaviorRideOn getRideOn()
		return pRideOn
	end
	
	/** \brief Collision filter. */
	func ECComposeCollisionFilter getCollisionFilter()
		return pCollisionFilter
	end
	
	/** \brief Avoid radius. */
	func ECPFloat getRadius()
		return pRadius
	end
	
	/**
	 * \brief Compose behavior trees and state machines.
	 * \version 1.26
	 */
	func ECComposeBTSM getBTSMs()
		return pBTSMs
	end
	
	/** \deprecated Use getBTSMs() \ref ECComposeBTSM#addBehaviorTree(). */
	func void setBehaviorTree(ECBehaviorBehaviorTree behaviorTree)
		pBTSMs.addBehaviorTree(behaviorTree)
	end
	
	
	
	/** \brief Get instance in element from owner element class. */
	func Instance instance(BehaviorElement element)
		return element.getInstanceAt(getInstanceIndex()) cast Instance
	end
	
	
	
	/**
	 * \brief Get behavior in element class or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElementClass contains a behavior
	 * of type ECBehaviorAvoidCollision.
	 */
	static func ECBehaviorAvoidCollision getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBehaviorAvoidCollision each
			return true
		end) cast ECBehaviorAvoidCollision
	end
	
	/**
	 * \brief Get instance in element or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElement contains a behavior instance
	 * of type ECBehaviorAvoidCollision.Instance .
	 */
	static func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	
	
	/** \brief Create Behavior instance. */
	func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
