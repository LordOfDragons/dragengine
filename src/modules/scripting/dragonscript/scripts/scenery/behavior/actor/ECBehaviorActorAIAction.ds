/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Scenery

pin Dragengine.ConversationSystem
pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Utils
pin Dragengine.BehaviorTreeSystem
pin Dragengine.StateMachineSystem


/**
 * \brief Behavior adding AI and Action support to actors.
 * 
 * Allows instance of BaseActorAction and BaseActorAI to be assigned to actor. During thinking
 * first the AI then the Action is called.
 * 
 * Actions allow actors to perform a specific, well defined and enclosed action like interacting
 * with an object. Actions are suitable to be used by player and computer controlled actors
 * alike. This concept allows using the same actions for both player and computer controlled
 * actors reducing coding effort, misbehavior and overall ensures that what a player can do
 * a computer controlled actor can do and vice versa.
 * 
 * AIs allow computer controlled actors to act on their own. With player controlled actors the
 * AI is skipped and the player is the AI. AI provides long running actor actions like guarding
 * a zone with the possiblity to switch between different actions depending on how the actor
 * wants to react to events. This separation makes it simple to design AI in coarse grain
 * placing actual small grained actions into reusable action instances. This separation also
 * allows actors to easily switch between player and computer controlled because both can reuse
 * the same action instances.
 * 
 * Supports these optional behaviors:
 * - ECBehaviorConversationActor: Adds conversation commands to control behavior.
 * 
 * If conversation actor is used see ECBehaviorActorAIAction.ConvoCondition and
 * ECBehaviorActorAIAction.ConvoCommand for supported syntax.
 * 
 * \see https://developer.dragondreams.ch/wiki/doku.php/dragengine:modules:dragonscript:behavior_actoraiaction
 */
class ECBehaviorActorAIAction extends DefaultECBehavior
	/** \brief Factory for creating action. */
	interface ActionFactory
		/** \brief Create action for behavior instance. */
		func BaseActorAction createAction(Instance instance)
	end
	
	/** \brief Factory for creating AI. */
	interface AIFactory
		/** \brief Create AI for behavior instance. */
		func BaseActorAI createAI(Instance instance)
	end
	
	/**
	 * \brief Behavior factory.
	 * \version 1.25
	 * 
	 * Automatically assigns these behaviors if present before adding:
	 * - Optional: \ref ECBehaviorColliderAI
	 * - Optional: \ref ECBehaviorConversationActor
	 * - Optional: \ref ECBehaviorPlayerControllable
	 * 
	 * Example XML element class:
	 * \code{.xml}
	 * <behavior type='ECBehaviorActorAIAction'>
	 *   <!-- optional: use behavior tree with id instead of empty string -->
	 *   <string name='behaviorTree'>second</string>
	 *   
	 *   <!-- optional: use state machine with id instead of empty string -->
	 *   <string name='stateMachine'>second</string>
	 * </behavior>
	 * \endcode
	 * 
	 * Element class properties added by the behavior can also be set directly inside the tag
	 * be removing the property name prefix and starting with a "." (for example ".propertyName").
	 */
	class Factory implements BehaviorFactory
		func new()
		end
		
		func String factoryId()
			return "ECBehaviorActorAIAction"
		end
		
		func ECBehavior addBehavior(BehaviorElementClass eclass, String id, Dictionary parameters)
			if not id.empty()
				throw EInvalidParam.new("id is not empty string")
			end
			var ECBehaviorActorAIAction behavior = ECBehaviorActorAIAction.new(eclass,\
				ECBehaviorColliderAI.getBehaviorIn(eclass),\
				ECBehaviorConversationActor.getBehaviorIn(eclass),\
				ECBehaviorPlayerControllable.getBehaviorIn(eclass))
			
			behavior.setBehaviorTree(eclass.sharedFactoryHelper.defaultBehaviorTree(eclass, parameters))
			behavior.setStateMachine(eclass.sharedFactoryHelper.defaultStateMachine(eclass, parameters))
			
			eclass.sharedFactoryHelper.setPropertiesFromParameters(eclass, parameters, "aiAction")
			return behavior
		end
	end
	
	/** \brief Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		/**
		 * \brief Behavior tree action "aiAction.set".
		 * \version 1.26
		 */
		private class BTASet implements BTAction, SMAction
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func BTResult runAction(BTContext context, Dictionary parameters)
				var Object value
				
				value = parameters.getAt("ai.behaviorTree", null)
				if value != null
					var String basePath = context.getBehaviorTree().getFilename()
					if basePath != null
						value = File.absolutePath(value cast String,\
							File.new(basePath).getParent().getPath()).getPath()
					end
					pInstance.setAI(BAAIBehaviorTree.new(pInstance.getECBehavior().\
						getLoadBehaviorTree().loadFromFile(value cast String)))
				end
				
				value = parameters.getAt("action.stateMachine", null)
				if value != null
					var String basePath = context.getBehaviorTree().getFilename()
					if basePath != null
						value = File.absolutePath(value cast String,\
							File.new(basePath).getParent().getPath()).getPath()
					end
					pInstance.setAction(BAAStateMachine.new(pInstance.getECBehavior().\
						getLoadStateMachine().loadFromFile(value cast String)))
				end
				
				return BTResult.success
			end
			
			func void runAction(SMContext context, Dictionary parameters)
				var Object value
				
				value = parameters.getAt("ai.behaviorTree", null)
				if value != null
					var String basePath = context.getStateMachine().getFilename()
					if basePath != null
						value = File.absolutePath(value cast String,\
							File.new(basePath).getParent().getPath()).getPath()
					end
					pInstance.setAI(BAAIBehaviorTree.new(pInstance.getECBehavior().\
						getLoadBehaviorTree().loadFromFile(value cast String)))
				end
				
				value = parameters.getAt("action.stateMachine", null)
				if value != null
					var String basePath = context.getStateMachine().getFilename()
					if basePath != null
						value = File.absolutePath(value cast String,\
							File.new(basePath).getParent().getPath()).getPath()
					end
					pInstance.setAction(BAAStateMachine.new(pInstance.getECBehavior().\
						getLoadStateMachine().loadFromFile(value cast String)))
				end
			end
		end
		
		/** \brief Collider AI listener forwarding to Action/AI. */
		private class ColliderAIListener extends ECBehaviorColliderAI.DefaultListener
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func void collisionResponse(ECBehaviorColliderAI.Instance instance, \
			Collider collider, CollisionInfo info)
				if pInstance.getAction() != null
					pInstance.getAction().collisionResponse(collider, info)
				end
				if pInstance.getAI() != null
					pInstance.getAI().collision(collider, info)
				end
			end
			
			func bool canHitCollider(ECBehaviorColliderAI.Instance instance, \
			Collider collider, Collider hitCollider)
				return pInstance.getAction() != null \
					and pInstance.getAction().canHitCollider(collider, hitCollider)
			end
			
			func void colliderChanged(ECBehaviorColliderAI.Instance instance, Collider collider)
				if pInstance.getAction() != null
					pInstance.getAction().colliderChanged(collider)
				end
			end
		end
		
		/** \brief Conversation actor listener forwarding to Action/AI. */
		private class ConvoActorListener extends ECBehaviorConversationActor.DefaultListener
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func bool wait(ECBehaviorConversationActor.Instance instance)
				if pInstance.getAction() != null
					return pInstance.getAction().conversationWait()
					
				else
					return false
				end
			end
			
			func void enterConversation(ECBehaviorConversationActor.Instance instance)
				if pInstance.getAI() != null
					pInstance.getAI().enterConversation()
				end
			end
			
			func void leaveConversation(ECBehaviorConversationActor.Instance instance)
				if pInstance.getAI() != null
					pInstance.getAI().leaveConversation()
				end
			end
		end
		
		/** \brief Forward player takes controll to Action/AI. */
		private class PlayerTakeControlListener extends ECBehaviorPlayerControllable.DefaultListener
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func void playerTakesControl(ECBehaviorPlayerControllable.Instance instance)
				if pInstance.getAction() != null
					pInstance.getAction().playerTakesControl()
				end
				if pInstance.getAI() != null
					pInstance.getAI().playerTakesControl()
				end
			end
			
			func void playerReleasesControl(ECBehaviorPlayerControllable.Instance instance)
				if pInstance.getAction() != null
					pInstance.getAction().playerReleasesControl()
				end
				if pInstance.getAI() != null
					pInstance.getAI().playerReleasesControl()
				end
			end
		end
		
		
		
		var ECBehaviorActorAIAction pECBehavior
		var ECBehaviorColliderAI.Instance pColliderAI
		var ECBehaviorConversationActor.Instance pConversationActor
		var ECBehaviorPlayerControllable.Instance pPlayerControllable
		
		var BaseActorAction pAction
		var BaseActorAI pAI
		var SMContext pSMContext
		
		
		/** \brief Create behavior instance. */
		func new(ECBehaviorActorAIAction ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			
			setRequiresEnterFrame(true)
			setRequiresThink(true)
		end
		
		/** \brief Dispose of behavior instance. */
		func void dispose()
			setAIAndDispose(null)
			setActionAndDispose(null)
			
			pConversationActor = null
			pPlayerControllable = null
			pColliderAI = null
			pSMContext = null
			super.dispose()
		end
		
		
		
		/** \brief Initialize behavior from stub. */
		func void init(StubElement stub)
			var BehaviorElement element = getElement()
			
			if pECBehavior.getColliderAI() != null
				pColliderAI = pECBehavior.getColliderAI().instance(element)
			end
			if pECBehavior.getConversationActor() != null
				pConversationActor = pECBehavior.getConversationActor().instance(element)
			end
			if pECBehavior.getPlayerControllable() != null
				pPlayerControllable = pECBehavior.getPlayerControllable().instance(element)
			end
			
			if pColliderAI != null
				pColliderAI.addListener(ColliderAIListener.new(this))
			end
			if pConversationActor != null
				pConversationActor.addListener(ConvoActorListener.new(this))
			end
			if pPlayerControllable != null
				pPlayerControllable.addListener(PlayerTakeControlListener.new(this))
			end
			
			if pECBehavior.getBehaviorTree() != null
				var String prefix = pECBehavior.getPrefix()
				var BTContext c = pECBehavior.getBehaviorTree().instance(element).getContext()
				c.setAction(prefix + "set", BTASet.new(this))
			end
			
			if pECBehavior.getStateMachine() != null
				var String prefix = pECBehavior.getPrefix()
				pSMContext = pECBehavior.getStateMachine().instance(element).getContext()
				pSMContext.setAction(prefix + "set", BTASet.new(this))
			end
			
			setAction(pECBehavior.getActionFactory().createAction(this))
			setAI(pECBehavior.getAIFactory().createAI(this))
		end
		
		
		
		/** \brief Behavior. */
		func ECBehaviorActorAIAction getECBehavior()
			return pECBehavior
		end
		
		/** \brief Conversation actor if present. */
		func ECBehaviorConversationActor.Instance getConversationActor()
			return pConversationActor
		end
		
		/** \brief Player controllable actor if present. */
		func ECBehaviorPlayerControllable.Instance getPlayerControllable()
			return pPlayerControllable
		end
		
		
		
		/** \brief Active action or \em null. */
		func BaseActorAction getAction()
			return pAction
		end
		
		/**
		 * \brief Set active action or \em null.
		 * 
		 * Does not call dispose() on old action if present.
		 */
		func void setAction(BaseActorAction action)
			if action == pAction
				return
			end
			
			if pAction != null
				pAction.deactivate()
			end
			
			pAction = action
			
			if action != null
				action.activate(getElement())
			end
		end
		
		/**
		 * \brief Set active action or \em null.
		 * 
		 * Calls dispose() on old action if present.
		 */
		func void setActionAndDispose(BaseActorAction action)
			var BaseActorAction disposeAction = pAction
			
			setAction(action)
			
			if disposeAction != null
				disposeAction.dispose()
			end
		end
		
		
		
		/** \brief Active AI or \em null. */
		func BaseActorAI getAI()
			return pAI
		end
		
		/**
		 * \brief Set active AI or \em null.
		 * 
		 * Does not call dispose() on old AI if present.
		 */
		func void setAI(BaseActorAI ai)
			if ai == pAI
				return
			end
			
			if pAI != null
				pAI.deactivate()
			end
			
			pAI = ai
			
			if ai != null
				ai.activate(getElement())
			end
		end
		
		/**
		 * \brief Set active AI or \em null.
		 * 
		 * Calls dispose() on old AI if present.
		 */
		func void setAIAndDispose(BaseActorAI ai)
			var BaseActorAI disposeAI = pAI
			
			setAI(ai)
			
			if disposeAI != null
				disposeAI.dispose()
			end
		end
		
		
		
		/** \brief Frame update started. */
		func void enterFrame()
			if pAI != null
				pAI.enterFrame()
			end
			if pAction != null
				pAction.enterFrame()
			end
		end
		
		/**
		 * \brief Think about what to do for the next frame update.
		 * 
		 * If actor is player controlled calls BaseActorAction.playerThink() and
		 * BaseActorAction.think(). If actor is not player controlled calls
		 * BaseActorAI.think() and BaseActorAction.think(). This avoids the need for
		 * AI and Action to check if they are player controlled or not.
		 */
		func void think(float elapsed)
			if pPlayerControllable.isPlayerControlled()
				if pAction != null
					pAction.playerThink(elapsed)
					pAction.think(elapsed)
				end
				
			else
				if pAI != null
					pAI.think(elapsed)
				end
				if pAction != null
					pAction.think(elapsed)
				end
			end
		end
		
		/**
		 * \brief Post thinking after physics processing is finished.
		 * 
		 * If actor is player controlled calls BaseActorAction.playerPostThink(float)
		 * and BaseActorAction.postThink(float). If actor is not player controlled only
		 * BaseActorAction.postThink(float) is called.
		 */
		func void postThink(float elapsed)
			if pAction != null
				if pPlayerControllable.isPlayerControlled()
					pAction.playerPostThink(elapsed)
				end
				pAction.postThink(elapsed)
			end
		end
		
		/** \brief Add element to game world. */
		func void addToGameWorld()
			if pAI != null
				pAI.enteredGameWorld()
			end
			if pAction != null
				pAction.enteredGameWorld()
			end
		end
		
		/** \brief Remove element from game world. */
		func void removeFromGameWorld()
			if pAI != null
				pAI.leftGameWorld()
			end
			if pAction != null
				pAction.leftGameWorld()
			end
		end
		
		
		
		/** \brief Read behavior from file. */
		func void readFromFile(PersistencyEnvironment env, FileReader reader)
			select reader.readByte() // version
			case 0
				var BehaviorElement element = getElement()
				
				pAI = env.readObjectOrNull(reader) cast BaseActorAI
				if pAI != null
					pAI.activateWhileLoading(element)
				end
				
				pAction = env.readObjectOrNull(reader) cast BaseActorAction
				if pAction != null
					pAction.activateWhileLoading(element)
				end
				
			else
				throw EInvalidParam.new("unsupported version")
			end
		end
		
		/** \brief Write behavior to file. */
		func void writeToFile(PersistencyEnvironment env, FileWriter writer)
			writer.writeByte(0) // version
			
			env.writeObjectOrNull(writer, pAI)
			env.writeObjectOrNull(writer, pAction)
		end
	end
	
	
	
	var ECBehaviorColliderAI pColliderAI
	var ECBehaviorConversationActor pConversationActor
	var ECBehaviorPlayerControllable pPlayerControllable
	var ECBehaviorBehaviorTree pBehaviorTree
	var ECBehaviorStateMachine pStateMachine
	var ActionFactory pActionFactory
	var AIFactory pAIFactory
	var String pPrefix
	var LoadBehaviorTree pLoadBehaviorTree
	var LoadStateMachine pLoadStateMachine
	
	
	
	/**
	 * \brief Create behavior element class.
	 * 
	 * These values are optional and can be null: \em colliderAI, \em conversationActor,
	 * \em playerControllable.
	 * 
	 * The default Action and AI factory are BAAFirstPerson and BAAIBehaviorTree.
	 */
	func new(BehaviorElementClass eclass, ECBehaviorColliderAI colliderAI, \
	ECBehaviorConversationActor conversationActor, ECBehaviorPlayerControllable playerControllable) \
	this(eclass, colliderAI, conversationActor, playerControllable, "aiAction.")
	end
	
	func new(BehaviorElementClass eclass, ECBehaviorColliderAI colliderAI, \
	ECBehaviorConversationActor conversationActor, ECBehaviorPlayerControllable playerControllable, \
	String prefix) this(eclass, colliderAI, conversationActor, playerControllable,\
	BaseGameApp.getApp().getLoaders(), prefix)
	end
	
	func new(BehaviorElementClass eclass, ECBehaviorColliderAI colliderAI, \
	ECBehaviorConversationActor conversationActor, ECBehaviorPlayerControllable playerControllable, \
	Loaders loaders, String prefix) super(eclass)
		pPrefix = prefix
		pColliderAI = colliderAI
		pConversationActor = conversationActor
		pPlayerControllable = playerControllable
		pActionFactory = BAAFirstPerson.Factory.new()
		pAIFactory = BAAIBehaviorTree.Factory.new()
		pLoadBehaviorTree = loaders.getBehaviorTree()
		pLoadStateMachine = loaders.getStateMachine()
		
		eclass.addBehavior(this)
	end
	
	/** \brief Dispose of behavior. */
	func void dispose()
		pColliderAI = null
		pConversationActor = null
		pPlayerControllable = null
		pActionFactory = null
		pAIFactory = null
		pBehaviorTree = null
		pStateMachine = null
		super.dispose()
	end
	
	
	
	/**
	 * \brief Prefix.
	 * \version 1.26
	 */
	func String getPrefix()
		return pPrefix
	end
	
	/** \brief Collider AI behavior or null. */
	func ECBehaviorColliderAI getColliderAI()
		return pColliderAI
	end
	
	/** \brief Set collider AI behavior or null. */
	func void setColliderAI(ECBehaviorColliderAI colliderAI)
		pColliderAI = colliderAI
	end
	
	/** \brief Conversation actor behavior or null. */
	func ECBehaviorConversationActor getConversationActor()
		return pConversationActor
	end
	
	/**
	 * \brief Set conversation actor behavior or null.
	 * 
	 * If set conversation conditions and commands are added.
	 */
	func void setConversationActor(ECBehaviorConversationActor conversationActor)
		pConversationActor = conversationActor
	end
	
	/** \brief Player controllable behavior or null. */
	func ECBehaviorPlayerControllable getPlayerControllable()
		return pPlayerControllable
	end
	
	/** \brief Set player controllable behavior or null. */
	func void setPlayerControllable(ECBehaviorPlayerControllable playerControllable)
		pPlayerControllable = playerControllable
	end
	
	/** \brief Action factory. */
	func ActionFactory getActionFactory()
		return pActionFactory
	end
	
	/** \brief Set action factory. */
	func void setActionFactory(ActionFactory factory)
		if factory == null
			throw ENullPointer.new()
		end
		pActionFactory = factory
	end
	
	/** \brief AI factory. */
	func AIFactory getAIFactory()
		return pAIFactory
	end
	
	/** \brief Set AI factory. */
	func void setAIFactory(AIFactory factory)
		if factory == null
			throw ENullPointer.new()
		end
		pAIFactory = factory
	end
	
	/**
	 * \brief Behavior tree or null.
	 * \version 1.26
	 */
	func ECBehaviorBehaviorTree getBehaviorTree()
		return pBehaviorTree
	end
	
	/**
	 * \brief Set behavior tree or null.
	 * \version 1.26
	 */
	func void setBehaviorTree(ECBehaviorBehaviorTree behaviorTree)
		pBehaviorTree = behaviorTree
	end
	
	/**
	 * \brief State machine or null.
	 * \version 1.26
	 */
	func ECBehaviorStateMachine getStateMachine()
		return pStateMachine
	end
	
	/**
	 * \brief Set state machine or null.
	 * \version 1.26
	 */
	func void setStateMachine(ECBehaviorStateMachine stateMachine)
		pStateMachine = stateMachine
	end
	
	/**
	 * \brief Behavior tree loader.
	 * \version 1.26
	 */
	func LoadBehaviorTree getLoadBehaviorTree()
		return pLoadBehaviorTree
	end
	
	/**
	 * \brief Set behavior tree loader.
	 * \version 1.26
	 */
	func void setLoadBehaviorTree(LoadBehaviorTree loader)
		if loader == null
			throw ENullPointer.new("loader")
		end
		pLoadBehaviorTree = loader
	end
	
	/**
	 * \brief State machine loader.
	 * \version 1.26
	 */
	func LoadStateMachine getLoadStateMachine()
		return pLoadStateMachine
	end
	
	/**
	 * \brief Set state machine loader.
	 * \version 1.26
	 */
	func void setLoadStateMachine(LoadStateMachine loader)
		if loader == null
			throw ENullPointer.new("loader")
		end
		pLoadStateMachine = loader
	end
	
	
	
	/** \brief Get instance in element from owner element class. */
	func Instance instance(BehaviorElement element)
		return element.getInstanceAt(getInstanceIndex()) cast Instance
	end
	
	
	
	/**
	 * \brief Get behavior in element class or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElementClass contains a behavior
	 * of type ECBehaviorActorAIAction.
	 */
	static func ECBehaviorActorAIAction getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBehaviorActorAIAction each
			return true
		end) cast ECBehaviorActorAIAction
	end
	
	/**
	 * \brief Get instance in element or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElement contains a behavior instance
	 * of type ECBehaviorActorAIAction.Instance .
	 */
	static func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	
	
	/** \brief Create Behavior instance. */
	func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
