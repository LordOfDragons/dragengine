/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Scenery

pin Dragengine.ConversationSystem
pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Utils


/**
 * \brief Behavior adding mover support to actors.
 * 
 * Uses ECBehaviorNavigator to find a path. Uses ECBehaviorLocomotion to provide input to
 * the actor for the direction to move to. Listener tell the actor and other behavior
 * about the state of moving towards the goal.
 * 
 * Requires these behaviors the be present:
 * - ECBehaviorLocomotion
 * - ECBehaviorNavigator
 * 
 * Supports these optional behaviors:
 * - ECBehaviorRideOn: Allows mover goal relative to ridable supported elements.
 * - ECBehaviorConversationActor: Adds conversation commands to control behavior.
 * 
 * Add a listener to be notified if the actor arrives at the target. For BaseActor the class
 * BaseActorListener can be used calling BaseActorAI.arrivedAtGoal().
 * 
 * If conversation actor is used see ECBehaviorActorMover.ConvoCondition and
 * ECBehaviorActorMover.ConvoCommand for supported syntax.
 * 
 * \see https://developer.dragondreams.ch/wiki/doku.php/dragengine:modules:dragonscript:behavior_actormover
 */
class ECBehaviorActorMover extends DefaultECBehavior
	/** \brief Listener for behavior instance events. */
	interface Listener
		/**
		 * \brief Actor starts moving towards goal.
		 * 
		 * \note
		 * \ref Instance#getPath() can be null if no path could be found or the actor is already
		 * at the goal. In this case \ref #arrivedAtGoal() and \ref #stopMoving() is called too.
		 */
		func void startMoving(Instance instance)
		
		/** \brief Actor stops moving. */
		func void stopMoving(Instance instance)
		
		/**
		 * \brief Actor arrived at goal position.
		 * \note \ref #stopMoving() will be called before \ref #arrivedAtGoal() is called.
		 */
		func void arrivedAtGoal(Instance instance, DVector goalPosition)
		
		/** \brief Modify locomotion values set by moveTowards(). */
		func void modifyMoveTowards(Instance instance, DVector position, float elapsed)
	end
	
	/** \brief Default implementation of behavior instance listener. */
	class DefaultListener implements Listener
		/** \brief Create default listener. */
		func new()
		end
		
		func void startMoving(Instance instance)
		end
		
		func void stopMoving(Instance instance)
		end
		
		func void arrivedAtGoal(Instance instance, DVector goalPosition)
		end
		
		func void modifyMoveTowards(Instance instance, DVector position, float elapsed)
		end
	end
	
	/** \brief Factory creating listeners. */
	interface ListenerFactory
		/** \brief Create listener. */
		func Listener createListener(Instance instance)
	end
	
	/** \brief Factory creating listeners using block. */
	class BlockListenerFactory implements ListenerFactory
		var Block pBlock
		
		/** \brief Create factory using block receiving Instance as parameter returning Listener. */
		func new(Block blockFactory)
			if blockFactory == null
				throw ENullPointer.new()
			end
			pBlock = blockFactory
		end
		
		/** \brief Create listener. */
		func Listener createListener(Instance instance)
			return pBlock.run(instance) cast Listener
		end
	end
	
	/**
	 * \brief Conversation condition.
	 * 
	 * Syntax:
	 * actorMover hasGoal|hasNoGoal|paused
	 *   Calls hasGoal(), hasNoGoal(), getPause(). Typically used to check if the actor is
	 *   moving to a goal or not.
	 * 
	 * actorMover closerThan goal|direct [distance]
	 *   Checks if the distance to the goal is less than or equal to "distance". If no goal is
	 *   set true is returned. If "goal" is specified uses remaining goal distance. If "direct"
	 *   is specified uses distance between actor and goal position. The remaining goal distance
	 *   is not necessarily the same as the direct line distance between the actor and the goal.
	 */
	class ConvoCondition implements ECBehaviorConversationActor.ConversationCondition
		var Instance pInstance
		
		func new(Instance instance)
			pInstance = instance
		end
		
		func bool evaluateCondition(ECBehaviorConversationActor.Instance instance, Array arguments)
			var String action = arguments.getAt(1) cast String
			
			if action.equals("hasGoal")
				return evaluateHasGoal(instance, arguments)
				
			elif action.equals("hasNoGoal")
				return evaluateHasNoGoal(instance, arguments)
				
			elif action.equals("paused")
				return evaluatePaused(instance, arguments)
				
			elif action.equals("closerThan")
				return evaluateCloserThan(instance, arguments)
				
			else
				throw EInvalidParam.new("Unknown action '" + action + "'")
			end
		end
		
		protected func bool evaluateHasGoal(ECBehaviorConversationActor.Instance instance, Array arguments)
			return pInstance.hasGoal()
		end
		
		protected func bool evaluateHasNoGoal(ECBehaviorConversationActor.Instance instance, Array arguments)
			return pInstance.hasNoGoal()
		end
		
		protected func bool evaluatePaused(ECBehaviorConversationActor.Instance instance, Array arguments)
			return pInstance.getPause()
		end
		
		protected func bool evaluateCloserThan(ECBehaviorConversationActor.Instance instance, Array arguments)
			if pInstance.hasNoGoal()
				return true
			end
			
			var String action = arguments.getAt(2) cast String
			var float distance = (arguments.getAt(3) cast String).toFloat()
			
			if action.equals("goal")
				return pInstance.getDistanceToGoal() <= distance
				
			elif action.equals("direct")
				return (instance.getElement().getPosition() - pInstance.getGoalPosition()).getLength() <= distance
				
			else
				throw EInvalidParam.new("closerThan: Unknown keyword '" + action + "'")
			end
		end
	end
	
	/**
	 * \brief Conversation command.
	 * 
	 * Syntax:
	 * actorMover pause|continue|stop
	 *   Calls pauseMoving(), continueMoving() or stopMoving().
	 * 
	 * actorMover actor [id] [distance]
	 *   Start moving to position of conversation actor.
	 *   - id: Identifier or Alias of conversation actor. Throws exception conversation actor
	 *         has no playback or actor id/alias is unknown.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover coordsys [id] [distance]
	 *   Start moving to position of conversation coordinate system.
	 *   - id: Identifier of conversation coord system to use. Throws exception conversation
	 *         actor has no playback or identifier is unknown.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover spawn [name] [distance]
	 *   Start moving to position of spawn point.
	 *   - name: Name of spawn point to use. Throws exception element is not in a game world
	 *           or name is not found in the game world.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover anchor [id] [distance]
	 *   Start moving to position of anchor element.
	 *   - id: Identifier of anchor element to use. Throws exception element is not in a game
	 *         world or name is not found in the game world.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover position [x] [y] [z] [distance]
	 *   Start moving to position in game world.
	 *   - x,y,z: Coordinates of position to move to.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover relative [offsetX] [offsetY] [offsetZ] [distance]
	 *   - offset*: Position relative to Element.getElementMatrix().
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 */
	class ConvoCommand implements ECBehaviorConversationActor.ConversationCommand
		var Instance pInstance
		
		func new(Instance instance)
			pInstance = instance
		end
		
		func void runCommand(ECBehaviorConversationActor.Instance instance, Array arguments)
			var String action = arguments.getAt(1) cast String
			
			if action.equals("pause")
				runPause(instance, arguments)
				
			elif action.equals("continue")
				runContinue(instance, arguments)
				
			elif action.equals("stop")
				runStop(instance, arguments)
				
			elif action.equals("position")
				runPosition(instance, arguments)
				
			elif action.equals("relative")
				runRelative(instance, arguments)
				
			elif action.equals("actor")
				runActor(instance, arguments)
				
			elif action.equals("coordsys")
				runCoordSystem(instance, arguments)
				
			elif action.equals("spawn")
				runSpawn(instance, arguments)
				
			elif action.equals("anchor")
				runAnchor(instance, arguments)
				
			else
				throw EInvalidParam.new("Unknown action '" + action + "'")
			end
		end
		
		protected func void runPause(ECBehaviorConversationActor.Instance instance, Array arguments)
			pInstance.pauseMoving()
		end
		
		protected func void runContinue(ECBehaviorConversationActor.Instance instance, Array arguments)
			pInstance.continueMoving()
		end
		
		protected func void runStop(ECBehaviorConversationActor.Instance instance, Array arguments)
			pInstance.stopMoving()
		end
		
		protected func void runPosition(ECBehaviorConversationActor.Instance instance, Array arguments)
			// TODO we can not handle double precision values like this
			var float x = (arguments.getAt(2) cast String).toFloat()
			var float y = (arguments.getAt(3) cast String).toFloat()
			var float z = (arguments.getAt(4) cast String).toFloat()
			var float distance = (arguments.getAt(5) cast String).toFloat()
			pInstance.moveTo(DVector.new(x, y, z), distance)
		end
		
		protected func void runRelative(ECBehaviorConversationActor.Instance instance, Array arguments)
			var float x = (arguments.getAt(2) cast String).toFloat()
			var float y = (arguments.getAt(3) cast String).toFloat()
			var float z = (arguments.getAt(4) cast String).toFloat()
			var float distance = (arguments.getAt(5) cast String).toFloat()
			pInstance.moveTo(instance.getElement().getElementMatrix() * DVector.new(x, y, z), distance)
		end
		
		protected func void runActor(ECBehaviorConversationActor.Instance instance, Array arguments)
			var ConversationPlayback playback = instance.getConversationActor().getPlayback()
			if playback == null
				throw EInvalidParam.new("Playback is null")
			end
			
			var String id = arguments.getAt(2) cast String
			var ConversationActor actor = playback.getActorMatching(StringID.new(id))
			if actor == null
				throw EInvalidParam.new("No conversation actor found with id/alias '" + id + "'")
			end
			
			var float distance = (arguments.getAt(3) cast String).toFloat()
			pInstance.moveTo(actor.getMatrix().getPosition(), distance)
		end
		
		protected func void runCoordSystem(ECBehaviorConversationActor.Instance instance, Array arguments)
			var ConversationPlayback playback = instance.getConversationActor().getPlayback()
			if playback == null
				throw EInvalidParam.new("Playback is null")
			end
			
			var String id = arguments.getAt(2) cast String
			var ConversationCoordSystem coordSys = playback.createConversationCoordSystem(StringID.new(id))
			if coordSys == null
				throw EInvalidParam.new("No conversation system found with id '" + id + "'")
			end
			
			var float distance = (arguments.getAt(3) cast String).toFloat()
			pInstance.moveTo(coordSys.getMatrix().getPosition(), distance)
		end
		
		protected func void runSpawn(ECBehaviorConversationActor.Instance instance, Array arguments)
			var GameWorld gameWorld = instance.getElement().getGameWorld()
			if gameWorld == null
				throw EInvalidParam.new("Element game world is null")
			end
			
			var String name = arguments.getAt(2) cast String
			var SpawnPoint spawn = gameWorld.getSpawnPoints().getNamed(name)
			if spawn == null
				throw EInvalidParam.new("No spawn point found with name '" + name + "'")
			end
			
			var float distance = (arguments.getAt(3) cast String).toFloat()
			pInstance.moveTo(spawn.getPosition(), distance)
		end
		
		protected func void runAnchor(ECBehaviorConversationActor.Instance instance, Array arguments)
			var GameWorld gameWorld = instance.getElement().getGameWorld()
			if gameWorld == null
				throw EInvalidParam.new("Element game world is null")
			end
			
			var String id = arguments.getAt(2) cast String
			var Element anchor = gameWorld.getAnchoredElementList().getAt(StringID.new(id))
			if anchor == null
				throw EInvalidParam.new("No anchor found with identifier '" + id + "'")
			end
			
			var float distance = (arguments.getAt(3) cast String).toFloat()
			pInstance.moveTo(anchor.getPosition(), distance)
		end
	end
	
	/**
	 * \brief Behavior factory.
	 * \ref 1.25
	 * 
	 * Automatically assigns these behaviors if present before adding:
	 * - Required: \ref ECBehaviorLocomotion
	 * - Required: \ref ECBehaviorNavigator
	 * - Optional: \ref ECBehaviorRideOn
	 * - Optional: \ref ECBehaviorConversationActor
	 * 
	 * Example XML element class:
	 * \code{.xml}
	 * <behavior type='ECBehaviorActorMover'>
	 *   <!-- optional: use navigator with id instead of empty string -->
	 *   <string name='navigator'>second</string>
	 * </behavior>
	 * \endcode
	 * 
	 * Element class properties added by the behavior can also be set directly inside the tag
	 * be removing the property name prefix and starting with a "." (for exampler ".propertyName").
	 */
	class Factory implements BehaviorFactory
		func new()
		end
		
		func String factoryId()
			return "ECBehaviorActorMover"
		end
		
		func ECBehavior addBehavior(BehaviorElementClass eclass, String id, Dictionary parameters)
			if not id.empty()
				throw EInvalidParam.new("id is not empty string")
			end
			
			var ECBehaviorActorMover behavior = ECBehaviorActorMover.new(eclass,\
				ECBehaviorLocomotion.getBehaviorIn(eclass),\
				eclass.sharedFactoryHelper.defaultNavigator(eclass, parameters),\
				ECBehaviorRideOn.getBehaviorIn(eclass))
			
			behavior.setConversationActor(ECBehaviorConversationActor.getBehaviorIn(eclass))
			
			BehaviorElementClass.sharedFactoryHelper.setPropertiesFromParameters(\
				eclass, parameters, "actorMover")
			return behavior
		end
	end
	
	
	
	/** \brief Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		/** \brief Ridable changed. */
		protected class RidableChanged extends ECBehaviorRideOn.DefaultListener
			var Instance pInstance
			
			func new(Instance instance)
				pInstance = instance
			end
			
			func void ridableChanged(ECBehaviorRideOn.Instance instance)
				pInstance.onRidableChanged()
			end
		end
		
		
		var ECBehaviorActorMover pECBehavior
		
		var ECBehaviorLocomotion.Instance pLocomotion
		var ECBehaviorNavigator.Instance pNavigator
		var ECBehaviorRideOn.Instance pRideOn
		var ECBehaviorRidable.Instance pRidable
		var ECBehaviorCollider.Instance pRidableCollider
		var ECBehaviorConversationActor.Instance pConversationActor
		
		var DVector pGoalPosition
		var float pGoalDistance
		var NavigatorPath pPath
		var int pNextPathPoint
		var DVector pNextPlaneNormal
		var bool pPause
		
		var float pRemainingDistance
		
		var bool pEnableLimitTurnAngle
		var float pLimitTurnAngle
		
		var float pSpeed
		
		var ElementResolver pElementResolver
		var Array pListeners
		
		
		
		/** \brief Create behavior instance. */
		func new(ECBehaviorActorMover ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pGoalDistance = 0
			pNextPathPoint = 0
			pPause = false
			pEnableLimitTurnAngle = false
			pLimitTurnAngle = 89
			pListeners = Array.new()
			
			pLocomotion = ecbehavior.getLocomotion().instance(element)
			pNavigator = ecbehavior.getNavigator().instance(element)
		end
		
		/** \brief Dispose of behavior instance. */
		func void dispose()
			pConversationActor = null
			pRidable = null
			pRidableCollider = null
			pRideOn = null
			pNavigator = null
			pLocomotion = null
			pListeners = null
			pElementResolver = null
			
			super.dispose()
		end
		
		
		
		/** \brief Initialize behavior from stub. */
		func void init(StubElement stub)
			var BehaviorElement element = getElement()
			
			pSpeed = pECBehavior.getSpeed().getValue(stub)
			
			if pECBehavior.getRideOn() != null
				pRideOn = pECBehavior.getRideOn().instance(element)
			end
			if pECBehavior.getConversationActor() != null
				pConversationActor = pECBehavior.getConversationActor().instance(element)
			end
			
			if pRideOn != null
				pRideOn.addListener(RidableChanged.new(this))
			end
			if pConversationActor != null
				pConversationActor.addCondition("actorMover", ConvoCondition.new(this))
				pConversationActor.addCommand("actorMover", ConvoCommand.new(this))
			end
			
			pECBehavior.createListeners(this)
		end
		
		
		
		/** \brief Behavior. */
		func ECBehaviorActorMover getECBehavior()
			return pECBehavior
		end
		
		/** \brief Locomotion behavior. */
		func ECBehaviorLocomotion.Instance getLocomotion()
			return pLocomotion
		end
		
		/** \brief Navigator behavior. */
		func ECBehaviorNavigator.Instance getNavigator()
			return pNavigator
		end
		
		/** \brief Conversation actor if present. */
		func ECBehaviorConversationActor.Instance getConversationActor()
			return pConversationActor
		end
		
		/** \brief Ride on behavior if present. */
		func ECBehaviorRideOn.Instance getRideOn()
			return pRideOn
		end
		
		
		
		/** \brief Goal to move to or \em null if not set. */
		func DVector getGoalPosition()
			return pGoalPosition
		end
		
		/** \brief Set goal to move to. */
		func void setGoalPosition(DVector goal)
			if pRidableCollider != null
				goal = pRidableCollider.getCollider().getInverseMatrix() * goal
			end
			
			if goal.equals(pGoalPosition)
				return
			end
			
			pGoalPosition = goal
			pPath = null
			pNextPathPoint = 0
			pNextPlaneNormal = null
			updateRequiresThinking()
		end
		
		/** \brief Distance along path below which actor arrive at target is triggered. */
		func float getGoalDistance()
			return pGoalDistance
		end
		
		/** \brief Set distance along path below which actor arrive at target is triggered. */
		func void setGoalDistance(float distance)
			pGoalDistance = DEMath.max(distance, 0.0)
		end
		
		/** \brief Path or \em null if not calculated. */
		func NavigatorPath getPath()
			return pPath
		end
		
		
		
		/** \brief Enable limit turning angle. */
		func bool getEnableLimitTurnAngle()
			return pEnableLimitTurnAngle
		end
		
		/** \brief Set if limit turning angle is enabled. */
		func void setEnableLimitTurnAngle(bool enabled)
			pEnableLimitTurnAngle = enabled
		end
		
		/** \brief Turning angle limit in degrees if enabled. */
		func float getLimitTurnAngle()
			return pLimitTurnAngle
		end
		
		/** \brief Set turning angle limit in degrees if enabled. */
		func void setLimitTurnAngle(float angle)
			pLimitTurnAngle = DEMath.max(angle, 0.0)
		end
		
		/** \brief Movement speed. */
		func float getSpeed()
			return pSpeed
		end
		
		/** \brief Set movement speed. */
		func void setSpeed(float speed)
			pSpeed = DEMath.max(speed, 0.0)
		end
		
		
		
		/** \brief Element resolver used during loading or \em null if not set. */
		func ElementResolver getElementResolver()
			return pElementResolver
		end
		
		
		
		/** \brief Goal is set and actor is moved by this mover. */
		func bool hasGoal()
			return pGoalPosition != null
		end
		
		/** \brief Goal is not set and actor is not moved by this mover. */
		func bool hasNoGoal()
			return pGoalPosition == null
		end
		
		/** \brief Pause moving. */
		func bool getPause()
			return pPause
		end
		
		/** \brief Pause moving. */
		func void pauseMoving()
			if pPause
				return
			end
			
			pLocomotion.getLocomotion().setAnalogMovingSpeed(0)
			pPause = true
			updateRequiresThinking()
		end
		
		/** \brief Continue moving. */
		func void continueMoving()
			if pPause
				pPause = false
				updateRequiresThinking()
			end
		end
		
		
		
		/** \brief Move to goal. */
		func void moveTo(DVector goal)
			moveTo(goal, 0.001)
		end
		
		/**
		 * \brief Move to goal.
		 */
		func void moveTo(DVector goal, float distance)
			setGoalPosition(goal)
			pGoalDistance = DEMath.max(distance, 0.001)
			pPause = false
			pPath = null
			pNextPathPoint = 0
			pNextPlaneNormal = null
			
			if goal != null
				bareUpdatePath()
			end
			
			if pGoalPosition != null and pPath != null
				pListeners.forEach(block Listener each
					each.startMoving(this)
				end)
				
				if pGoalPosition == null or pPath == null
					return // listener forced stop moving
				end
				
				updateRequiresThinking()
				
				if pNextPathPoint == pPath.getCount()
					arrivedAtGoal()
				end
				
			else
				stopMoving()
				updateRequiresThinking()
			end
		end
		
		/** \brief Stop moving. */
		func void stopMoving()
			if pGoalPosition == null
				return
			end
			
			pListeners.forEach(block Listener each
				each.stopMoving(this)
			end)
			
			pLocomotion.getLocomotion().setAnalogMovingSpeed(0)
			
			pGoalPosition = null
			
			pPath = null
			pNextPathPoint = 0
			pNextPlaneNormal = null
			pRemainingDistance = 0
			updateRequiresThinking()
		end
		
		
		
		/**
		 * \brief Update move to path.
		 * 
		 * This method can be called while the actor is moving along a path to calculate a new
		 * path to the target. This is useful if the actor ended up in a bad location or the
		 * navigation spaces or navigator changed in a way the current path might be no more valid.
		 * 
		 * \retval true Path is valid and actor starts moving.
		 * \retval false No goal position is set.
		 * \retval false Path is valid and actor is already at goal position.
		 */
		func bool updatePath()
			bareUpdatePath()
			
			if pGoalPosition == null or pPath == null
				return false
				
			elif pNextPathPoint == pPath.getCount()
				arrivedAtGoal()
				return false
				
			else
				calculateRemainingDistance()
				return true
			end
		end
		
		/**
		 * \brief Update move to path without calling \ref #arrivedAtGoal().
		 * \version 1.24
		 */
		protected func void bareUpdatePath()
			if pGoalPosition == null
				pPath = null
				pNextPathPoint = 0
				pNextPlaneNormal = null
				pRemainingDistance = 0
				return
			end
			
			// check if actor is already at target
			var DVector actorPosition = getElement().getPosition()
			var DVector goalPosition = pGoalPosition
			var Collider ridableCollider
			if pRidableCollider != null
				ridableCollider = pRidableCollider.getCollider()
				goalPosition = ridableCollider.getMatrix() * goalPosition
			end
			
			// this check fails if actor is exactly below or above target on a different floor.
			// for this reason removed this optimization. it would be possible to re-enable this
			// optimization if the height of the actor is known. in this case the y distance would
			// have to be inside half the actor height for this check to be correct
			/*
			var DVector goalToActor = (goalPosition - actorPosition).compSelect(true, false, true)
			if goalToActor.getLength() <= 0.001  // add an option for this
				arrivedAtGoal()
				return false
			end
			*/
			
			// calculate path
			var Navigator navigator = pNavigator.getNavigator()
			var NavigatorPath path = NavigatorPath.new()
			navigator.findPath(path, actorPosition, goalPosition)
			
			var int i, pointCount = path.getCount()
			var DVector point, prevPoint = actorPosition
			pPath = NavigatorPath.new()
			for i = 0 to pointCount
				point = path.getAt(i)
				if not point.isEqualTo(prevPoint, 0.01)
					pPath.add(point)
				end
			end
			
			pointCount = pPath.getCount()
			if pointCount == 0 or not pPath.getAt(pointCount - 1).equals(goalPosition)
				pPath.add(goalPosition)
				pointCount++
			end
			
			if ridableCollider != null
				pPath.transform(ridableCollider.getInverseMatrix())
			end
			
			pNextPathPoint = 0
			
			// otherwise find the next path point to head for
			var DVector nextPoint
			
			while pNextPathPoint < pointCount
				nextPoint = pPath.getAt(pNextPathPoint)
				if ridableCollider != null
					nextPoint = ridableCollider.getMatrix() * nextPoint
				end
				
				pNextPlaneNormal = nextPoint - actorPosition
				if ridableCollider != null
					pNextPlaneNormal = ridableCollider.getInverseMatrix().transformNormal(pNextPlaneNormal)
				end
				
				if pNextPlaneNormal.getLength() <= 0.001
					pNextPathPoint++
					
				else
					pNextPlaneNormal = pNextPlaneNormal.normalize()
					break
				end
			end
			
			if pNextPathPoint < pointCount
				calculateRemainingDistance()
			end
		end
		
		
		
		/** \brief Next path point to move to or path point count if the actor is at the goal. */
		func int getNextPathPoint()
			return pNextPathPoint
		end
		
		/** \brief Move to next path plane normal. */
		func DVector getNextPlaneNormal()
			return pNextPlaneNormal
		end
		
		/**
		 * \brief Has next point.
		 * 
		 * If \em true is returned calls to getWorldNextPathPoint(), getWorldNextPlaneNormal()
		 * and getWorldDistanceNextPoint() will return non-null/non-0 value.
		 */
		func bool hasNextPathPoint()
			return pPath != null and pNextPathPoint < pPath.getCount()
		end
		
		/**
		 * \brief Next path point to move to or \em null if the actor is at the goal.
		 * 
		 * If present point is in world space (transformed by relative collider if present).
		 */
		func DVector getWorldNextPathPoint()
			if pPath == null or pNextPathPoint >= pPath.getCount()
				return null
			end
			
			var DVector point = pPath.getAt(pNextPathPoint)
			if pRidableCollider != null
				point = pRidableCollider.getCollider().getMatrix() * point
			end
			return point
		end
		
		/**
		 * \brief Move to next path plane normal or \em null if the actor is at the goal.
		 * 
		 * If present normal is in world space (transformed by relative collider if present).
		 */
		func DVector getWorldNextPlaneNormal()
			if pPath == null or pNextPathPoint >= pPath.getCount()
				return null
			end
			
			if pRidableCollider != null
				return pRidableCollider.getCollider().getMatrix().transformNormal(pNextPlaneNormal)
				
			else
				return pNextPlaneNormal
			end
		end
		
		/**
		 * \brief Distance from actor to next corner if present along normal.
		 * 
		 * Returns 0 if next corner or normal is not present.
		 */
		func float getWorldDistanceNextPoint()
			if pPath == null or pNextPathPoint >= pPath.getCount()
				return 0
			end
			
			var DVector point = pPath.getAt(pNextPathPoint)
			var DVector normal = pNextPlaneNormal
			
			if pRidableCollider != null
				var DMatrix matrix = pRidableCollider.getCollider().getMatrix()
				point = matrix * point
				normal = matrix.transformNormal(normal)
			end
			
			return normal * (point - getElement().getPosition())
		end
		
		
		
		/** \brief Rideable the actor is standing upon or \em null. */
		func ECBehaviorRidable.Instance getRidable()
			return pRidable
		end
		
		/**
		 * \brief Rideable collider the actor is standing upon or \em null.
		 * \version 1.5
		 */
		func ECBehaviorCollider.Instance getRidableCollider()
			return pRidableCollider
		end
		
		/**
		 * \brief Ridable changed.
		 * 
		 * Called by RidableChanged. If overwritten do not forget to super-call.
		 */
		func void onRidableChanged()
			var ECBehaviorRidable.Instance ridable = pRideOn.getRidable()
			var DMatrix matrix = DMatrix.new()
			
			if pRidableCollider != null
				matrix = pRidableCollider.getCollider().getMatrix()
			end
			
			pRidable = ridable
			pRidableCollider = null
			
			if ridable != null
				pRidableCollider = ridable.getCollider()
				matrix = matrix * pRidableCollider.getCollider().getInverseMatrix()
			end
			
			if pGoalPosition != null
				pGoalPosition = matrix * pGoalPosition
			end
			if pNextPlaneNormal != null
				pNextPlaneNormal = matrix.transformNormal(pNextPlaneNormal)
			end
			if pPath != null
				pPath.transform(matrix)
			end
		end
		
		
		
		/**
		 * \brief Arrive at target.
		 * 
		 * Calls stopMoving() and arrivedAtGoal() on listeners.
		 */
		func void arrivedAtGoal()
			var DVector goalPosition = pGoalPosition
			
			stopMoving()
			
			pListeners.forEach(block Listener each
				each.arrivedAtGoal(this, goalPosition)
			end)
		end
		
		
		
		/** \brief Update. */
		func void update(float elapsed)
			if pGoalPosition == null or pPause or pPath == null
				return
			end
			
			var Locomotion locomotion = pLocomotion.getLocomotion()
			var DVector actorPosition = getElement().getPosition()
			var int pointCount = pPath.getCount()
			var DVector nextCorner, nextNextCorner
			var DMatrix matrix, invMatrix
			var DVector nextNormal
			var float distance
			
			if pRidableCollider != null
				var Collider collider = pRidableCollider.getCollider()
				matrix = collider.getMatrix()
				invMatrix = collider.getInverseMatrix()
			end
			
			while pGoalPosition != null and not pPause
				nextCorner = pPath.getAt(pNextPathPoint)
				nextNormal = pNextPlaneNormal
				if matrix != null
					nextCorner = matrix * nextCorner
					nextNormal = matrix.transformNormal(nextNormal)
				end
				
				distance = nextNormal * (nextCorner - actorPosition)
				
				// actor is close enough to target
				if pRemainingDistance + distance <= pGoalDistance
					arrivedAtGoal()
					break
				end
				
				// heading for the next path point
				if distance < locomotion.getAbsMovingSpeed() * 0.1   // add option for this
					// sanity check. if the position is more than 1m away from the corner the actor is most probably stuck
					// due to some unholy combination of circumstances. recalculate the path to get out of the mess
// 					if (nextCorner - position).getLength() > 1.0
// 						pDirtyPath = true
// 						update(elapsed)
// 						return
// 					end
					
					// continue with next corner unless we are at the end of the path
					pNextPathPoint++
					if pNextPathPoint == pointCount
						arrivedAtGoal()
						break
					end
					
					// head for the next path point
					nextNextCorner = pPath.getAt(pNextPathPoint)
					if matrix != null
						nextNextCorner = matrix * nextNextCorner
					end
					
					pNextPlaneNormal = (nextNextCorner - nextCorner).normalize()
					if invMatrix != null
						pNextPlaneNormal = invMatrix.transformNormal(pNextPlaneNormal)
					end
					pRemainingDistance -= (nextNextCorner - nextCorner).getLength()
					
					continue
				end
				
				// move towards next path corner. calls listeners to allow modify the result
				moveTowards(nextCorner, elapsed)
				pListeners.forEach(block Listener each
					each.modifyMoveTowards(this, nextCorner, elapsed)
				end)
				break
			end
		end
		
		/**
		 * \brief Update locomotion to move towards the next path point.
		 * 
		 * Called by update() as long as the actor is moving.
		 * 
		 * Sets the locomotion to move straight towards the next path point. Adjusts looking,
		 * turning and moving left-right to head for the path point. Adjusts looking up-down
		 * to have the same elevation as the element Y position compared to the next path Y
		 * position.
		 * 
		 * Caller is responsible to allow listeners to modify the result.
		 */
		func void moveTowards(DVector position, float elapsed)
			var Locomotion locomotion = pLocomotion.getLocomotion()
			
			// adjust moving direction towards next corner point
			var DVector moveDirection = position - getElement().getPosition()
			var float elevation = moveDirection.getY()
			
			moveDirection = moveDirection.compSelect(true, false, true).normalize()
			var float targetOrientation = DEMath.atan2(-moveDirection.getX(), moveDirection.getZ())
			
			locomotion.setLookVerticalGoal(DEMath.atan2(elevation, moveDirection.getLength()))
			
			// this limitation of the look left-right goal to angles slightly less than 90
			// degrees prevents the actor from trying to walk backward in cases of sharp
			// turns. it has to be applied after the normalize otherwise the result is wrong
			var float turnAngle = DEMath.normalize(targetOrientation - locomotion.getOrientation(), -180.0, 180.0)
			if pEnableLimitTurnAngle
				turnAngle = DEMath.clamp(turnAngle, -pLimitTurnAngle, pLimitTurnAngle)
			end
			
			locomotion.setLookHorizontalGoal(turnAngle)
			locomotion.setTurnHorizontal(turnAngle)
			locomotion.setAnalogMovingHorizontalGoal(turnAngle)
			locomotion.setAnalogMovingSpeed(pSpeed)
		end
		
		
		
		/** \brief Remaining distance from current position to goal position along path in meters. */
		func float getDistanceToGoal()
			if pGoalPosition == null or pPath == null
				return 0
			end
			
			var DVector nextCorner = pPath.getAt(pNextPathPoint)
			if pRidableCollider != null
				nextCorner = pRidableCollider.getCollider().getMatrix() * nextCorner
			end
			
			return pRemainingDistance + (nextCorner - getElement().getPosition()).getLength()
		end
		
		/** \brief Calculate remaining distance from next path point to goal position along meters. */
		func void calculateRemainingDistance()
			pRemainingDistance = 0
			
			if pGoalPosition != null and pPath != null and pNextPathPoint < pPath.getCount()
				pRemainingDistance = pPath.getLengthFrom(pNextPathPoint)
			end
		end
		
		
		
		/**
		 * \brief Place actor on position relative on remaining path.
		 * \param position Value in range 0 (current position) to 1 (goal position) along path.
		 */
		func void placeOnPath(float position)
			if pGoalPosition == null or pPath == null
				return
			end
			
			var float remainingDistance = getDistanceToGoal() * position
			var int pointCount = pPath.getCount()
			
			var Locomotion locomotion = pLocomotion.getLocomotion()
			var DVector actorPosition = getElement().getPosition()
			var DVector nextCorner, nextNextCorner
			var DMatrix matrix, invMatrix
			
			var float targetOrientation = locomotion.getOrientation()
			var DVector orientationDirection
			var float targetVertical = 0
			var DVector moveDirection
			var float elevation
			var float distance
			
			if pRidableCollider != null
				var Collider collider = pRidableCollider.getCollider()
				matrix = collider.getMatrix()
				invMatrix = collider.getInverseMatrix()
			end
			
			var bool hitGoal = false
			while pGoalPosition != null and not pPause
				nextCorner = pPath.getAt(pNextPathPoint)
				if matrix != null
					nextCorner = matrix * nextCorner
				end
				
				moveDirection = nextCorner - actorPosition
				distance = moveDirection.getLength()
				elevation = moveDirection.getY()
				
				orientationDirection = moveDirection.compSelect(true, false, true).normalize()
				targetOrientation = DEMath.atan2(-orientationDirection.getX(), orientationDirection.getZ())
				targetVertical = DEMath.atan2(elevation, distance)
				
				if remainingDistance < distance
					actorPosition = actorPosition + moveDirection * (remainingDistance / distance)
				end
				
				if remainingDistance < distance
					break
				end
				
				actorPosition = nextCorner
				remainingDistance -= distance
				
				pNextPathPoint++
				if pNextPathPoint == pointCount
					hitGoal = true
					break
				end
				
				nextNextCorner = pPath.getAt(pNextPathPoint)
				if matrix != null
					nextNextCorner = matrix * nextNextCorner
				end
				
				pNextPlaneNormal = (nextNextCorner - nextCorner).normalize()
				if invMatrix != null
					pNextPlaneNormal = invMatrix.transformNormal(pNextPlaneNormal)
				end
			end
			
			calculateRemainingDistance()
			
			// update the locomotion and actor with the found results
			var float turnAngle = DEMath.normalize(targetOrientation - locomotion.getOrientation(), -180.0, 180.0)
			if pEnableLimitTurnAngle
				turnAngle = DEMath.clamp(turnAngle, -pLimitTurnAngle, pLimitTurnAngle)
			end
			
			locomotion.setLookVerticalGoal(targetVertical)
			locomotion.setLookHorizontalGoal(turnAngle)
			locomotion.setTurnHorizontal(turnAngle)
			locomotion.setAnalogMovingHorizontalGoal(turnAngle)
			locomotion.setAnalogMovingSpeed(pSpeed)
			
			getElement().setPosition(actorPosition)
			
			// actor is close enough to target
			if hitGoal
				arrivedAtGoal()
				return
			end
			
			nextCorner = pPath.getAt(pNextPathPoint)
			if matrix != null
				nextCorner = matrix * nextCorner
			end
			
			if pRemainingDistance + (nextCorner - actorPosition).getLength() <= pGoalDistance
				arrivedAtGoal()
			end
		end
		
		
		
		/** \brief Add listener. */
		func void addListener(Listener listener)
			if listener == null
				throw EInvalidParam.new()
			end
			pListeners.add(listener)
		end
		
		/** \brief Remove listener. */
		func void removeListener(Listener listener)
			pListeners.remove(listener)
		end
		
		
		
		/** \brief Frame update started. */
		func void enterFrame()
			if pElementResolver != null
				pElementResolver.resolve(getElement().getGameWorld())
				pElementResolver = null
			end
		end
		
		/** \brief Think about what to do for the next frame update. */
		func void think(float elapsed)
			update(elapsed)
		end
		
		/** \brief Remove element from game world. */
		func void removeFromGameWorld()
			stopMoving()
		end
		
		
		
		/**
		 * \brief Update requires thinking.
		 * \version 1.21
		 */
		protected func void updateRequiresThinking()
			setRequiresThink(pGoalPosition != null and not pPause and pPath != null)
		end
		
		
		
		/** \brief Read behavior from file. */
		func void readFromFile(PersistencyEnvironment env, FileReader reader)
			select reader.readByte() // version
			case 0
				var PersistencyFlags flags = PersistencyFlags.new(6, reader)
				pPause = flags.getAt(0)
				pEnableLimitTurnAngle = flags.getAt(1)
				
				if flags.getAt(2)
					pGoalPosition = DVector.readFromFile(reader)
				end
				pGoalDistance = reader.readFloat()
				
				if flags.getAt(4)
					pPath = NavigatorPath.readFromFile(reader)
				end
				pNextPathPoint = reader.readUShort()
				
				if flags.getAt(3)
					pNextPlaneNormal = DVector.readFromFile(reader)
				end
				pRemainingDistance = reader.readFloat()
				
				pLimitTurnAngle = reader.readFloat()
				pSpeed = reader.readFloat()
				
				if flags.getAt(5)
					pElementResolver = ElementResolver.new()
					pElementResolver.addBehavior(reader, block ECBehaviorRidable.Instance behavior
						pRidable = behavior
						pRidableCollider = behavior.getCollider()
					end)
					setRequiresEnterFrame(true)
				end
				
			else
				throw EInvalidParam.new("unsupported version")
			end
			
			updateRequiresThinking()
		end
		
		/**
		 * \brief Write behavior to file.
		 * 
		 * If relative collider is present the goal position is transformed to world spaces before
		 * being written. The relative collider is not saved. During loading the  base actor is
		 * responsible to restore the relative collider. This has to be done any.
		 */
		func void writeToFile(PersistencyEnvironment env, FileWriter writer)
			writer.writeByte(0) // version
			
			var PersistencyFlags flags = PersistencyFlags.new(6)
			flags.setAt(0, pPause)
			flags.setAt(1, pEnableLimitTurnAngle)
			flags.setAt(2, pGoalPosition != null)
			flags.setAt(3, pNextPlaneNormal != null)
			flags.setAt(4, pPath != null)
			flags.setAt(5, pRidable != null)
			flags.writeToFile(writer)
			
			if pGoalPosition != null
				pGoalPosition.writeToFile(writer)
			end
			writer.writeFloat(pGoalDistance)
			
			if pPath != null
				pPath.writeToFile(writer)
			end
			writer.writeUShort(pNextPathPoint)
			
			if pNextPlaneNormal != null
				pNextPlaneNormal.writeToFile(writer)
			end
			writer.writeFloat(pRemainingDistance)
			
			writer.writeFloat(pLimitTurnAngle)
			writer.writeFloat(pSpeed)
			
			if pRidable != null
				ElementResolver.writeToFileBehavior(writer, pRidable)
			end
		end
	end
	
	
	
	var ECBehaviorLocomotion pLocomotion
	var ECBehaviorNavigator pNavigator
	var ECBehaviorRideOn pRideOn
	var ECBehaviorConversationActor pConversationActor
	var ECPFloat pSpeed
	var Array pListenerFactories
	
	
	
	/**
	 * \brief Create behavior element class.
	 * 
	 * These values are optional and can be null: \em rideOn.
	 */
	func new(BehaviorElementClass eclass, ECBehaviorLocomotion locomotion, \
	ECBehaviorNavigator navigator, ECBehaviorRideOn rideOn) \
	this(eclass, locomotion, navigator, rideOn, "actorMover.")
	end
	
	func new(BehaviorElementClass eclass, ECBehaviorLocomotion locomotion, \
	ECBehaviorNavigator navigator, ECBehaviorRideOn rideOn, String prefix) super(eclass)
		if locomotion == null
			throw ENullPointer.new("locomotion")
		end
		if navigator == null
			throw ENullPointer.new("navigator")
		end
		
		pLocomotion = locomotion
		pNavigator = navigator
		pRideOn = rideOn
		pListenerFactories = Array.new()
		
		pSpeed = ECPFloat.new(prefix + "speed", 1.25, 0)
		eclass.addProperty(pSpeed)
		
		eclass.addBehavior(this)
	end
	
	/** \brief Dispose of behavior. */
	func void dispose()
		pRideOn = null
		pNavigator = null
		pLocomotion = null
		pConversationActor = null
		pListenerFactories = null
		super.dispose()
	end
	
	
	
	/** \brief Locomotion behavior to use. */
	func ECBehaviorLocomotion getLocomotion()
		return pLocomotion
	end
	
	/** \brief Navigator behavior to use. */
	func ECBehaviorNavigator getNavigator()
		return pNavigator
	end
	
	/** \brief Ride on behavior to use or null. */
	func ECBehaviorRideOn getRideOn()
		return pRideOn
	end
	
	/** \brief Conversation actor behavior or null. */
	func ECBehaviorConversationActor getConversationActor()
		return pConversationActor
	end
	
	/**
	 * \brief Set conversation actor or null.
	 * 
	 * If set conversation conditions and commands are added.
	 */
	func void setConversationActor(ECBehaviorConversationActor conversationActor)
		pConversationActor = conversationActor
	end
	
	/** \brief Movement speed. */
	func ECPFloat getSpeed()
		return pSpeed
	end
	
	/** \brief Add listener factory. */
	func void addListenerFactory(ListenerFactory factory)
		if factory == null
			throw ENullPointer.new()
		end
		pListenerFactories.add(factory)
	end
	
	/**
	 * \brief Add listener factory using block.
	 * 
	 * Block receives as parameter Instance and returns Listener.
	 */
	func void addListenerFactory(Block blockFactory)
		pListenerFactories.add(BlockListenerFactory.new(blockFactory))
	end
	
	/** \brief Visit listener factories with block with argument ListenerFactory. */
	func void forEachListenerFactory(Block ablock)
		pListenerFactories.forEach(ablock)
	end
	
	/** \brief Create listeners from factories adding them to behavior instance. */
	func void createListeners(Instance instance)
		pListenerFactories.forEach(block ListenerFactory each
			instance.addListener(each.createListener(instance))
		end)
	end
	
	
	
	/** \brief Get instance in element from owner element class. */
	func Instance instance(BehaviorElement element)
		return element.getInstanceAt(getInstanceIndex()) cast Instance
	end
	
	
	
	/**
	 * \brief Get behavior in element class or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElementClass contains a behavior
	 * of type ECBehaviorActorMover.
	 */
	static func ECBehaviorActorMover getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBehaviorActorMover each
			return true
		end) cast ECBehaviorActorMover
	end
	
	/**
	 * \brief Get instance in element or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElement contains a behavior instance
	 * of type ECBehaviorActorMover.Instance .
	 */
	static func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	
	
	/** \brief Create Behavior instance. */
	func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
