/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Scenery

pin Dragengine.ConversationSystem
pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Utils


/**
 * \brief Behavior adding mover support to actors.
 * 
 * Uses ECBehaviorNavigator to find a path. Uses ECBehaviorLocomotion to provide input to
 * the actor for the direction to move to. Listener tell the actor and other behavior
 * about the state of moving towards the goal.
 * 
 * Requires these behaviors the be present:
 * - ECBehaviorLocomotion
 * - ECBehaviorNavigator
 * 
 * Supports these optional behaviors:
 * - ECBehaviorRideOn: Allows mover goal relative to ridable supported elements.
 * - ECBehaviorConversationActor: Adds conversation commands to control behavior.
 * 
 * Add a listener to be notified if the actor arrives at the target. For BaseActor the class
 * BaseActorListener can be used calling BaseActorAI.arrivedAtGoal().
 * 
 * If conversation actor is used see ECBehaviorActorMover.ConvoCondition and
 * ECBehaviorActorMover.ConvoCommand for supported syntax.
 */
class ECBehaviorActorMover extends DefaultECBehavior
	/** \brief Listener for behavior instance events. */
	interface Listener
		/** \brief Actor starts moving towards goal. */
		func void startMoving( Instance instance )
		
		/** \brief Actor stops moving. */
		func void stopMoving( Instance instance )
		
		/**
		 * \brief Actor arrived at goal position.
		 * \note stopMoving() will be called before arrivedAtGoal() is called.
		 */
		func void arrivedAtGoal( Instance instance, DVector goalPosition )
		
		/** \brief Modify locomotion values set by moveTowards(). */
		func void modifyMoveTowards( Instance instance, DVector position, float elapsed )
	end
	
	/** \brief Default implementation of behavior instance listener. */
	class DefaultListener implements Listener
		/** \brief Create default listener. */
		public func new()
		end
		
		/** \brief Actor starts moving towards goal. */
		public func void startMoving( Instance instance )
		end
		
		/** \brief Actor stops moving. */
		public func void stopMoving( Instance instance )
		end
		
		/**
		 * \brief Actor arrived at goal position.
		 * \note stopMoving() will be called before arrivedAtGoal() is called.
		 */
		public func void arrivedAtGoal( Instance instance, DVector goalPosition )
		end
		
		/** \brief Modify locomotion values set by moveTowards(). */
		public func void modifyMoveTowards( Instance instance, DVector position, float elapsed )
		end
	end
	
	/** \brief Factory creating listeners. */
	interface ListenerFactory
		/** \brief Create listener. */
		func Listener createListener( Instance instance )
	end
	
	/** \brief Factory creating listeners using block. */
	class BlockListenerFactory implements ListenerFactory
		private var Block pBlock
		
		/** \brief Create factory using block receiving Instance as parameter returning Listener. */
		public func new( Block blockFactory )
			if blockFactory == null
				throw ENullPointer.new()
			end
			this.pBlock = blockFactory
		end
		
		/** \brief Create listener. */
		public func Listener createListener( Instance instance )
			return this.pBlock.run( instance ) cast Listener
		end
	end
	
	/**
	 * \brief Conversation condition.
	 * 
	 * Syntax:
	 * actorMover hasGoal|hasNoGoal|paused
	 *   Calls hasGoal(), hasNoGoal(), getPause(). Typically used to check if the actor is
	 *   moving to a goal or not.
	 * 
	 * actorMover closerThan goal|direct [distance]
	 *   Checks if the distance to the goal is less than or equal to "distance". If no goal is
	 *   set true is returned. If "goal" is specified uses remaining goal distance. If "direct"
	 *   is specified uses distance between actor and goal position. The remaining goal distance
	 *   is not necessarily the same as the direct line distance between the actor and the goal.
	 */
	class ConvoCondition implements ECBehaviorConversationActor.ConversationCondition
		private var Instance pInstance
		
		public func new( Instance instance )
			this.pInstance = instance
		end
		
		public func bool evaluateCondition( ECBehaviorConversationActor.Instance instance, Array arguments )
			var String action = arguments.getAt( 1 ) cast String
			
			if action.equals( "hasGoal" )
				return this.evaluateHasGoal( instance, arguments )
				
			elif action.equals( "hasNoGoal" )
				return this.evaluateHasNoGoal( instance, arguments )
				
			elif action.equals( "paused" )
				return this.evaluatePaused( instance, arguments )
				
			elif action.equals( "closerThan" )
				return this.evaluateCloserThan( instance, arguments )
				
			else
				throw EInvalidParam.new( "Unknown action '" + action + "'" )
			end
		end
		
		protected func bool evaluateHasGoal( ECBehaviorConversationActor.Instance instance, Array arguments )
			return this.pInstance.hasGoal()
		end
		
		protected func bool evaluateHasNoGoal( ECBehaviorConversationActor.Instance instance, Array arguments )
			return this.pInstance.hasNoGoal()
		end
		
		protected func bool evaluatePaused( ECBehaviorConversationActor.Instance instance, Array arguments )
			return this.pInstance.getPause()
		end
		
		protected func bool evaluateCloserThan( ECBehaviorConversationActor.Instance instance, Array arguments )
			if this.pInstance.hasNoGoal()
				return true
			end
			
			var String action = arguments.getAt( 2 ) cast String
			var float distance = ( arguments.getAt( 3 ) cast String ).toFloat()
			
			if action.equals( "goal" )
				return this.pInstance.getGoalDistance() <= distance
				
			elif action.equals( "direct" )
				return ( instance.getElement().getPosition() - this.pInstance.getGoalPosition() ) \
					.getLength() <= distance
				
			else
				throw EInvalidParam.new( "closerThan: Unknown keyword '" + action + "'" )
			end
		end
	end
	
	/**
	 * \brief Conversation command.
	 * 
	 * Syntax:
	 * actorMover pause|continue|stop
	 *   Calls pauseMoving(), continueMoving() or stopMoving().
	 * 
	 * actorMover actor [id] [distance]
	 *   Start moving to position of conversation actor.
	 *   - id: Identifier or Alias of conversation actor. Throws exception conversation actor
	 *         has no playback or actor id/alias is unknown.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover coordsys [id] [distance]
	 *   Start moving to position of conversation coordinate system.
	 *   - id: Identifier of conversation coord system to use. Throws exception conversation
	 *         actor has no playback or identifier is unknown.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover spawn [name] [distance]
	 *   Start moving to position of spawn point.
	 *   - name: Name of spawn point to use. Throws exception element is not in a game world
	 *           or name is not found in the game world.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover anchor [id] [distance]
	 *   Start moving to position of anchor element.
	 *   - id: Identifier of anchor element to use. Throws exception element is not in a game
	 *         world or name is not found in the game world.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover position [x] [y] [z] [distance]
	 *   Start moving to position in game world.
	 *   - x,y,z: Coordinates of position to move to.
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 * 
	 * actorMover relative [offsetX] [offsetY] [offsetZ] [distance]
	 *   - offset*: Position relative to Element.getElementMatrix().
	 *   - distance: Stops moving as soon as the remaining distance in meters to goal is less
	 *               than or equal to "distance".
	 */
	class ConvoCommand implements ECBehaviorConversationActor.ConversationCommand
		private var Instance pInstance
		
		public func new( Instance instance )
			this.pInstance = instance
		end
		
		public func void runCommand( ECBehaviorConversationActor.Instance instance, Array arguments )
			var String action = arguments.getAt( 1 ) cast String
			
			if action.equals( "pause" )
				this.runPause( instance, arguments )
				
			elif action.equals( "continue" )
				this.runContinue( instance, arguments )
				
			elif action.equals( "stop" )
				this.runStop( instance, arguments )
				
			elif action.equals( "position" )
				this.runPosition( instance, arguments )
				
			elif action.equals( "relative" )
				this.runRelative( instance, arguments )
				
			elif action.equals( "actor" )
				this.runActor( instance, arguments )
				
			elif action.equals( "coordsys" )
				this.runCoordSystem( instance, arguments )
				
			elif action.equals( "spawn" )
				this.runSpawn( instance, arguments )
				
			elif action.equals( "anchor" )
				this.runAnchor( instance, arguments )
				
			else
				throw EInvalidParam.new( "Unknown action '" + action + "'" )
			end
		end
		
		protected func void runPause( ECBehaviorConversationActor.Instance instance, Array arguments )
			this.pInstance.pauseMoving()
		end
		
		protected func void runContinue( ECBehaviorConversationActor.Instance instance, Array arguments )
			this.pInstance.continueMoving()
		end
		
		protected func void runStop( ECBehaviorConversationActor.Instance instance, Array arguments )
			this.pInstance.stopMoving()
		end
		
		protected func void runPosition( ECBehaviorConversationActor.Instance instance, Array arguments )
			// TODO we can not handle double precision values like this
			var float x = ( arguments.getAt( 2 ) cast String ).toFloat()
			var float y = ( arguments.getAt( 3 ) cast String ).toFloat()
			var float z = ( arguments.getAt( 4 ) cast String ).toFloat()
			var float distance = ( arguments.getAt( 5 ) cast String ).toFloat()
			this.pInstance.moveTo( DVector.new( x, y, z ), distance )
		end
		
		protected func void runRelative( ECBehaviorConversationActor.Instance instance, Array arguments )
			var float x = ( arguments.getAt( 2 ) cast String ).toFloat()
			var float y = ( arguments.getAt( 3 ) cast String ).toFloat()
			var float z = ( arguments.getAt( 4 ) cast String ).toFloat()
			var float distance = ( arguments.getAt( 5 ) cast String ).toFloat()
			this.pInstance.moveTo( instance.getElement().getElementMatrix() * DVector.new( x, y, z ), distance )
		end
		
		protected func void runActor( ECBehaviorConversationActor.Instance instance, Array arguments )
			var ConversationPlayback playback = instance.getConversationActor().getPlayback()
			if playback == null
				throw EInvalidParam.new( "Playback is null" )
			end
			
			var String id = arguments.getAt( 2 ) cast String
			var ConversationActor actor = playback.getActorMatching( StringID.new( id ) )
			if actor == null
				throw EInvalidParam.new( "No conversation actor found with id/alias '" + id + "'" )
			end
			
			var float distance = ( arguments.getAt( 3 ) cast String ).toFloat()
			this.pInstance.moveTo( actor.getMatrix().getPosition(), distance )
		end
		
		protected func void runCoordSystem( ECBehaviorConversationActor.Instance instance, Array arguments )
			var ConversationPlayback playback = instance.getConversationActor().getPlayback()
			if playback == null
				throw EInvalidParam.new( "Playback is null" )
			end
			
			var String id = arguments.getAt( 2 ) cast String
			var ConversationCoordSystem coordSys = playback.createConversationCoordSystem( StringID.new( id ) )
			if coordSys == null
				throw EInvalidParam.new( "No conversation system found with id '" + id + "'" )
			end
			
			var float distance = ( arguments.getAt( 3 ) cast String ).toFloat()
			this.pInstance.moveTo( coordSys.getMatrix().getPosition(), distance )
		end
		
		protected func void runSpawn( ECBehaviorConversationActor.Instance instance, Array arguments )
			var GameWorld gameWorld = instance.getElement().getGameWorld()
			if gameWorld == null
				throw EInvalidParam.new( "Element game world is null" )
			end
			
			var String name = arguments.getAt( 2 ) cast String
			var SpawnPoint spawn = gameWorld.getSpawnPoints().getNamed( name )
			if spawn == null
				throw EInvalidParam.new( "No spawn point found with name '" + name + "'" )
			end
			
			var float distance = ( arguments.getAt( 3 ) cast String ).toFloat()
			this.pInstance.moveTo( spawn.getPosition(), distance )
		end
		
		protected func void runAnchor( ECBehaviorConversationActor.Instance instance, Array arguments )
			var GameWorld gameWorld = instance.getElement().getGameWorld()
			if gameWorld == null
				throw EInvalidParam.new( "Element game world is null" )
			end
			
			var String id = arguments.getAt( 2 ) cast String
			var Element anchor = gameWorld.getAnchoredElementList().getAt( StringID.new( id ) )
			if anchor == null
				throw EInvalidParam.new( "No anchor found with identifier '" + id + "'" )
			end
			
			var float distance = ( arguments.getAt( 3 ) cast String ).toFloat()
			this.pInstance.moveTo( anchor.getPosition(), distance )
		end
	end
	
	
	
	/** \brief Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		/** \brief Ridable changed. */
		protected class RidableChanged extends ECBehaviorRideOn.DefaultListener
			private var Instance pInstance
			
			public func new( Instance instance )
				this.pInstance = instance
			end
			
			public func void ridableChanged( ECBehaviorRideOn.Instance instance )
				this.pInstance.onRidableChanged()
			end
		end
		
		
		private var ECBehaviorActorMover pECBehavior
		
		private var ECBehaviorLocomotion.Instance pLocomotion
		private var ECBehaviorNavigator.Instance pNavigator
		private var ECBehaviorRideOn.Instance pRideOn
		private var ECBehaviorRidable.Instance pRidable
		private var ECBehaviorConversationActor.Instance pConversationActor
		
		private var DVector pGoalPosition
		private var float pGoalDistance
		private var NavigatorPath pPath
		private var int pNextPathPoint
		private var DVector pNextPlaneNormal
		private var bool pPause
		
		private var float pRemainingDistance
		
		private var bool pEnableLimitTurnAngle
		private var float pLimitTurnAngle
		
		private var float pSpeed
		
		private var ElementResolver pElementResolver
		private var Array pListeners
		
		
		
		/** \brief Create behavior instance. */
		public func new( ECBehaviorActorMover ecbehavior, BehaviorElement element ) super( element )
			this.pECBehavior = ecbehavior
			this.pGoalDistance = 0
			this.pNextPathPoint = 0
			this.pPause = false
			this.pEnableLimitTurnAngle = false
			this.pLimitTurnAngle = 89
			this.pListeners = Array.new()
			
			this.pLocomotion = ecbehavior.getLocomotion().instance( element )
			this.pNavigator = ecbehavior.getNavigator().instance( element )
			
			this.setRequiresThink( true )
		end
		
		/** \brief Dispose of behavior instance. */
		public func void dispose()
			this.pConversationActor = null
			this.pRidable = null
			this.pRideOn = null
			this.pNavigator = null
			this.pLocomotion = null
			this.pListeners = null
			this.pElementResolver = null
			
			super.dispose()
		end
		
		
		
		/** \brief Initialize behavior from stub. */
		public func void init( StubElement stub )
			var BehaviorElement element = this.getElement()
			
			this.pSpeed = this.pECBehavior.getSpeed().getValue( stub )
			
			if this.pECBehavior.getRideOn() != null
				this.pRideOn = this.pECBehavior.getRideOn().instance( element )
			end
			if this.pECBehavior.getConversationActor() != null
				this.pConversationActor = this.pECBehavior.getConversationActor().instance( element )
			end
			
			if this.pRideOn != null
				this.pRideOn.addListener( RidableChanged.new( this ) )
			end
			if this.pConversationActor != null
				this.pConversationActor.addCondition( "actorMover", ConvoCondition.new( this ) )
				this.pConversationActor.addCommand( "actorMover", ConvoCommand.new( this ) )
			end
			
			this.pECBehavior.createListeners( this )
		end
		
		
		
		/** \brief Behavior. */
		public func ECBehaviorActorMover getECBehavior()
			return this.pECBehavior
		end
		
		/** \brief Locomotion behavior. */
		public func ECBehaviorLocomotion.Instance getLocomotion()
			return this.pLocomotion
		end
		
		/** \brief Navigator behavior. */
		public func ECBehaviorNavigator.Instance getNavigator()
			return this.pNavigator
		end
		
		/** \brief Conversation actor if present. */
		public func ECBehaviorConversationActor.Instance getConversationActor()
			return this.pConversationActor
		end
		
		/** \brief Ride on behavior if present. */
		public func ECBehaviorRideOn.Instance getRideOn()
			return this.pRideOn
		end
		
		
		
		/** \brief Goal to move to or \em null if not set. */
		public func DVector getGoalPosition()
			return this.pGoalPosition
		end
		
		/** \brief Set goal to move to. */
		public func void setGoalPosition( DVector goal )
			if this.pRidable != null
				goal = this.pRidable.getCollider().getCollider().getInverseMatrix() * goal
			end
			
			if goal.equals( this.pGoalPosition )
				return
			end
			
			this.pGoalPosition = goal
			this.pPath = null
			this.pNextPathPoint = 0
		end
		
		/** \brief Distance along path below which actor arrive at target is triggered. */
		public func float getGoalDistance()
			return this.pGoalDistance
		end
		
		/** \brief Set distance along path below which actor arrive at target is triggered. */
		public func void setGoalDistance( float distance )
			this.pGoalDistance = DEMath.max( distance, 0.0 )
		end
		
		/** \brief Path or \em null if not calculated. */
		public func NavigatorPath getPath()
			return this.pPath
		end
		
		
		
		/** \brief Enable limit turning angle. */
		public func bool getEnableLimitTurnAngle()
			return this.pEnableLimitTurnAngle
		end
		
		/** \brief Set if limit turning angle is enabled. */
		public func void setEnableLimitTurnAngle( bool enabled )
			this.pEnableLimitTurnAngle = enabled
		end
		
		/** \brief Turning angle limit in degrees if enabled. */
		public func float getLimitTurnAngle()
			return this.pLimitTurnAngle
		end
		
		/** \brief Set turning angle limit in degrees if enabled. */
		public func void setLimitTurnAngle( float angle )
			this.pLimitTurnAngle = DEMath.max( angle, 0.0 )
		end
		
		/** \brief Movement speed. */
		public func float getSpeed()
			return this.pSpeed
		end
		
		/** \brief Set movement speed. */
		public func void setSpeed( float speed )
			this.pSpeed = DEMath.max( speed, 0.0 )
		end
		
		
		
		/** \brief Element resolver used during loading or \em null if not set. */
		public func ElementResolver getElementResolver()
			return this.pElementResolver
		end
		
		
		
		/** \brief Goal is set and actor is moved by this mover. */
		public func bool hasGoal()
			return this.pGoalPosition != null
		end
		
		/** \brief Goal is not set and actor is not moved by this mover. */
		public func bool hasNoGoal()
			return this.pGoalPosition == null
		end
		
		/** \brief Pause moving. */
		public func bool getPause()
			return this.pPause
		end
		
		/** \brief Pause moving. */
		public func void pauseMoving()
			if this.pPause
				return
			end
			
			this.pLocomotion.getLocomotion().setAnalogMovingSpeed( 0 )
			this.pPause = true
		end
		
		/** \brief Continue moving. */
		public func void continueMoving()
			this.pPause = false
		end
		
		
		
		/** \brief Move to goal. */
		public func void moveTo( DVector goal )
			this.moveTo( goal, 0.001 )
		end
		
		/**
		 * \brief Move to goal.
		 */
		public func void moveTo( DVector goal, float distance )
			this.setGoalPosition( goal )
			this.pGoalDistance = DEMath.max( distance, 0.001 )
			this.pPause = false
			this.pPath = null
			
			if goal != null
				this.updatePath()
			end
			
			this.pListeners.forEach( block Listener each
				each.startMoving( this )
			end )
		end
		
		/** \brief Stop moving. */
		public func void stopMoving()
			if this.pGoalPosition == null
				return
			end
			
			this.pListeners.forEach( block Listener each
				each.stopMoving( this )
			end )
			
			this.pLocomotion.getLocomotion().setAnalogMovingSpeed( 0 )
			
			this.pGoalPosition = null
			
			this.pPath = null
			this.pNextPathPoint = 0
			this.pRemainingDistance = 0
		end
		
		
		
		/**
		 * \brief Update move to path.
		 */
		public func bool updatePath()
			if this.pGoalPosition == null
				this.pPath = null
				this.pNextPathPoint = 0
				this.pNextPlaneNormal = null
				this.pRemainingDistance = 0
				return false
			end
			
			// check if actor is already at target
			var DVector actorPosition = this.getElement().getPosition()
			var DVector goalPosition = this.pGoalPosition
			var Collider ridableCollider
			if this.pRidable != null
				ridableCollider = this.pRidable.getCollider().getCollider()
				goalPosition = ridableCollider.getMatrix() * goalPosition
			end
			
			var DVector goalToActor = ( goalPosition - actorPosition ).compSelect( true, false, true )
			if goalToActor.getLength() <= 0.001  // add an option for this
				this.arrivedAtGoal()
				return false
			end
			
			// calculate path
			var Navigator navigator = this.pNavigator.getNavigator()
			var NavigatorPath path = NavigatorPath.new()
			navigator.findPath( path, actorPosition, goalPosition )
			
			var int i, pointCount = path.getCount()
			var DVector point, prevPoint = actorPosition
			this.pPath = NavigatorPath.new()
			for i = 0 to pointCount
				point = path.getAt( i )
				if not point.isEqualTo( prevPoint, 0.01 )
					this.pPath.add( point )
				end
			end
			
			pointCount = this.pPath.getCount()
			if pointCount == 0 or not this.pPath.getAt( pointCount - 1 ).equals( goalPosition )
				this.pPath.add( goalPosition )
			end
			
			if ridableCollider != null
				this.pPath.transform( ridableCollider.getInverseMatrix() )
			end
			
			this.pNextPathPoint = 0
			
			// otherwise find the next path point to head for
			var DVector nextPoint
			
			while this.pNextPathPoint < pointCount
				nextPoint = this.pPath.getAt( this.pNextPathPoint )
				if ridableCollider != null
					nextPoint = ridableCollider.getMatrix() * nextPoint
				end
				
				this.pNextPlaneNormal = nextPoint - actorPosition
				if ridableCollider != null
					this.pNextPlaneNormal = ridableCollider.getInverseMatrix().transformNormal( this.pNextPlaneNormal )
				end
				
				if this.pNextPlaneNormal.isEqualTo( DVector.new(), 0.001 )
					this.pNextPathPoint++
					
				else
					this.pNextPlaneNormal = this.pNextPlaneNormal.normalize()
					break
				end
			end
			
			if this.pNextPathPoint == pointCount
				this.arrivedAtGoal()
				return false
			end
			
			this.calculateRemainingDistance()
			return true
		end
		
		
		
		/** \brief Next path point to move to or path point count if the actor is at the goal. */
		public func int getNextPathPoint()
			return this.pNextPathPoint
		end
		
		/** \brief Move to next path plane normal. */
		public func DVector getNextPlaneNormal()
			return this.pNextPlaneNormal
		end
		
		/**
		 * \brief Has next point.
		 * 
		 * If \em true is returned calls to getWorldNextPathPoint(), getWorldNextPlaneNormal()
		 * and getWorldDistanceNextPoint() will return non-null/non-0 value.
		 */
		public func bool hasNextPathPoint()
			return this.pPath != null and this.pNextPathPoint < this.pPath.getCount()
		end
		
		/**
		 * \brief Next path point to move to or \em null if the actor is at the goal.
		 * 
		 * If present point is in world space (transformed by relative collider if present).
		 */
		public func DVector getWorldNextPathPoint()
			if this.pNextPathPoint >= this.pPath.getCount()
				return null
			end
			
			var DVector point = this.pPath.getAt( this.pNextPathPoint )
			if this.pRidable != null
				point = this.pRidable.getCollider().getCollider().getMatrix() * point
			end
			return point
		end
		
		/**
		 * \brief Move to next path plane normal or \em null if the actor is at the goal.
		 * 
		 * If present normal is in world space (transformed by relative collider if present).
		 */
		public func DVector getWorldNextPlaneNormal()
			if this.pNextPathPoint >= this.pPath.getCount()
				return null
			end
			
			if this.pRidable != null
				return this.pRidable.getCollider().getCollider().getMatrix().transformNormal( this.pNextPlaneNormal )
				
			else
				return this.pNextPlaneNormal
			end
		end
		
		/**
		 * \brief Distance from actor to next corner if present along normal.
		 * 
		 * Returns 0 if next corner or normal is not present.
		 */
		public func float getWorldDistanceNextPoint()
			if this.pNextPathPoint >= this.pPath.getCount()
				return 0
			end
			
			var DVector point = this.pPath.getAt( this.pNextPathPoint )
			var DVector normal = this.pNextPlaneNormal
			
			if this.pRidable != null
				var DMatrix matrix = this.pRidable.getCollider().getCollider().getMatrix()
				point = matrix * point
				normal = matrix.transformNormal( normal )
			end
			
			return normal * ( point - this.getElement().getPosition() )
		end
		
		
		
		/** \brief Rideable the actor is standing upon or \em null. */
		public func ECBehaviorRidable.Instance getRidable()
			return this.pRidable
		end
		
		/**
		 * \brief Ridable changed.
		 * 
		 * Called by RidableChanged. If overwritten do not forget to super-call.
		 */
		public func void onRidableChanged()
			var ECBehaviorRidable.Instance ridable = this.pRideOn.getRidable()
			var DMatrix matrix = DMatrix.new()
			
			if this.pRidable != null
				matrix = this.pRidable.getCollider().getCollider().getMatrix()
			end
			
			this.pRidable = ridable
			
			if ridable != null
				matrix = matrix * ridable.getCollider().getCollider().getInverseMatrix()
			end
			
			if this.pGoalPosition != null
				this.pGoalPosition = matrix * this.pGoalPosition
			end
			if this.pNextPlaneNormal != null
				this.pNextPlaneNormal = matrix.transformNormal( this.pNextPlaneNormal )
			end
			if this.pPath != null
				this.pPath.transform( matrix )
			end
		end
		
		
		
		/**
		 * \brief Arrive at target.
		 * 
		 * Calls stopMoving() and arrivedAtGoal() on listeners.
		 */
		public func void arrivedAtGoal()
			var DVector goalPosition = this.pGoalPosition
			
			this.stopMoving()
			
			this.pListeners.forEach( block Listener each
				each.arrivedAtGoal( this, goalPosition )
			end )
		end
		
		
		
		/** \brief Update. */
		public func void update( float elapsed )
			if this.pGoalPosition == null or this.pPause or this.pPath == null
				return
			end
			
			var Locomotion locomotion = this.pLocomotion.getLocomotion()
			var DVector actorPosition = this.getElement().getPosition()
			var int pointCount = this.pPath.getCount()
			var DVector nextCorner, nextNextCorner
			var DMatrix matrix, invMatrix
			var DVector nextNormal
			var float distance
			
			if this.pRidable != null
				var Collider collider = this.pRidable.getCollider().getCollider()
				matrix = collider.getMatrix()
				invMatrix = collider.getInverseMatrix()
			end
			
			while this.pGoalPosition != null and not this.pPause
				nextCorner = this.pPath.getAt( this.pNextPathPoint )
				nextNormal = this.pNextPlaneNormal
				if matrix != null
					nextCorner = matrix * nextCorner
					nextNormal = matrix.transformNormal( nextNormal )
				end
				
				distance = nextNormal * ( nextCorner - actorPosition )
				
				// actor is close enough to target
				if this.pRemainingDistance + distance <= this.pGoalDistance
					this.arrivedAtGoal()
					break
				end
				
				// heading for the next path point
				if distance < locomotion.getAbsMovingSpeed() * 0.1   // add option for this
					// sanity check. if the position is more than 1m away from the corner the actor is most probably stuck
					// due to some unholy combination of circumstances. recalculate the path to get out of the mess
// 					if ( nextCorner - position ).getLength() > 1.0
// 						this.pDirtyPath = true
// 						this.update( elapsed )
// 						return
// 					end
					
					// continue with next corner unless we are at the end of the path
					this.pNextPathPoint++
					if this.pNextPathPoint == pointCount
						this.arrivedAtGoal()
						break
					end
					
					// head for the next path point
					nextNextCorner = this.pPath.getAt( this.pNextPathPoint )
					if matrix != null
						nextNextCorner = matrix * nextNextCorner
					end
					
					this.pNextPlaneNormal = ( nextNextCorner - nextCorner ).normalize()
					if invMatrix != null
						this.pNextPlaneNormal = invMatrix.transformNormal( this.pNextPlaneNormal )
					end
					this.pRemainingDistance -= ( nextNextCorner - nextCorner ).getLength()
					
					continue
				end
				
				// move towards next path corner. calls listeners to allow modify the result
				this.moveTowards( nextCorner, elapsed )
				this.pListeners.forEach( block Listener each
					each.modifyMoveTowards( this, nextCorner, elapsed )
				end )
				break
			end
		end
		
		/**
		 * \brief Update locomotion to move towards the next path point.
		 * 
		 * Called by update() as long as the actor is moving.
		 * 
		 * Sets the locomotion to move straight towards the next path point. Adjusts looking,
		 * turning and moving left-right to head for the path point. Adjusts looking up-down
		 * to have the same elevation as the element Y position compared to the next path Y
		 * position.
		 * 
		 * Caller is responsible to allow listeners to modify the result.
		 */
		public func void moveTowards( DVector position, float elapsed )
			var Locomotion locomotion = this.pLocomotion.getLocomotion()
			
			// adjust moving direction towards next corner point
			var DVector moveDirection = position - this.getElement().getPosition()
			var float elevation = moveDirection.getY()
			
			moveDirection = moveDirection.compSelect( true, false, true ).normalize()
			var float targetOrientation = DEMath.atan2( -moveDirection.getX(), moveDirection.getZ() )
			
			locomotion.setLookVerticalGoal( DEMath.atan2( elevation, moveDirection.getLength() ) )
			
			// this limitation of the look left-right goal to angles slightly less than 90
			// degrees prevents the actor from trying to walk backward in cases of sharp
			// turns. it has to be applied after the normalize otherwise the result is wrong
			var float turnAngle = DEMath.normalize( targetOrientation - locomotion.getOrientation(), -180.0, 180.0 )
			if this.pEnableLimitTurnAngle
				turnAngle = DEMath.clamp( turnAngle, -this.pLimitTurnAngle, this.pLimitTurnAngle )
			end
			
			locomotion.setLookHorizontalGoal( turnAngle )
			locomotion.setTurnHorizontal( turnAngle )
			locomotion.setAnalogMovingHorizontalGoal( turnAngle )
			locomotion.setAnalogMovingSpeed( this.pSpeed )
		end
		
		
		
		/** \brief Remaining distance from current position to goal position along path in meters. */
		public func float getDistanceToGoal()
			if this.pGoalPosition == null or this.pPath == null
				return 0
			end
			
			var DVector nextCorner = this.pPath.getAt( this.pNextPathPoint )
			if this.pRidable != null
				nextCorner = this.pRidable.getCollider().getCollider().getMatrix() * nextCorner
			end
			
			return this.pRemainingDistance + ( nextCorner - this.getElement().getPosition() ).getLength()
		end
		
		/** \brief Calculate remaining distance from next path point to goal position along meters. */
		public func void calculateRemainingDistance()
			this.pRemainingDistance = 0
			
			if this.pGoalPosition != null and this.pNextPathPoint < this.pPath.getCount()
				this.pRemainingDistance = this.pPath.getLengthFrom( this.pNextPathPoint )
			end
		end
		
		
		
		/**
		 * \brief Place actor on position relative on remaining path.
		 * \param position Value in range 0 (current position) to 1 (goal position) along path.
		 */
		public func void placeOnPath( float position )
			if this.pGoalPosition == null
				return
			end
			
			var float remainingDistance = this.getDistanceToGoal() * position
			var int pointCount = this.pPath.getCount()
			
			var Locomotion locomotion = this.pLocomotion.getLocomotion()
			var DVector actorPosition = this.getElement().getPosition()
			var DVector nextCorner, nextNextCorner
			var DMatrix matrix, invMatrix
			
			var float targetOrientation = locomotion.getOrientation()
			var DVector orientationDirection
			var float targetVertical = 0
			var DVector moveDirection
			var float elevation
			var float distance
			
			if this.pRidable != null
				var Collider collider = this.pRidable.getCollider().getCollider()
				matrix = collider.getMatrix()
				invMatrix = collider.getInverseMatrix()
			end
			
			var bool hitGoal = false
			while this.pGoalPosition != null and not this.pPause
				nextCorner = this.pPath.getAt( this.pNextPathPoint )
				if matrix != null
					nextCorner = matrix * nextCorner
				end
				
				moveDirection = nextCorner - actorPosition
				distance = moveDirection.getLength()
				elevation = moveDirection.getY()
				
				orientationDirection = moveDirection.compSelect( true, false, true ).normalize()
				targetOrientation = DEMath.atan2( -orientationDirection.getX(), orientationDirection.getZ() )
				targetVertical = DEMath.atan2( elevation, distance )
				
				if remainingDistance < distance
					actorPosition = actorPosition + moveDirection * ( remainingDistance / distance )
				end
				
				if remainingDistance < distance
					break
				end
				
				actorPosition = nextCorner
				remainingDistance -= distance
				
				this.pNextPathPoint++
				if this.pNextPathPoint == pointCount
					hitGoal = true
					break
				end
				
				nextNextCorner = this.pPath.getAt( this.pNextPathPoint )
				if matrix != null
					nextNextCorner = matrix * nextNextCorner
				end
				
				this.pNextPlaneNormal = ( nextNextCorner - nextCorner ).normalize()
				if invMatrix != null
					this.pNextPlaneNormal = invMatrix.transformNormal( this.pNextPlaneNormal )
				end
			end
			
			this.calculateRemainingDistance()
			
			// update the locomotion and actor with the found results
			var float turnAngle = DEMath.normalize( targetOrientation - locomotion.getOrientation(), -180.0, 180.0 )
			if this.pEnableLimitTurnAngle
				turnAngle = DEMath.clamp( turnAngle, -this.pLimitTurnAngle, this.pLimitTurnAngle )
			end
			
			locomotion.setLookVerticalGoal( targetVertical )
			locomotion.setLookHorizontalGoal( turnAngle )
			locomotion.setTurnHorizontal( turnAngle )
			locomotion.setAnalogMovingHorizontalGoal( turnAngle )
			locomotion.setAnalogMovingSpeed( this.pSpeed )
			
			this.getElement().setPosition( actorPosition )
			
			// actor is close enough to target
			if hitGoal
				this.arrivedAtGoal()
				return
			end
			
			nextCorner = this.pPath.getAt( this.pNextPathPoint )
			if matrix != null
				nextCorner = matrix * nextCorner
			end
			
			if this.pRemainingDistance + ( nextCorner - actorPosition ).getLength() <= this.pGoalDistance
				this.arrivedAtGoal()
			end
		end
		
		
		
		/** \brief Add listener. */
		public func void addListener( Listener listener )
			if listener == null
				throw EInvalidParam.new()
			end
			this.pListeners.add( listener )
		end
		
		/** \brief Remove listener. */
		public func void removeListener( Listener listener )
			this.pListeners.remove( listener )
		end
		
		
		
		/** \brief Frame update started. */
		public func void enterFrame()
			if this.pElementResolver != null
				this.pElementResolver.resolve( this.getElement().getGameWorld() )
				this.pElementResolver = null
			end
		end
		
		/** \brief Think about what to do for the next frame update. */
		public func void think( float elapsed )
			this.update( elapsed )
		end
		
		/** \brief Remove element from game world. */
		public func void removeFromGameWorld()
			this.stopMoving()
		end
		
		
		
		/** \brief Read behavior from file. */
		public func void readFromFile( PersistencyEnvironment env, FileReader reader )
			select reader.readByte() // version
			case 0
				var PersistencyFlags flags = PersistencyFlags.new( 6, reader )
				this.pPause = flags.getAt( 0 )
				this.pEnableLimitTurnAngle = flags.getAt( 1 )
				
				if flags.getAt( 2 )
					this.pGoalPosition = DVector.readFromFile( reader )
				end
				this.pGoalDistance = reader.readFloat()
				
				if flags.getAt( 4 )
					this.pPath = NavigatorPath.readFromFile( reader )
				end
				this.pNextPathPoint = reader.readUShort()
				
				if flags.getAt( 3 )
					this.pNextPlaneNormal = DVector.readFromFile( reader )
				end
				this.pRemainingDistance = reader.readFloat()
				
				this.pLimitTurnAngle = reader.readFloat()
				this.pSpeed = reader.readFloat()
				
				if flags.getAt( 5 )
					this.pElementResolver = ElementResolver.new()
					this.pElementResolver.addBehavior( reader, block ECBehaviorRidable.Instance behavior
						this.pRidable = behavior
					end )
					this.setRequiresEnterFrame( true )
				end
				
			else
				throw EInvalidParam.new( "unsupported version" )
			end
		end
		
		/**
		 * \brief Write behavior to file.
		 * 
		 * If relative collider is present the goal position is transformed to world spaces before
		 * being written. The relative collider is not saved. During loading the  base actor is
		 * responsible to restore the relative collider. This has to be done any.
		 */
		public func void writeToFile( PersistencyEnvironment env, FileWriter writer )
			writer.writeByte( 0 ) // version
			
			var PersistencyFlags flags = PersistencyFlags.new( 6 )
			flags.setAt( 0, this.pPause )
			flags.setAt( 1, this.pEnableLimitTurnAngle )
			flags.setAt( 2, this.pGoalPosition != null )
			flags.setAt( 3, this.pNextPlaneNormal != null )
			flags.setAt( 4, this.pPath != null )
			flags.setAt( 5, this.pRidable != null )
			flags.writeToFile( writer )
			
			if this.pGoalPosition != null
				this.pGoalPosition.writeToFile( writer )
			end
			writer.writeFloat( this.pGoalDistance )
			
			if this.pPath != null
				this.pPath.writeToFile( writer )
			end
			writer.writeUShort( this.pNextPathPoint )
			
			if this.pNextPlaneNormal != null
				this.pNextPlaneNormal.writeToFile( writer )
			end
			writer.writeFloat( this.pRemainingDistance )
			
			writer.writeFloat( this.pLimitTurnAngle )
			writer.writeFloat( this.pSpeed )
			
			if this.pRidable != null
				ElementResolver.writeToFileBehavior( writer, this.pRidable )
			end
		end
	end
	
	
	
	private var ECBehaviorLocomotion pLocomotion
	private var ECBehaviorNavigator pNavigator
	private var ECBehaviorRideOn pRideOn
	private var ECBehaviorConversationActor pConversationActor
	private var ECPFloat pSpeed
	private var Array pListenerFactories
	
	
	
	/**
	 * \brief Create behavior element class.
	 * 
	 * These values are optional and can be null: \em rideOn.
	 */
	public func new( BehaviorElementClass eclass, ECBehaviorLocomotion locomotion, \
	ECBehaviorNavigator navigator, ECBehaviorRideOn rideOn ) \
	this( eclass, locomotion, navigator, rideOn, "actorMover." )
	end
	
	public func new( BehaviorElementClass eclass, ECBehaviorLocomotion locomotion, \
	ECBehaviorNavigator navigator, ECBehaviorRideOn rideOn, String prefix ) super( eclass )
		if locomotion == null
			throw ENullPointer.new( "locomotion" )
		end
		if navigator == null
			throw ENullPointer.new( "navigator" )
		end
		
		this.pLocomotion = locomotion
		this.pNavigator = navigator
		this.pRideOn = rideOn
		this.pListenerFactories = Array.new()
		
		this.pSpeed = ECPFloat.new( prefix + "speed", 1.25, 0 )
		eclass.addProperty( this.pSpeed )
		
		eclass.addBehavior( this )
	end
	
	/** \brief Dispose of behavior. */
	public func void dispose()
		this.pRideOn = null
		this.pNavigator = null
		this.pLocomotion = null
		this.pConversationActor = null
		this.pListenerFactories = null
		super.dispose()
	end
	
	
	
	/** \brief Locomotion behavior to use. */
	public func ECBehaviorLocomotion getLocomotion()
		return this.pLocomotion
	end
	
	/** \brief Navigator behavior to use. */
	public func ECBehaviorNavigator getNavigator()
		return this.pNavigator
	end
	
	/** \brief Ride on behavior to use or null. */
	public func ECBehaviorRideOn getRideOn()
		return this.pRideOn
	end
	
	/** \brief Conversation actor behavior or null. */
	public func ECBehaviorConversationActor getConversationActor()
		return this.pConversationActor
	end
	
	/**
	 * \brief Set conversation actor or null.
	 * 
	 * If set conversation conditions and commands are added.
	 */
	public func void setConversationActor( ECBehaviorConversationActor conversationActor )
		this.pConversationActor = conversationActor
	end
	
	/** \brief Movement speed. */
	public func ECPFloat getSpeed()
		return this.pSpeed
	end
	
	/** \brief Add listener factory. */
	public func void addListenerFactory( ListenerFactory factory )
		if factory == null
			throw ENullPointer.new()
		end
		this.pListenerFactories.add( factory )
	end
	
	/**
	 * \brief Add listener factory using block.
	 * 
	 * Block receives as parameter Instance and returns Listener.
	 */
	public func void addListenerFactory( Block blockFactory )
		this.pListenerFactories.add( BlockListenerFactory.new( blockFactory ) )
	end
	
	/** \brief Visit listener factories with block with argument ListenerFactory. */
	public func void forEachListenerFactory( Block ablock )
		this.pListenerFactories.forEach( ablock )
	end
	
	/** \brief Create listeners from factories adding them to behavior instance. */
	public func void createListeners( Instance instance )
		this.pListenerFactories.forEach( block ListenerFactory each
			instance.addListener( each.createListener( instance ) )
		end )
	end
	
	
	
	/** \brief Get instance in element from owner element class. */
	public func Instance instance( BehaviorElement element )
		return element.getInstanceAt( this.getInstanceIndex() ) cast Instance
	end
	
	
	
	/**
	 * \brief Get behavior in element class or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElementClass contains a behavior
	 * of type ECBehaviorActorMover.
	 */
	static public func ECBehaviorActorMover getBehaviorIn( BehaviorElementClass eclass )
		return eclass.findBehavior( block ECBehavior each
			return each castable ECBehaviorActorMover
		end ) cast ECBehaviorActorMover
	end
	
	/**
	 * \brief Get instance in element or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElement contains a behavior instance
	 * of type ECBehaviorActorMover.Instance .
	 */
	static public func Instance getInstanceIn( BehaviorElement element )
		return element.findInstance( block ECBehaviorInstance each
			return each castable Instance
		end ) cast Instance
	end
	
	
	
	/** \brief Create Behavior instance. */
	public func ECBehaviorInstance createInstance( BehaviorElement element )
		return Instance.new( this, element )
	end
end
