/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Scenery

pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Utils


/**
 * \brief Behavior element behavior adding moving player input.
 * 
 * Keeps track of moving player input and applies them to actor locomotion. The type of
 * locomotion can be set to one of three typical configurations.
 * 
 * This behavior can be used for human actor and vehicle movement.
 * 
 * This behavior supports persistable element class (setPersistable).
 */
class ECBehaviorPlayerInputMove extends DefaultECBehavior
	/** \brief Locomotion type. */
	public enum LocomotionType
		/**
		 * Default locomotion working best for actors moving in a natural way. The actor
		 * moves into the direction it is looking. The body is oriented into the walking
		 * direction if the actor is moving.
		 * 
		 * Interferes with ECBehaviorPlayerInputTurn since both behaviors modify the locomotion
		 * turning value.
		 */
		natural
		
		/**
		 * Configuration useful for FPS type games where the actor is always oriented into
		 * the direction the player is looking. This configuration typically uses an
		 * 8-direction animator representing the actor moving into any direction relative to
		 * the looking direction.
		 * 
		 * Interferes with ECBehaviorPlayerInputTurn since both behaviors modify the locomotion
		 * turning value.
		 */
		fps
		
		/**
		 * Configuration useful for vehicle type actors like tanks which move into the
		 * direction their body is oriented while allowing to freely look around.
		 * 
		 * Does not interfere with ECBehaviorPlayerInputTurn since this behavior does not
		 * modify the locomotion turning value.
		 */
		vehicle
	end
	
	/**
	 * \brief Behavior factory.
	 * \ref 1.25
	 * 
	 * Automatically assigns these behaviors if present before adding:
	 * - Optional: \ref ECBehaviorLocomotion
	 * 
	 * Example XML element class:
	 * \code{.xml}
	 * <behavior type='ECBehaviorPlayerInputMove'/>
	 * \endcode
	 * 
	 * Element class properties added by the behavior can also be set directly inside the tag
	 * be removing the property name prefix and starting with a "." (for exampler ".propertyName").
	 */
	class Factory implements BehaviorFactory
		func new()
		end
		
		func String factoryId()
			return "ECBehaviorPlayerInputMove"
		end
		
		func ECBehavior addBehavior(BehaviorElementClass eclass, String id, Dictionary parameters)
			if not id.empty()
				throw EInvalidParam.new("id is not empty string")
			end
			var ECBehaviorPlayerInputMove behavior = ECBehaviorPlayerInputMove.new(\
				eclass, ECBehaviorLocomotion.getBehaviorIn(eclass))
			BehaviorElementClass.sharedFactoryHelper.setPropertiesFromParameters(\
				eclass, parameters, "playerInputMove")
			return behavior
		end
	end
	
	/** \brief Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		var ECBehaviorPlayerInputMove pECBehavior
		var ECBehaviorLocomotion.Instance pLocomotion
		
		var LocomotionType pLocomotionType
		
		var bool pMoveForward
		var bool pMoveBackward
		var bool pMoveLeft
		var bool pMoveRight
		var float pAnalogMoveForwardBackward
		var float pAnalogMoveLeftRight
		var float pAnalogMoveForwardBackwardSticky
		var float pAnalogMoveLeftRightSticky
		var bool pCanMove
		
		var bool pRun
		var float pSpeedWalk
		var float pSpeedFactorWalkForward
		var float pSpeedFactorWalkBackward
		var float pSpeedFactorWalkLeft
		var float pSpeedFactorWalkRight
		var float pSpeedRun
		var float pSpeedFactorRunForward
		var float pSpeedFactorRunBackward
		var float pSpeedFactorRunLeft
		var float pSpeedFactorRunRight
		
		var float pMovingDirection
		var float pMovingBodyTurn
		var float pMovingSpeed
		
		
		
		/** \brief Create instance. */
		func new(ECBehaviorPlayerInputMove ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			
			pLocomotionType = LocomotionType.natural
			pCanMove = true
			
			pSpeedFactorWalkForward = 1
			pSpeedFactorWalkBackward = 1
			pSpeedFactorWalkLeft = 1
			pSpeedFactorWalkRight = 1
			
			pSpeedFactorRunForward = 1
			pSpeedFactorRunBackward = 1
			pSpeedFactorRunLeft = 1
			pSpeedFactorRunRight = 1
		end
		
		/** \brief Dispose of instance. */
		func void dispose()
			pLocomotion = null
			super.dispose()
		end
		
		
		
		/** \brief Initialize element from stub. */
		func void init(StubElement stub)
			if pECBehavior.getLocomotion() != null
				pLocomotion = pECBehavior.getLocomotion().instance(getElement())
			end
			
			pSpeedWalk = pECBehavior.getSpeedWalk().getValue(stub)
			pSpeedFactorWalkForward = pECBehavior.getSpeedFactorWalkForward().getValue(stub)
			pSpeedFactorWalkBackward = pECBehavior.getSpeedFactorWalkBackward().getValue(stub)
			pSpeedFactorWalkLeft = pECBehavior.getSpeedFactorWalkLeft().getValue(stub)
			pSpeedFactorWalkRight = pECBehavior.getSpeedFactorWalkRight().getValue(stub)
			
			pSpeedRun = pECBehavior.getSpeedRun().getValue(stub)
			pSpeedFactorRunForward = pECBehavior.getSpeedFactorRunForward().getValue(stub)
			pSpeedFactorRunBackward = pECBehavior.getSpeedFactorRunBackward().getValue(stub)
			pSpeedFactorRunLeft = pECBehavior.getSpeedFactorRunLeft().getValue(stub)
			pSpeedFactorRunRight = pECBehavior.getSpeedFactorRunRight().getValue(stub)
		end
		
		
		
		/** \brief Behavior. */
		func ECBehaviorPlayerInputMove getECBehavior()
			return pECBehavior
		end
		
		/** \brief Locomotion behavior or null if absent. */
		func ECBehaviorLocomotion.Instance getLocomotion()
			return pLocomotion
		end
		
		
		
		/** \brief Locomotion type. */
		func LocomotionType getLocomotionType()
			return pLocomotionType
		end
		
		/** \brief Set locomotion type. */
		func void setLocomotionType(LocomotionType type)
			pLocomotionType = type
		end
		
		
		
		/** \brief Move forward key is pressed. */
		func bool getMoveForward()
			return pMoveForward
		end
		
		/** \brief Set if move forward key is pressed. */
		func void setMoveForward(bool pressed)
			pMoveForward = pressed
		end
		
		/** \brief Toggle move forward key pressed. */
		func void toggleMoveForward()
			pMoveForward = not pMoveForward
		end
		
		/** \brief Move backward key is pressed. */
		func bool getMoveBackward()
			return pMoveBackward
		end
		
		/** \brief Set if move backward key is pressed. */
		func void setMoveBackward(bool pressed)
			pMoveBackward = pressed
		end
		
		/** \brief Toggle move backward key pressed. */
		func void toggleMoveBackward()
			pMoveBackward = not pMoveBackward
		end
		
		/** \brief Move left key is pressed. */
		func bool getMoveLeft()
			return pMoveLeft
		end
		
		/** \brief Set if move left key is pressed. */
		func void setMoveLeft(bool pressed)
			pMoveLeft = pressed
		end
		
		/** \brief Toggle move left key pressed. */
		func void toggleMoveLeft()
			pMoveLeft = not pMoveLeft
		end
		
		/** \brief Move right key is pressed. */
		func bool getMoveRight()
			return pMoveRight
		end
		
		/** \brief Set if move right key is pressed. */
		func void setMoveRight(bool pressed)
			pMoveRight = pressed
		end
		
		/** \brief Toggle move right key pressed. */
		func void toggleMoveRight()
			pMoveRight = not pMoveRight
		end
		
		/** \brief Analog move forward backward. */
		func float getAnalogMoveForwardBackward()
			return pAnalogMoveForwardBackward
		end
		
		/** \brief Set analog move forward backward. */
		func void setAnalogMoveForwardBackward(float value)
			pAnalogMoveForwardBackward = value
		end
		
		/** \brief Analog move left right. */
		func float getAnalogMoveLeftRight()
			return pAnalogMoveLeftRight
		end
		
		/** \brief Set analog move left right. */
		func void setAnalogMoveLeftRight(float value)
			pAnalogMoveLeftRight = value
		end
		
		/** \brief Sticky analog move forward backward. */
		func float getAnalogMoveForwardBackwardSticky()
			return pAnalogMoveForwardBackwardSticky
		end
		
		/** \brief Set sticky analog move forward backward. */
		func void setAnalogMoveForwardBackwardSticky(float value)
			pAnalogMoveForwardBackwardSticky = value
		end
		
		/** \brief Sticky analog move left right. */
		func float getAnalogMoveLeftRightSticky()
			return pAnalogMoveLeftRightSticky
		end
		
		/** \brief Set sticky analog move left right. */
		func void setAnalogMoveLeftRightSticky(float value)
			pAnalogMoveLeftRightSticky = value
		end
		
		/** \brief Player can move. */
		func bool getCanMove()
			return pCanMove
		end
		
		/** \brief Set if player can move. */
		func void setCanMove(bool canMove)
			pCanMove = canMove
		end
		
		/** \brief Toggle can move. */
		func void toggleCanMove()
			pCanMove = not pCanMove
		end
		
		/** \brief Player is moving. */
		func bool isMoving()
			return pCanMove and (pMoveForward or pMoveBackward \
				or pMoveLeft or pMoveRight \
				or DEMath.fabs(pAnalogMoveForwardBackward) > 0.01 \
				or DEMath.fabs(pAnalogMoveForwardBackwardSticky) > 0.01)
		end
		
		
		
		/** \brief Run key is pressed. */
		func bool getRun()
			return pRun
		end
		
		/** \brief Set if run key is pressed. */
		func void setRun(bool pressed)
			pRun = pressed
			updateMovingSpeed()
		end
		
		/** \brief Toggle run key pressed. */
		func void toggleRun()
			pRun = not pRun
			updateMovingSpeed()
		end
		
		
		
		/** \brief Walk speed. */
		func float getSpeedWalk()
			return pSpeedWalk
		end
		
		/** \brief Set walk speed. */
		func void setSpeedWalk(float speed)
			pSpeedWalk = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		/** \brief Speed factor Walk forward. */
		func float getSpeedFactorWalkForward()
			return pSpeedFactorWalkForward
		end
		
		/** \brief Set speed factor walk forward. */
		func void setSpeedFactorWalkForward(float speed)
			pSpeedFactorWalkForward = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		/** \brief Speed factor walk backward. */
		func float getSpeedFactorWalkBackward()
			return pSpeedFactorWalkBackward
		end
		
		/** \brief Set speed factor walk backward. */
		func void setSpeedFactorWalkBackward(float speed)
			pSpeedFactorWalkBackward = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		/** \brief Speed factor walk left. */
		func float getSpeedFactorWalkLeft()
			return pSpeedFactorWalkLeft
		end
		
		/** \brief Set speed factor walk left. */
		func void setSpeedFactorWalkLeft(float speed)
			pSpeedFactorWalkLeft = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		/** \brief Speed factor walk right. */
		func float getSpeedFactorWalkRight()
			return pSpeedFactorWalkRight
		end
		
		/** \brief Set speed factor walk right. */
		func void setSpeedFactorWalkRight(float speed)
			pSpeedFactorWalkRight = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		
		
		/** \brief Run speed. */
		func float getSpeedRun()
			return pSpeedRun
		end
		
		/** \brief Set run speed. */
		func void setSpeedRun(float speed)
			pSpeedRun = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		/** \brief Speed factor run forward. */
		func float getSpeedFactorRunForward()
			return pSpeedFactorRunForward
		end
		
		/** \brief Set speed factor walk forward. */
		func void setSpeedFactorRunForward(float speed)
			pSpeedFactorRunForward = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		/** \brief Speed factor run backward. */
		func float getSpeedFactorRunBackward()
			return pSpeedFactorRunBackward
		end
		
		/** \brief Set speed factor walk backward. */
		func void setSpeedFactorRunBackward(float speed)
			pSpeedFactorRunBackward = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		/** \brief Speed factor run left. */
		func float getSpeedFactorRunLeft()
			return pSpeedFactorRunLeft
		end
		
		/** \brief Set speed factor walk left. */
		func void setSpeedFactorRunLeft(float speed)
			pSpeedFactorRunLeft = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		/** \brief Speed factor run right. */
		func float getSpeedFactorRunRight()
			return pSpeedFactorRunRight
		end
		
		/** \brief Set speed factor walk right. */
		func void setSpeedFactorRunRight(float speed)
			pSpeedFactorRunRight = DEMath.max(speed, 0.0)
			updateMovingSpeed()
		end
		
		
		
		/** \brief Reset input. */
		func void reset()
			pMoveForward = false
			pMoveBackward = false
			pMoveLeft = false
			pMoveRight = false
			pAnalogMoveForwardBackward = 0
			pAnalogMoveLeftRight = 0
			pAnalogMoveForwardBackwardSticky = 0
			pAnalogMoveLeftRightSticky = 0
			pMovingDirection = 0
			pMovingBodyTurn = 0
			pMovingSpeed = 0
		end
		
		/**
		 * \brief Reset analog input.
		 * \version 1.20
		 */
		func void resetAnalog()
			pAnalogMoveForwardBackward = 0
			pAnalogMoveLeftRight = 0
			pAnalogMoveForwardBackwardSticky = 0
			pAnalogMoveLeftRightSticky = 0
		end
		
		
		/** \brief Locomotion moving direction. */
		func float getMovingDirection()
			return pMovingDirection
		end
		
		/** \brief Set locomotion moving direction. */
		func void setMovingDirection(float direction)
			pMovingDirection = DEMath.normalize(direction, -180.0, 180.0)
		end
		
		/** \brief Locomotion moving speed. */
		func float getMovingSpeed()
			return pMovingSpeed
		end
		
		/** \brief Set locomotion moving speed. */
		func void setMovingSpeed(float speed)
			pMovingSpeed = speed
		end
		
		
		
		/** \brief Calculate moving direction. */
		func float calculateMovingDirection()
			// movement using analog input
			var float analogFB = pAnalogMoveForwardBackward + pAnalogMoveForwardBackwardSticky
			var float analogLR = pAnalogMoveLeftRight + pAnalogMoveLeftRightSticky
			var bool hasMovingDirectionAnalog = false
			var float movingDirectionAnalog = 0
			
			if DEMath.fabs(analogFB) > 0.01 or DEMath.fabs(analogLR) > 0
				movingDirectionAnalog = DEMath.atan2(-analogLR, analogFB)
				hasMovingDirectionAnalog = true
			end
			
			// movement using digital input
			var bool hasMovingDirectionDigital = false
			var float movingDirectionDigital = 0
			
			if pMoveForward
				if pMoveLeft
					movingDirectionDigital = 45
					
				elif pMoveRight
					movingDirectionDigital = -45
				end
				hasMovingDirectionDigital = true
				
			elif pMoveBackward
				if pMoveLeft
					movingDirectionDigital = 135
					
				elif pMoveRight
					movingDirectionDigital = -135
					
				else
					movingDirectionDigital = 180
				end
				hasMovingDirectionDigital = true
				
			elif pMoveLeft
				movingDirectionDigital = 90
				hasMovingDirectionDigital = true
				
			elif pMoveRight
				movingDirectionDigital = -90
				hasMovingDirectionDigital = true
			end
			
			// combine moving speeds
			if hasMovingDirectionAnalog and hasMovingDirectionDigital
				return (movingDirectionDigital + movingDirectionAnalog) * 0.5
				
			elif hasMovingDirectionAnalog
				return movingDirectionAnalog
				
			elif hasMovingDirectionDigital
				return movingDirectionDigital
				
			else
				return 0
			end
		end
		
		/** \brief Calculate moving speed. */
		func float calculateMovingSpeed()
			if not pCanMove
				return 0
			end
			
			// analog movement
			var float analogFB = pAnalogMoveForwardBackward + pAnalogMoveForwardBackwardSticky
			var float analogLR = pAnalogMoveLeftRight + pAnalogMoveLeftRightSticky
			var float movingSpeedAnalog = Vector2.new(analogFB, analogLR).getLength()
			
			if DEMath.fabs(movingSpeedAnalog) > 0.001
				var float orientation = DEMath.atan2(-analogLR, analogFB)
				
				if orientation < -90
					movingSpeedAnalog *= DEMath.linearStep(orientation, -180.0, -90.0, \
						pSpeedFactorRunBackward, pSpeedFactorRunRight)
					
				elif orientation < 0
					movingSpeedAnalog *= DEMath.linearStep(orientation, -90.0, 0.0, \
						pSpeedFactorRunRight, pSpeedFactorRunForward)
					
				elif orientation < 90
					movingSpeedAnalog *= DEMath.linearStep(orientation, 0.0, 90.0, \
						pSpeedFactorRunForward, pSpeedFactorRunLeft)
					
				else
					movingSpeedAnalog *= DEMath.linearStep(orientation, 90.0, 180.0, \
						pSpeedFactorRunLeft, pSpeedFactorRunBackward)
				end
				
				movingSpeedAnalog *= pSpeedRun
				
			else
				movingSpeedAnalog = 0
			end
			
			// digital movement
			var float movingSpeedDigital = 0
			
			if pRun
				if pMoveForward
					if pMoveLeft
						movingSpeedDigital = pSpeedRun * (pSpeedFactorRunForward + pSpeedFactorRunLeft) * 0.5
						
					elif pMoveRight
						movingSpeedDigital = pSpeedRun * (pSpeedFactorRunForward + pSpeedFactorRunRight) * 0.5
						
					else
						movingSpeedDigital = pSpeedRun * pSpeedFactorRunForward
					end
					
				elif pMoveBackward
					if pMoveLeft
						movingSpeedDigital = pSpeedRun * (pSpeedFactorRunBackward + pSpeedFactorRunLeft) * 0.5
						
					elif pMoveRight
						movingSpeedDigital = pSpeedRun * (pSpeedFactorRunBackward + pSpeedFactorRunRight) * 0.5
						
					else
						movingSpeedDigital = pSpeedRun * pSpeedFactorRunBackward
					end
					
				elif pMoveLeft
					movingSpeedDigital = pSpeedRun * pSpeedFactorRunLeft
					
				elif pMoveRight
					movingSpeedDigital = pSpeedRun * pSpeedFactorRunRight
				end
				
			else
				if pMoveForward
					if pMoveLeft
						movingSpeedDigital = pSpeedWalk * (pSpeedFactorWalkForward + pSpeedFactorWalkLeft) * 0.5
						
					elif pMoveRight
						movingSpeedDigital = pSpeedWalk * (pSpeedFactorWalkForward + pSpeedFactorWalkRight) * 0.5
						
					else
						movingSpeedDigital = pSpeedWalk * pSpeedFactorWalkForward
					end
					
				elif pMoveBackward
					if pMoveLeft
						movingSpeedDigital = pSpeedWalk * (pSpeedFactorWalkBackward + pSpeedFactorWalkLeft) * 0.5
						
					elif pMoveRight
						movingSpeedDigital = pSpeedWalk * (pSpeedFactorWalkBackward + pSpeedFactorWalkRight) * 0.5
						
					else
						movingSpeedDigital = pSpeedWalk * pSpeedFactorWalkBackward
					end
					
				elif pMoveLeft
					movingSpeedDigital = pSpeedWalk * pSpeedFactorWalkLeft
					
				elif pMoveRight
					movingSpeedDigital = pSpeedWalk * pSpeedFactorWalkRight
				end
			end
			
			// combine moving speeds
			return DEMath.max(movingSpeedDigital, movingSpeedAnalog)
		end
		
		
		
		
		/** \brief Update moving direction and moving body turn. */
		func void updateMovingDirection()
			pMovingDirection = calculateMovingDirection()
			
			// body turn
			if isMoving()
				// slightly larger than 90 degrees required to get normalizing affecting only
				// moving orientations pointing strictly backward
				pMovingBodyTurn = DEMath.normalize(pMovingDirection, -90.1, 90.1)
				
			else
				pMovingBodyTurn = 0
			end
		end
		
		/** \brief Update moving speed. */
		func void updateMovingSpeed()
			pMovingSpeed = calculateMovingSpeed()
		end
		
		/**
		 * \brief Update locomotion.
		 */
		func void updateLocomotion(float elapsed)
			updateMovingDirection()
			updateMovingSpeed()
			
			pAnalogMoveForwardBackward = 0
			pAnalogMoveLeftRight = 0
			
			if pLocomotion == null
				return
			end
			
			var Locomotion locomotion = pLocomotion.getLocomotion()
			locomotion.setAnalogMovingSpeed(pMovingSpeed)
			
			select pLocomotionType
			case LocomotionType.natural
				locomotion.setAnalogMovingHorizontalGoal(pMovingDirection + locomotion.getLookHorizontalGoal())
				if pMovingSpeed > 0.001 or not locomotion.getCanTurnInPlace()
					locomotion.setTurnHorizontal(locomotion.getLookHorizontalGoal() + pMovingBodyTurn)
					
				else
					locomotion.setTurnHorizontal(0)
				end
				
			case LocomotionType.fps
				locomotion.setAnalogMovingHorizontalGoal(pMovingDirection)
				locomotion.setTurnHorizontal(locomotion.getLookHorizontalGoal())
				
			case LocomotionType.vehicle
				locomotion.setAnalogMovingHorizontalGoal(pMovingDirection)
			end
		end
		
		
		
		/** \brief Read element from file. */
		func void readFromFile(PersistencyEnvironment env, FileReader reader)
			select reader.readByte() // version
			case 0
				var PersistencyFlags flags = PersistencyFlags.new(2, reader)
				pCanMove = flags.getAt(0)
				pRun = flags.getAt(1)
				
				pLocomotionType = LocomotionType.withOrder(reader.readByte())
				
				pSpeedWalk = reader.readFloat()
				pSpeedFactorWalkForward = reader.readFloat()
				pSpeedFactorWalkBackward = reader.readFloat()
				pSpeedFactorWalkLeft = reader.readFloat()
				pSpeedFactorWalkRight = reader.readFloat()
				
				pSpeedRun = reader.readFloat()
				pSpeedFactorRunForward = reader.readFloat()
				pSpeedFactorRunBackward = reader.readFloat()
				pSpeedFactorRunLeft = reader.readFloat()
				pSpeedFactorRunRight = reader.readFloat()
				
			else
				throw EInvalidParam.new("unsupported version")
			end
		end
		
		/** \brief Write element to file. */
		func void writeToFile(PersistencyEnvironment env, FileWriter writer)
			writer.writeByte(0) // version
			
			var PersistencyFlags flags = PersistencyFlags.new(2)
			flags.setAt(0, pCanMove)
			flags.setAt(1, pRun)
			flags.writeToFile(writer)
			
			writer.writeByte(pLocomotionType.order())
			
			writer.writeFloat(pSpeedWalk)
			writer.writeFloat(pSpeedFactorWalkForward)
			writer.writeFloat(pSpeedFactorWalkBackward)
			writer.writeFloat(pSpeedFactorWalkLeft)
			writer.writeFloat(pSpeedFactorWalkRight)
			
			writer.writeFloat(pSpeedRun)
			writer.writeFloat(pSpeedFactorRunForward)
			writer.writeFloat(pSpeedFactorRunBackward)
			writer.writeFloat(pSpeedFactorRunLeft)
			writer.writeFloat(pSpeedFactorRunRight)
		end
	end
	
	
	
	var ECBehaviorLocomotion pLocomotion
	var ECPFloat pSpeedWalk
	var ECPFloat pSpeedRun
	var ECPFloat pSpeedFactorWalkForward
	var ECPFloat pSpeedFactorWalkBackward
	var ECPFloat pSpeedFactorWalkLeft
	var ECPFloat pSpeedFactorWalkRight
	var ECPFloat pSpeedFactorRunForward
	var ECPFloat pSpeedFactorRunBackward
	var ECPFloat pSpeedFactorRunLeft
	var ECPFloat pSpeedFactorRunRight
	
	
	
	/** \brief Create behavior element class. */
	func new(BehaviorElementClass eclass, ECBehaviorLocomotion locomotion) \
	this(eclass, locomotion, "playerInputMove.")
	end
	
	func new(BehaviorElementClass eclass, ECBehaviorLocomotion locomotion, \
	String prefix) super(eclass)
		if getBehaviorIn(eclass) != null
			throw BEMultipleInstanceException.new(eclass, this)
		end
		
		pLocomotion = locomotion
		
		pSpeedWalk = ECPFloat.new(prefix + "speedWalk", 1.25, 0)
		eclass.addProperty(pSpeedWalk)
		
		pSpeedRun = ECPFloat.new(prefix + "speedRun", 4, 0)
		eclass.addProperty(pSpeedRun)
		
		pSpeedFactorWalkForward = ECPFloat.new(prefix + "speedFactorWalkForward", 1, 0)
		eclass.addProperty(pSpeedFactorWalkForward)
		
		pSpeedFactorWalkBackward = ECPFloat.new(prefix + "speedFactorWalkBackward", 1, 0)
		eclass.addProperty(pSpeedFactorWalkBackward)
		
		pSpeedFactorWalkLeft = ECPFloat.new(prefix + "speedFactorWalkLeft", 1, 0)
		eclass.addProperty(pSpeedFactorWalkLeft)
		
		pSpeedFactorWalkRight = ECPFloat.new(prefix + "speedFactorWalkRight", 1, 0)
		eclass.addProperty(pSpeedFactorWalkRight)
		
		pSpeedFactorRunForward = ECPFloat.new(prefix + "speedFactorRunForward", 1, 0)
		eclass.addProperty(pSpeedFactorRunForward)
		
		pSpeedFactorRunBackward = ECPFloat.new(prefix + "speedFactorRunBackward", 1, 0)
		eclass.addProperty(pSpeedFactorRunBackward)
		
		pSpeedFactorRunLeft = ECPFloat.new(prefix + "speedFactorRunLeft", 1, 0)
		eclass.addProperty(pSpeedFactorRunLeft)
		
		pSpeedFactorRunRight = ECPFloat.new(prefix + "speedFactorRunRight", 1, 0)
		eclass.addProperty(pSpeedFactorRunRight)
		
		eclass.addBehavior(this)
	end
	
	/** \brief Dispose of behavior. */
	func void dispose()
		pLocomotion = null
		super.dispose()
	end
	
	
	
	/** \brief Locomotion behavior or null. */
	func ECBehaviorLocomotion getLocomotion()
		return pLocomotion
	end
	
	/** \brief Walk speed. */
	func ECPFloat getSpeedWalk()
		return pSpeedWalk
	end
	
	/** \brief Run speed. */
	func ECPFloat getSpeedRun()
		return pSpeedRun
	end
	
	/** \brief Speed factor Walk forward. */
	func ECPFloat getSpeedFactorWalkForward()
		return pSpeedFactorWalkForward
	end
	
	/** \brief Speed factor walk backward. */
	func ECPFloat getSpeedFactorWalkBackward()
		return pSpeedFactorWalkBackward
	end
	
	/** \brief Speed factor walk left. */
	func ECPFloat getSpeedFactorWalkLeft()
		return pSpeedFactorWalkLeft
	end
	
	/** \brief Speed factor walk right. */
	func ECPFloat getSpeedFactorWalkRight()
		return pSpeedFactorWalkRight
	end
	
	/** \brief Speed factor Run forward. */
	func ECPFloat getSpeedFactorRunForward()
		return pSpeedFactorRunForward
	end
	
	/** \brief Speed factor run backward. */
	func ECPFloat getSpeedFactorRunBackward()
		return pSpeedFactorRunBackward
	end
	
	/** \brief Speed factor run left. */
	func ECPFloat getSpeedFactorRunLeft()
		return pSpeedFactorRunLeft
	end
	
	/** \brief Speed factor run right. */
	func ECPFloat getSpeedFactorRunRight()
		return pSpeedFactorRunRight
	end
	
	
	
	/** \brief Get instance in element from owner element class. */
	func Instance instance(BehaviorElement element)
		return element.getInstanceAt(getInstanceIndex()) cast Instance
	end
	
	
	
	/**
	 * \brief Get behavior in element class or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElementClass contains a behavior
	 * of type ECBehaviorPlayerInputMove.
	 */
	static func ECBehaviorPlayerInputMove getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block ECBehaviorPlayerInputMove each
			return true
		end) cast ECBehaviorPlayerInputMove
	end
	
	/**
	 * \brief Get instance in element or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElement contains a behavior instance
	 * of type ECBehaviorPlayerInputMove.Instance .
	 */
	static func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	
	
	/** \brief Create Behavior instance. */
	func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
