/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Scenery

pin Dragengine.ConversationSystem
pin Dragengine.Preloading
pin Dragengine.LoadSave
pin Dragengine.Utils


/**
 * \brief Base actor action aligning actors using ECBehaviorAlignActor.
 * 
 * This class is a typical transition action. Upon activating the ECBehaviorAlignActor is
 * set up and aligning started. While aligning is running no locomotion update is allowed
 * since all is done by ECBehaviorAlignActor. Once finished a previously set BaseActorAction
 * is activated and the transition ends.
 * 
 * Use this class if you need to align one or more of these actor parameters:
 * - Actor position
 * - Actor orientation
 * - Locomotion look up-down
 * - Locomotion look left-right
 * - Locomotion stance changing
 * 
 * This is typically the case if an actor needs to be in a specifi position and orientation
 * to match animation with another game world element.
 */
class BAAAlignActor extends BaseActorAction
	/** \brief Factory for loading actor actions. */
	public class Factory implements PersistencyFactory
		public static fixed var String NAME = "BAAAlignActor"
		
		public func new()
		end
		
		public func Persistable readObjectFromFile( PersistencyEnvironment env, FileReader reader )
			return BAAAlignActor.new( env, reader )
		end
		
		public static func void registerFactory( Persistency persistency )
			persistency.addFactory( NAME, Factory.new() )
		end
	end
	
	
	
	private var BaseActorAction pActionSucceeded
	private var BaseActorAction pActionFailed
	private var DVector pTargetPosition
	private var float pTargetOrientation
	private var float pTargetLookVertical
	private var ConversationPlaybackLookAt pLookAt
	private var Element pRelativeTargetElement
	private var DMatrix pRelativeTargetMatrix
	private var bool pCallAIFinished
	private var ElementResolver pElementResolver
	
	/** \brief Align actor behavior. */
	protected var ECBehaviorAlignActor.Instance alignActor
	
	/** \brief Actor mover behavior. */
	protected var ECBehaviorActorMover.Instance actorMover
	
	/** \brief Player input looking around behavior. */
	protected var ECBehaviorPlayerInputLook.Instance playerInputLook
	
	/** \brief Player input crouching behavior. */
	protected var ECBehaviorPlayerInputCrouch.Instance playerInputCrouch
	
	/** \brief Player input moving behavior. */
	protected var ECBehaviorPlayerInputMove.Instance playerInputMove
	
	
	
	/**
	 * \brief Create align actor action.
	 * \param succeeded Action to switch to if aligning finished or failed.
	 */
	public func new( BaseActorAction succeeded ) this( succeeded, succeeded )
	end
	
	/**
	 * \brief Create align actor action.
	 * \param succeeded Action to switch to if aligning succeeded.
	 * \param failed Action to switch to if aligning failed.
	 */
	public func new( BaseActorAction succeeded, BaseActorAction failed )
		if succeeded == null
			throw EInvalidParam.new( "succeeded is null" )
		end
		if failed == null
			throw EInvalidParam.new( "failed is null" )
		end
		
		this.pActionSucceeded = succeeded
		this.pActionFailed = failed
		this.pCallAIFinished = true
	end
	
	/** \brief Create align actor action from persisted state. */
	public func new( PersistencyEnvironment env, FileReader reader )
		select reader.readByte() // version
		case 0
			var PersistencyFlags flags = PersistencyFlags.new( 3, reader )
			this.pCallAIFinished = flags.getAt( 0 )
			
			this.pTargetPosition = DVector.readFromFile( reader )
			this.pTargetOrientation = reader.readFloat()
			this.pTargetLookVertical = reader.readFloat()
			
			if flags.getAt( 1 )
				this.pElementResolver = ElementResolver.new()
				this.pElementResolver.add( reader, block Element element
					this.pRelativeTargetElement = element
				end )
			end
			
			if flags.getAt( 2 )
				this.pLookAt = ConversationPlaybackLookAt.readFromFile( env, reader )
			end
			
			this.pActionSucceeded = env.readObjectOrNull( reader ) cast BaseActorAction
			this.pActionFailed = env.readObjectOrNull( reader ) cast BaseActorAction
			
		else
			throw EInvalidParam.new( "unsupported version" )
		end
	end
	
	
	
	/** \brief Target position. */
	public func DVector getTargetPosition()
		return this.pTargetPosition
	end
	
	/** \brief Set target position. */
	public func void setTargetPosition( DVector position )
		this.pTargetPosition = position
	end
	
	/** \brief Target orientation. */
	public func float getTargetOrientation()
		return this.pTargetOrientation
	end
	
	/** \brief Set target orientation. */
	public func void setTargetOrientation( float orientation )
		this.pTargetOrientation = DEMath.normalize( orientation, -180.0, 180.0 )
	end
	
	/** \brief Set target orientation. */
	public func void setTargetOrientation( DVector targetPosition )
		var DVector direction = targetPosition - actor.getPosition()
		this.pTargetOrientation = -DEMath.atan2( direction.getX(), direction.getZ() )
	end
	
	/** \brief Relative target element. */
	public func Element getRelativeTargetElement()
		return this.pRelativeTargetElement
	end
	
	/** \brief Set relative target position. */
	public func void setRelativeTargetElement( Element element )
		this.pRelativeTargetElement = element
	end
	
	/** \brief Set target. */
	public func void setTarget( Element element, DVector position, float orientation )
		this.setRelativeTargetElement( element )
		this.setTargetPosition( position )
		this.setTargetOrientation( orientation )
	end
	
	/** \brief Target looking up-down. */
	public func float getTargetLookVertical()
		return this.pTargetLookVertical
	end
	
	/** \brief Set target looking up-down. */
	public func void setTargetLookVertical( float lookVertical )
		this.pTargetLookVertical = lookVertical
	end
	
	/** \brief Set target from locomotion. */
	public func void setTargetFromLocomotion()
		var Locomotion locomotion = this.locomotion.getLocomotion()
		this.pTargetOrientation = locomotion.getOrientation()
		this.pTargetLookVertical = locomotion.getLookVerticalGoal()
	end
	
	/** \brief Conversation look-at. */
	public func ConversationPlaybackLookAt getLookAt()
		return this.pLookAt
	end
	
	/** \brief Set conversation look-at. */
	public func void setLookAt( ConversationPlaybackLookAt lookAt )
		this.pLookAt = lookAt
	end
	
	
	
	/** \brief Action to switch to if aligning succeeded. */
	public func BaseActorAction getActionSucceeded()
		return this.pActionSucceeded
	end
	
	/** \brief Set action to switch to if aligning succeeded. */
	public func void setActionSucceeded( BaseActorAction action )
		if action == null
			throw EInvalidParam.new( "action is null" )
		end
		this.pActionSucceeded = action
	end
	
	/** \brief Action to switch to if aligning failed. */
	public func BaseActorAction getActionFailed()
		return this.pActionFailed
	end
	
	/** \brief Set action to switch to if aligning failed. */
	public func void setActionFailed( BaseActorAction action )
		if action == null
			throw EInvalidParam.new( "action is null" )
		end
		this.pActionFailed = action
	end
	
	/** \brief Call aiFinished() if aligning finished. */
	public func bool getCallAIFinished()
		return this.pCallAIFinished
	end
	
	/** \brief Set if aiFinished() is called if aligning finished. */
	public func void setCallAIFinished( bool sendActionFinished )
		this.pCallAIFinished = sendActionFinished
	end
	
	
	
	/**
	 * \brief Action has been set as active action in an actor.
	 * 
	 * Starts aligning actor.
	 */
	public func void activate( BehaviorElement actor )
		super.activate( actor )
		this.startAligningActor()
	end
	
	/**
	 * \brief Action has been unset as active action in an actor.
	 * 
	 * If actor is still aligning cancel aligning. No next action is activated. Player input
	 * is cleared to avoid troubles.
	 */
	public func void deactivate()
		if this.alignActor.isFinished()
			return
		end
		
		this.alignActor.cancelAligning()
		this.resetPlayerInput()
	end
	
	/** \brief Cancel action the next time possible. */
	public func void cancel()
		if this.alignActor.isAligning()
			this.alignActor.cancelAligning()
			this.resetPlayerInput()
		end
		
		super.cancel()
	end
	
	/** \brief Actor has been added to game world and enterFrame() is called once. */
	public func void enterFrame()
		if this.pElementResolver != null
			this.pElementResolver.resolve( actor.getGameWorld() )
			this.pElementResolver = null
		end
	end
	
	/**
	 * \brief Thinking.
	 * 
	 * If aligning finished switches to finished or failed action depending if aligning
	 * succeeded or failed.
	 */
	public func void think( float elapsed )
		super.think( elapsed )
		
		if this.alignActor.isAligning()
			return
		end
		
		this.resetPlayerInput()
		
		if this.aiAction != null
			if this.alignActor.hasSucceeded()
				this.aiAction.setAction( this.pActionSucceeded )
				
			else
				this.aiAction.setAction( this.pActionFailed )
			end
		end
		
		if this.pCallAIFinished
			this.aiFinished()
		end
	end
	
	
	
	/**
	 * \brief Init behaviors.
	 * 
	 * Retrieve and store required and optional behavior instances from the actor element.
	 */
	protected func void initBehaviors()
		super.initBehaviors()
		
		if actor castable BaseActor
			var BaseActor baseActor = actor cast BaseActor
			this.alignActor = baseActor.getAlignActor()
			this.actorMover = baseActor.getActorMover()
			this.playerInputLook = baseActor.getPlayerInputLook()
			this.playerInputCrouch = baseActor.getPlayerInputCrouch()
			this.playerInputMove = baseActor.getPlayerInputMove()
			
		else
			this.alignActor = ECBehaviorAlignActor.getInstanceIn( actor )
			this.actorMover = ECBehaviorActorMover.getInstanceIn( actor )
			this.playerInputLook = ECBehaviorPlayerInputLook.getInstanceIn( actor )
			this.playerInputCrouch = ECBehaviorPlayerInputCrouch.getInstanceIn( actor )
			this.playerInputMove = ECBehaviorPlayerInputMove.getInstanceIn( actor )
		end
	end
	
	/**
	 * \brief Start aligning actor.
	 */
	protected func void startAligningActor()
		this.alignActor.setRelativeTargetElement( this.pRelativeTargetElement )
		this.alignActor.setTargetPosition( this.pTargetPosition )
		this.alignActor.setTargetOrientation( this.pTargetOrientation )
		this.alignActor.setTargetLookVertical( this.pTargetLookVertical )
		this.alignActor.setLookAt( this.pLookAt )
		
		if this.isControlledByPlayer() 
			this.alignActor.initLocomotionPlayer()
		end
		
		this.alignActor.startAligning()
	end
	
	/** \brief Reset player input. */
	protected func void resetPlayerInput()
		if this.playerInputLook != null
			this.playerInputLook.reset()
		end
		if this.playerInputMove != null
			this.playerInputMove.reset()
		end
		if this.playerInputCrouch != null
			this.playerInputCrouch.reset()
		end
	end
	
	
	
	/** \brief Two colliders can hit each other. */
	public func bool canHitCollider( Collider owner, Collider collider )
		return false
	end
	
	/** \brief Collider changed. */
	public func void colliderChanged( Collider owner )
		actor.setGeometry( owner.getPosition(), owner.getOrientation() )
	end
	
	
	
	/**
	 * \brief Name of PersistencyFactory required to load object from file.
	 * 
	 * Name of PersistencyFactory is first written to the file as string with
	 * 8-bit length. Then writeToFile() is called to write the object itself.
	 * Empty name is not allowed as is names longer than 255 characters.
	 * Name has to match a PersistencyFactory present in the Persistency
	 * instance used for loading objects. Object is read using
	 * PersistencyFactory.readObjectFromFile() of the matching PersistencyFactory.
	 */
	public func String persistencyFactoryName()
		return Factory.NAME
	end
	
	public func void writeObjectToFile( PersistencyEnvironment env, FileWriter writer )
		writer.writeByte( 0 ) // version
		
		var PersistencyFlags flags = PersistencyFlags.new( 3 )
		flags.setAt( 0, this.pCallAIFinished )
		flags.setAt( 1, this.pRelativeTargetElement != null )
		flags.setAt( 2, this.pLookAt != null )
		flags.writeToFile( writer )
		
		this.pTargetPosition.writeToFile( writer )
		writer.writeFloat( this.pTargetOrientation )
		writer.writeFloat( this.pTargetLookVertical )
		
		if this.pRelativeTargetElement != null
			ElementResolver.writeToFile( writer, this.pRelativeTargetElement )
		end
		if this.pLookAt != null
			this.pLookAt.writeToFile( env, writer )
		end
		
		env.writeObjectOrNull( writer, this.pActionSucceeded )
		env.writeObjectOrNull( writer, this.pActionFailed )
	end
end
