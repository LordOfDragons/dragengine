/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Utils

pin Dragengine.Gui
pin Dragengine.Preloading
pin Dragengine.Scenery


/**
 * \brief Texture replacement for use with element classes.
 * 
 * Supports replacing Skin and DynamicSkin of a matching component texture.
 * 
 * If a Skin instance is present the texture defined by the component Skin
 * instance or a manually set Skin is replaced with the new Skin instance.
 * The first texture defined in the replacing Skin instance is used. It is
 * possible to use skins with more than one texture but then only the first
 * texture is used. Using a skin with no texture is possible to render parts
 * of a component invisible.
 * 
 * If a color tint is present a DynamicSkin is created and replaces the
 * component or manually set dynamic skin. It is possible to use color tint
 * without using a new Skin instance. In this case the currently used skin
 * of the component texture is modified.
 * 
 * If a transform is present it replaces the component or manually set
 * transformation if present. It is possible to use transform without using
 * a new Skin instance. In this case the currently used skin of the
 * component texture is modified.
 * 
 * Texture replacements have to be applied to a component using
 * applyToComponent() method after setting up the component with all skin
 * and dynamic skin instances. If no component texture matches the name
 * the texture replacement has no effect.
 * 
 * To use a texture replacement in an element class use the
 * ECPTextureReplacementList element class property.
 */
class TextureReplacement
	var String pName, pPath
	var Skin pSkin
	var TexMatrix2 pTransform
	var Color pColorTint
	
	
	/** \brief Create texture replace object. */
	func new(String name)
		setName(name)
	end
	
	/** \brief Create copy of texture replace object. */
	func new(TextureReplacement copy)
		pName = copy.pName
		pPath = copy.pPath
		pSkin = copy.pSkin
		pTransform = copy.pTransform
		pColorTint = copy.pColorTint
	end
	
	/** \brief Create texture replacement from stub. */
	func new(StubElementTexture stub)
		pName = stub.getTextureName()
		pPath = stub.getPathSkin()
		pSkin = stub.getSkin()
		pTransform = stub.getTransform()
		pColorTint = stub.getColorTint()
	end
	
	
	
	/** \brief Name of the texture in the component. */
	func String getName()
		return pName
	end
	
	/**
	 * \brief Set name of the texture in the component.
	 * \version 1.29
	 */
	func void setName(String name)
		if name == null
			throw EInvalidParam.new()
		end
		pName = name
	end
	
	/** \brief Path to skin or \em null to not replace the skin. */
	func String getPath()
		return pPath
	end
	
	/** \brief Set path to skin or \em null to not replace the skin. */
	func void setPath(String path)
		pPath = path
	end
	
	/** \brief Skin resource or \em null to not replace the skin. */
	func Skin getSkin()
		return pSkin
	end
	
	/** \brief Set skin resource or \em null to not replace the skin. */
	func void setSkin(Skin skin)
		pSkin = skin
	end
	
	/** \brief Texture coordinate transformation or \em null to not replace the transformation. */
	func TexMatrix2 getTransform()
		return pTransform
	end
	
	/** \brief Set texture coordinate transformation or \em null to not replace the transformation. */
	func void setTransform(TexMatrix2 matrix)
		pTransform = matrix
	end
	
	/** \brief Color tint or \em null to not replace the color tint. */
	func Color getColorTint()
		return pColorTint
	end
	
	/** \brief Set color tint or \em null to not replace the color tint. */
	func void setColorTint(Color color)
		pColorTint = color
	end
	
	
	
	/** \brief Apply texture replacement to matching component texture if present. */
	func void applyToComponent(Component component)
		var int index = component.indexOfTextureNamed(pName)
		if index == -1
			return
		end
		
		if pSkin != null
			component.setTextureSkinAt(index, pSkin, 0)
		end
		
		if pTransform != null
			component.setTextureTransformAt(index, pTransform)
		end
		
		component.setTextureDynamicSkinAt(index, createDynamicSkin())
	end
	
	
	
	/**
	 * \brief Create dynamic skin from texture replace definition.
	 * \details If no dynamic skin is required null is returned.
	 */
	func DynamicSkin createDynamicSkin()
		if pColorTint == null
			return null
		end
		
		var DynamicSkin dynamicSkin = DynamicSkin.new()
		dynamicSkin.addRenderable("tint", DynamicSkinRenderableType.color)
		dynamicSkin.setColorAt(0, pColorTint)
		
		return dynamicSkin
	end
end
