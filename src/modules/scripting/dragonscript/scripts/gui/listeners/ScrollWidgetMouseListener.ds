/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland PlÃ¼ss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Events
pin Dragengine.Utils


/**
 * \brief Mouse listener scrolling widget using mouse dragging.
 *
 * \par Deceleration (1.16)
 * 
 * Supports continue scrolling with last drag velocity decelerating
 * down to zero over time. This can be used to simplify larger scale
 * scrolling by using fling type movement.
 *
 * By default continue scrolling is disabled. To enabled continuous
 * scrolling set the continue scroll time to a value larger than 0.
 */
class ScrollWidgetMouseListener extends DefaultMouseListener
	/**
	 * \brief Frame updater to continue scrolling over time.
	 * \version 1.16
	 */
	protected class ScrollUpdater extends FrameUpdateListener
		private var WeakReference pListener

		/** \brief Create frame updater. */
		public func new(ScrollWidgetMouseListener listener)
			pListener = WeakReference.new(listener)
		end

		/**
		 * \brief Do frame update.
		 * 
		 * \param elapsed Elapsed time since the last frame update. Equals Engine.getElapsedTime().
		 */
		public func void frameUpdate(float elapsed)
			var ScrollWidgetMouseListener listener = pListener.get() cast ScrollWidgetMouseListener
			if listener != null
				listener.updateScroll(elapsed)

			else
				giveUp()
			end
		end
	end



	private var Container pWidget
	private var Point pAnchorPosition
	private var int pAnchorVertical
	private var int pAnchorHorizontal

	private var Point pLastPosition
	private var Point pLastDisplacement
	private var float pVelocityVertical
	private var float pVelocityHorizontal
	private var float pContinueScrollTime
	private var float pContinueScrollElapsed
	private var ScrollUpdater pScrollUpdater
	
	
	
	/** \brief Create mouse listener. */
	public func new(Container widget)
		if widget == null
			throw ENullPointer.new("widget")
		end
		
		pWidget = widget
		pAnchorPosition = null
		pAnchorVertical = 0
		pAnchorHorizontal = 0
		pContinueScrollTime = 0
	end
	
	
	
	/** \brief Widget to scroll. */
	public func Container getWidget()
		return pWidget
	end
	
	/** \brief Anchor mouse position or \em null if not scrolling. */
	public func Point getAnchorPosition()
		return pAnchorPosition
	end
	
	/** \brief Set anchor mouse position or \em null if not scrolling. */
	public func void setAnchorPosition(Point position)
		pAnchorPosition = position
	end
	
	/** \brief Anchor vertical model value for anchor position. */
	public func int getAnchorVertical()
		return pAnchorVertical
	end
	
	/** \brief Set anchor vertical model value for anchor position. */
	public func void setAnchorVertical(int value)
		pAnchorVertical = value
	end
	
	/** \brief Anchor horizontal model value for anchor position. */
	public func int getAnchorHorizontal()
		return pAnchorHorizontal
	end
	
	/** \brief Set anchor horizontal model value for anchor position. */
	public func void setAnchorHorizontal(int value)
		pAnchorHorizontal = value
	end


	/**
	 * \brief Last position in pixels.
	 * \version 1.16
	 */
	public func Point getLastPosition()
		return pLastPosition
	end

	/**
	 * \brief Set last position in pixels.
	 * \version 1.16
	 */
	public func void setLastPosition(Point position)
		pLastPosition = position
	end

	/**
	 * \brief Last displacement in pixels.
	 * \version 1.16
	 */
	public func Point getLastDisplacement()
		return pLastDisplacement
	end

	/**
	 * \brief Set last displacement in pixels.
	 * \version 1.16
	 */
	public func void setLastDisplacement(Point displacement)
		pLastDisplacement = displacement
	end

	/**
	 * \brief Vertical velocity in pixels per second.
	 * \version 1.16
	 */
	public func float getVelocityVertical()
		return pVelocityVertical
	end

	/**
	 * \brief Set vertical velocity in pixels per second.
	 * \version 1.16
	 */
	public func void setVelocityVertical(float velocity)
		pVelocityVertical = DEMath.max(velocity, 0.0)
	end

	/**
	 * \brief Horizontal velocity in pixels per second.
	 * \version 1.16
	 */
	public func float getVelocityHorizontal()
		return pVelocityHorizontal
	end

	/**
	 * \brief Set horizontal velocity in pixels per second.
	 * \version 1.16
	 */
	public func void setVelocityHorizontal(float velocity)
		pVelocityHorizontal = DEMath.max(velocity, 0.0)
	end

	/**
	 * \brief Continue scroll time in seconds.
	 * \version 1.16
	 */
	public func float getContinueScrollTime()
		return pContinueScrollTime
	end

	/**
	 * \brief Set continue scroll time in seconds.
	 * \version 1.16
	 */
	public func void setContinueScrollTime(float time)
		pContinueScrollTime = DEMath.max(time, 0.0)
	end

	/**
	 * \brief Elapsed continue scroll time in seconds.
	 * \version 1.16
	 */
	public func float getContinueScrollElapsed()
		return pContinueScrollElapsed
	end

	/**
	 * \brief Set elapsed continue scroll time in seconds.
	 * \version 1.16
	 */
	public func void setContinueScrollElapsed(float elapsed)
		pContinueScrollElapsed = DEMath.max(elapsed, 0.0)
	end
	
	
	
	/**
	 * \brief Mouse button has been pressed.
	 * \details Starts scrolling by moving the mouse.
	 */
	public func void onButtonPress(MouseEvent event)
		if event.getButton() == InputEventMouseButton.left
			var Widget eventWidget = event.getSource() cast Widget
			pAnchorPosition = event.getPosition() + eventWidget.getRelativePosition(pWidget)

			pLastPosition = pAnchorPosition
			pLastDisplacement = Point.new()
			pVelocityHorizontal = 0
			pVelocityVertical = 0
			pContinueScrollElapsed = 0
			
			var RangeModel model = pWidget.getVerticalRangeModel()
			if model != null
				pAnchorVertical = model.getValue()
			end
			
			model = pWidget.getHorizontalRangeModel()
			if model != null
				pAnchorHorizontal = model.getValue()
			end
			
			eventWidget.captureMouse()
			startScrollUpdater()
		end
	end
	
	/** \brief Mouse button has been released. */
	public func void onButtonRelease(MouseEvent event)
		if event.getButton() == InputEventMouseButton.left
			if pAnchorPosition != null
				(event.getSource() cast Widget).releaseMouse()
				pAnchorPosition = null
				
				var RangeModel model = pWidget.getVerticalRangeModel()
				if model != null
					pAnchorVertical = model.getValue()
				end
				
				model = pWidget.getHorizontalRangeModel()
				if model != null
					pAnchorHorizontal = model.getValue()
				end
			end
		end
	end
	
	/** \brief Mouse has moved. */
	public func void onMouseMove(MouseEvent event)
		if pAnchorPosition == null
			return
		end
		
		var Point nextPosition = event.getPosition()\
			+ (event.getSource() cast Widget).getRelativePosition(pWidget)
		pLastDisplacement = nextPosition - pLastPosition
		pLastPosition = nextPosition
		
		var Point difference = nextPosition - pAnchorPosition
		
		var RangeModel model = pWidget.getHorizontalRangeModel()
		if model != null
			model.setValue(pAnchorHorizontal - difference.getX())
		end
		
		model = pWidget.getVerticalRangeModel()
		if model != null
			model.setValue(pAnchorVertical - difference.getY())
		end
	end

	/**
	 * \brief Continue scrolling.
	 * \version 1.16
	 *
	 * Reduces velocity from 0 to pContinueScrollTime using quadratic regression
	 * of the elapsed time then scrolls accordingly. Once pContinueScrollTime
	 * elapsed continue scrolling is disabled.
	 */
	public func void updateScroll(float elapsed)
		elapsed = DEMath.max(elapsed, 0.0)
		
		if pAnchorPosition != null
			if elapsed > 0
				pVelocityHorizontal = (pLastDisplacement.getX() cast float) / elapsed
				pVelocityVertical = (pLastDisplacement.getY() cast float) / elapsed
				
			else
				pVelocityHorizontal = 0
				pVelocityVertical = 0
			end

			pLastDisplacement = Point.new()
			return
		end

		pContinueScrollElapsed += elapsed

		if pContinueScrollElapsed >= pContinueScrollTime
			stopScrollUpdater()
			return
		end

		var float factor = pContinueScrollElapsed / pContinueScrollTime
		factor = (1.0 - factor * factor) * elapsed

		pAnchorVertical += (pVelocityVertical * factor) cast int
		pAnchorHorizontal += (pVelocityHorizontal * factor) cast int
		
		var RangeModel model = pWidget.getHorizontalRangeModel()
		if model != null
			model.setValue(pAnchorHorizontal)
		end
		
		model = pWidget.getVerticalRangeModel()
		if model != null
			model.setValue(pAnchorVertical)
		end
	end

	/**
	 * \brief Start scroll updater.
	 * \version 1.16
	 */
	protected func void startScrollUpdater()
		if pScrollUpdater == null
			pScrollUpdater = ScrollUpdater.new(this)
		end
	end

	/**
	 * \brief Stop scroll updater.
	 * \version 1.16
	 */
	protected func void stopScrollUpdater()
		if pScrollUpdater != null
			pScrollUpdater.giveUp()
			pScrollUpdater = null
		end
	end
end
