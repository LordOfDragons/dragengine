/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Events
pin Dragengine.Gui.Layouts
pin Dragengine.Gui.Decorations
pin Dragengine.Gui.MousePointers.Factories
pin Dragengine.Scenery


/**
 * \brief Desktop containing set of windows.
 * 
 * Provides typical desktop support like handling window interaction, focus and hover widget
 * as well as mouse pointer handling.
 * 
 * 
 * 
 * \todo Add support to set mouse pointers for different situations:
 * - normal mouse pointer
 * - resizing mouse pointes: 8 pointers for each direction
 * these also have to go into a new DefaultDesktopDesigner class.
 * change the mouse pointer depending on the situation. mouse pointers should have only the
 * responsibility to provide and update a canvas. complex logic like showing additional
 * widgets like the InfoMousePointer does have to be moved into MouseListener which update
 * widgets matching the mouse pointer position. this separates extended logic from basic
 * design which can be done using XML. It also allows to attach logic to a MousePointer
 * without the need to alter the instance itself.
 */
class Desktop extends Container
	private var Widget pFocusWidget
	private var Widget pFocusInProgress
	
	private var Widget pHoverWidget
	private var Window pTrackDecoration
	private var Decoration.Area pTrackDecorationAreaHover
	
	private var Widget pCaptureWidget
	
	private var Point pMouseLocation
	private var MousePointerFactory pActiveMousePointer
	private var MousePointer pMousePointerInstance
	private var RectArea pMouseArea
	private var bool pMouseHidden
	private var Array pMousePointerListeners
	
	private var Window pDragWindow
	private var Point pDragOffset
	private var Decoration.Area pDragArea
	
	private var BorderSize pNoWindowBorder
	
	private var ToolTipManager pToolTipManager
	private var WindowVirtualKeyboard pWindowVirtualKeyboard
	
	
	
	/** \brief Create desktop widget. */
	public func new(int width, int height) this(0, 0, width, height)
	end
	
	/** \brief Create desktop widget. */
	public func new(Point size) this(0, 0, size.getX(), size.getY())
	end
	
	/** \brief Create desktop widget. */
	public func new(int x, int y, int width, int height) super(x, y, width, height)
		pMousePointerListeners = Array.new()
		pDragOffset = Point.new()
		pNoWindowBorder = BorderSize.new()
		
		pTrackDecorationAreaHover = Decoration.Area.nothing
		
		setDesignerSelector("Desktop")
		setLayout(FixedLayout.new())
		pMouseLocation = Point.new(width / 2, height / 2)
		pMouseHidden = false
		
		pToolTipManager = ToolTipManager.new(this)
		setClipboard(Clipboard.new())
	end
	
	
	/** \brief Disposes of widget. */
	public func void dispose()
		setWindowVirtualKeyboard(null)
		setToolTipManager(null)
		
		pMousePointerListeners = null
		pFocusWidget = null
		pFocusInProgress = null
		
		pHoverWidget = null
		pTrackDecoration = null
		
		pCaptureWidget = null
		
		super.dispose()
	end
	
	
	
	/** \brief Active window or \em null. */
	public func Window getActiveWindow()
		var Widget focusWidget = getFocusWidget()
		if focusWidget != null
			return focusWidget.getWindow()
			
		else
			return null
		end
	end
	
	/** \brief Focused widget or \em null. */
	public func Widget getFocusWidget()
		if pFocusWidget != null
			if pFocusWidget.getParent() == null /* removed or disposed while active */ \
			or not pFocusWidget.getCanFocus() \
			or not pFocusWidget.getEnabled() \
			or not pFocusWidget.getVisible()
				pFocusWidget = null
			end
		end
		
		return pFocusWidget
	end
	
	
	
	/** \brief Widget the mouse hovers above or \em null. */
	public func Widget getHoverWidget()
		if pHoverWidget != null
			if pHoverWidget.getParent() == null /* removed or disposed while active */ \
			or not pHoverWidget.getVisible()
				pHoverWidget = null
			end
		end
		
		return pHoverWidget != null if pHoverWidget else this
	end
	
	/**
	 * \brief Set widget the mouse hovers above.
	 * \details If widget is different than the old one enter and leave messages are send.
	 */
	protected func void setHoverWidget(Widget widget, MouseEvent event)
		var Widget hoverWidget = getHoverWidget()
		if widget == hoverWidget
			return
		end
		
		var Widget leaveWidget = hoverWidget
		
		pHoverWidget = widget
		
		if leaveWidget != null
			// runWhileBlockingLayout added to deal with problem of layoutParent calling updateHoverWidget
			// which in turn overwrites pHoverWidget while the next call is running. this results in
			// pHoverWidget different than widget which is wrong
			runWhileBlockingLayout(block
				leaveWidget.sendEvent(MouseEvent.new(leaveWidget, MouseEvent.idMouseLeave, \
					event.getButton(), event.getModifiers(), event.getSystem(), event.getDevice()))
			end)
		end
		
		if widget == null
			setActiveMousePointer(getFirstMousePointer())
			
		else
			setActiveMousePointer(widget.getFirstMousePointer())
			widget.sendEvent(MouseEvent.new(widget, MouseEvent.idMouseEnter, \
				event.getButton(), event.getModifiers(), event.getSystem(), event.getDevice()))
		end
	end
	
	/**
	 * \brief Update hover widget.
	 * \details Call if the hover widget is removed from the desktop.
	 */
	public func void updateHoverWidget()
		var Widget hoverWidget
		
		if pDragWindow != null
			
		elif pCaptureWidget != null
			hoverWidget = pCaptureWidget
			
		else
			var int i, count = getWidgetCount()
			var Window window
			var Widget widget
			
			for i = count - 1 downto 0
				window = getWidget(i) cast Window
				if not window.getVisible()
					continue
				end
				if not window.getEnabled()
					break
				end
				
				widget = window.getWidgetAt(pMouseLocation - window.getPosition())
				if widget == null
					continue
				end
				
				hoverWidget = widget
				break
			end
		end
		
		if hoverWidget == getHoverWidget()
			return
		end
		
		var MouseEvent event = MouseEvent.new(hoverWidget, MouseEvent.idMouseMoved, 0, 0, Point.new(), -1)
		
		if hoverWidget == null
			setHoverWidget(null, event)
			
		else
			setHoverWidget(hoverWidget, event)
		end
	end
	
	/** \brief Clear hover widget. */
	protected func void clearHoverWidget()
		var Widget hoverWidget = getHoverWidget()
		if hoverWidget != null
			setHoverWidget(null, MouseEvent.new(hoverWidget, MouseEvent.idMouseLeave, 0, 0, -1))
		end
	end
	
	
	/** \brief Decoration whose state is tracked or \em null. */
	protected func Window getTrackDecoration()
		return pTrackDecoration
	end
	
	/** \brief Set decoration whose state is tracked or \em null. */
	protected func void setTrackDecoration(Window window)
		if window == pTrackDecoration
			return
		end
		
		setTrackDecorationAreaHover(Decoration.Area.nothing)
		pTrackDecoration = window
	end
	
	/** \brief Tracked decoration area the mouse hovers above. */
	protected func Decoration.Area getTrackDecorationAreaHover()
		return pTrackDecorationAreaHover
	end
	
	/** \brief Set tracked decoration area the mouse hovers above. */
	protected func void setTrackDecorationAreaHover(Decoration.Area areaHover)
		if areaHover == pTrackDecorationAreaHover
			return
		end
		
		if pTrackDecoration != null
			select pTrackDecorationAreaHover
			case Decoration.Area.close
				pTrackDecoration.getDecoration().setButtonState(Decoration.Button.close, false, false)
				
			case Decoration.Area.maximize
				pTrackDecoration.getDecoration().setButtonState(Decoration.Button.maximize, false, false)
				
			case Decoration.Area.minimize
				pTrackDecoration.getDecoration().setButtonState(Decoration.Button.minimize, false, false)
			end
		end
		
		pTrackDecorationAreaHover = areaHover
		
		if pTrackDecoration != null
			select areaHover
			case Decoration.Area.close
				pTrackDecoration.getDecoration().setButtonState(Decoration.Button.close, true, false)
				
			case Decoration.Area.maximize
				pTrackDecoration.getDecoration().setButtonState(Decoration.Button.maximize, true, false)
				
			case Decoration.Area.minimize
				pTrackDecoration.getDecoration().setButtonState(Decoration.Button.minimize, true, false)
			end
		end
	end
	
	
	
	/** Retrieves the widget having captured the mouse. */
	public func Widget getMouseCaptureWidget()
		return pCaptureWidget
	end
	
	
	
	/** \brief Location of mouse pointer. */
	public func Point getMouseLocation()
		return pMouseLocation
	end
	
	/**
	 * \brief Set location of mouse pointer.
	 * 
	 * Location is clamped to the mouse movement area.
	 */
	public func void setMouseLocation(Point location)
		if pMouseArea != null
			location = pMouseArea.clamp(location)
		end
		location = RectArea.new(0, 0, getWidth() - 1, getHeight() - 1).clamp(location)
		if location.equals(pMouseLocation)
			return
		end
		
		pMouseLocation = location
		
		if pMousePointerInstance != null
			pMousePointerInstance.setPosition(location)
		end
		
		onMousePointerMoved(MousePointerEvent.new(this,\
			MousePointerEvent.idMousePointerMoved, pMousePointerInstance))
	end
	
	/**
	 * \brief Warp mouse pointer.
	 * 
	 * Use this method if you move the moue pointer directly as otherwise the appropriate
	 * messages are not send.
	 */
	public func void warpMousePointer(Point location)
		if InputSystem.getCaptureInputDevices()
			onMouseMove(MouseEvent.new(this, MouseEvent.idMouseMoved, 0, 0, location - pMouseLocation, -1))
			
		else
			onMouseMove(MouseEvent.new(this, MouseEvent.idMouseMoved, 0, 0, location, -1))
		end
	end
	
	/**
	 * \brief Warp mouse pointer relative to widget.
	 * 
	 * Use this method if you move the moue pointer directly as otherwise the appropriate
	 * messages are not send.
	 */
	public func void warpMouseIn(Widget widget, Point location)
		warpMousePointer(widget.getDesktopPosition() + location)
	end
	
	/**
	 * \brief Warp mouse pointer centered in desktop.
	 * 
	 * Use this method if you move the moue pointer directly as otherwise the appropriate
	 * messages are not send.
	 */
	public func void warpCenterMouse()
		warpMousePointer(getSize() / 2)
	end
	
	/**
	 * \brief Warp mouse pointer centered inside widget.
	 * 
	 * Use this method if you move the moue pointer directly as otherwise the appropriate
	 * messages are not send.
	 */
	public func void warpCenterMouseIn(Widget widget)
		warpMouseIn(widget, widget.getSize() / 2)
	end
	
	/** \brief Active mouse pointer factory or \em null. */
	public func MousePointerFactory getActiveMousePointer()
		return pActiveMousePointer
	end
	
	/**
	 * \brief Set active mouse pointer or \em null.
	 * 
	 * If factory changes a new mouse pointer instance is created if not null.
	 */
	public func void setActiveMousePointer(MousePointerFactory mousePointer)
		if mousePointer == pActiveMousePointer
			return
		end
		
		if pMousePointerInstance != null
			getCanvasWidget().removeCanvas(pMousePointerInstance.getCanvas())
			pMousePointerInstance = null
		end
		
		pActiveMousePointer = mousePointer
		
		if mousePointer != null
			pMousePointerInstance = mousePointer.createMousePointer()
			pMousePointerInstance.setPosition(pMouseLocation)
			
			var Canvas canvas = pMousePointerInstance.getCanvas()
			canvas.setOrder(1.5) // between content and border
			canvas.setVisible(not pMouseHidden)
			getCanvasWidget().addCanvas(canvas)
		end
		
		onMousePointerChanged(MousePointerEvent.new(this,\
			MousePointerEvent.idMousePointerMoved, pMousePointerInstance))
	end
	
	/** \brief Mouse pointer instance or null. */
	public func MousePointer getMousePointerInstance()
		return pMousePointerInstance
	end
	
	/** \brief Movement area of mouse pointer or \em null if not set. */
	public func RectArea getMouseArea()
		return pMouseArea
	end
	
	/** \brief Set movement area of the mouse pointer or \em null to clear. */
	public func void setMouseArea(RectArea area)
		if area != null
			area = area.orientate()
		end
		pMouseArea = area
	end
	
	/** \brief Mouse pointer is hidden. */
	public func bool getIsMouseHidden()
		return pMouseHidden
	end
	
	/** \brief Set if mouse pointer is hidden. */
	public func void setIsMouseHidden(bool hidden)
		if hidden == pMouseHidden
			return
		end
		
		pMouseHidden = hidden
		
		if pMousePointerInstance != null
			pMousePointerInstance.getCanvas().setVisible(not hidden)
		end
		
		if hidden
			onMousePointerHidden(MousePointerEvent.new(this,\
				MousePointerEvent.idMousePointerHidden, pMousePointerInstance))
			
		else
			onMousePointerHidden(MousePointerEvent.new(this,\
				MousePointerEvent.idMousePointerShown, pMousePointerInstance))
		end
	end
	
	
	
	/**
	 * \brief Add mouse pointer listener.
	 * \version 1.7
	 */
	public func void addMousePointerListener(MousePointerListener listener)
		if listener == null
			throw ENullPointer.new("listener")
		end
		pMousePointerListeners.add(listener)
	end
	
	/**
	 * \brief Remove mouse pointer listener.
	 * \version 1.7
	 */
	public func void removeMousePointerListener(MousePointerListener listener)
		pMousePointerListeners.remove(listener)
	end
	
	
	
	/** \brief Area along the borders no window can occupy. */
	public func BorderSize getNoWindowBorder()
		return pNoWindowBorder
	end
	
	/** \brief Set area along the borders no window can occupy. */
	public func void setNoWindowBorder(BorderSize size)
		if size == null
			throw EInvalidParam.new()
		end
		
		if size.equals(pNoWindowBorder)
			return
		end
		
		pNoWindowBorder = size
	end
	
	/** \brief Top left position excluding no window border. */
	public func Point getNoBorderPosition()
		return Point.new(pNoWindowBorder.getLeft(), pNoWindowBorder.getTop())
	end
	
	/** \brief Maximum size excluding no window border. */
	public func Point getNoBorderSize()
		return getSize() - pNoWindowBorder.getSize()
	end
	
	
	
	/** \brief Add window to desktop. */
	public func void addWidget(Widget widget)
		addWidget(widget, null)
	end
	
	/**
	 * \brief Add window to desktop.
	 * \details To add windows use this function rather than addWidget.
	 */
	public func void addWindow(Window window)
		addWidget(window, null)
	end
	
	/** \brief Add window to desktop. */
	public func void addWidget(Widget widget, Object settings)
		if not widget castable Window
			throw EInvalidParam.new()
		end
		
		super.addWidget(widget, settings)
		
		if (widget cast Window).getWindowState() == Window.WindowState.maximized
			// TODO this is duplicate code. move this code and the one from updateMaximizedWindowSizes()
			//      into Window class. then also store the restored position
			widget.setPosition(Point.new())
			widget.setSize(getSize())
		end
		
		if widget.getVisible()
			widget.grabFocus()
		end
	end
	
	/**
	 * \brief Add window to desktop.
	 * \details To add windows use this function rather than addWidget.
	 */
	public func void addWindow(Window window, Object settings)
		addWidget(window, settings)
	end
	
	/** \brief Remove window from desktop. */
	public func void removeWidget(Widget widget)
		var Window window = widget cast Window
		
		if window == pTrackDecoration
			setTrackDecoration(null)
		end
		if window.getActivated()
			clearFocusWidget()
		end
		clearHoverWidget()
		
		if pHoverWidget != null
			throw EInvalidParam.new()
		end
		super.removeWidget(widget)
		
		if getFocusWidget() == null
			focusActiveWidgetOfFirstUsableWindow()
		end
		updateHoverWidget()
	end
	
	/** \brief Remove all windows from desktop. */
	public func void removeAllWidgets()
		clearFocusWidget()
		clearHoverWidget()
		super.removeAllWidgets()
	end
	
	
	
	/** Notifies that the current focus widget can no longer hold the focus. */
	public func void giveUpFocus()
		clearFocusWidget()
		focusActiveWidgetOfFirstUsableWindow()
	end
	
	/** Clears the focus widget. */
	public func void clearFocusWidget()
		var Widget focusWidget = getFocusWidget()
		if focusWidget == null
			return
		end
		
		var Window window = focusWidget.getWindow()
		if window != null
			window.setActivated(false)
		end
		
		pFocusWidget = null
		focusWidget.setHasFocus(false)
	end
	
	/** \brief Focus the active widget of the top window supporting it if possible. */
	public func void focusActiveWidgetOfFirstUsableWindow()
		var int count = getWidgetCount()
		if count == 0
			return
		end
		
		var Window window
		var int i
		
		for i = count - 1 downto 0
			window = getWidget(i) cast Window
			if not window.getVisible() or not window.getCanActivate() \
			or window.getBlockingWindow() != null
				continue
			end
			
			if window.getCanReorder()
				window.moveToTop()
			end
			window.grabFocus()
			return
		end
	end
	
	
	
	/** Request to focus the specified widget. */
	public func void requestGrabFocus(Widget widget)
		super.requestGrabFocus(widget)
		
		// get the windows of the current and new focus widget if existing
		var Window windowNew = widget.getWindow()
		var Window windowOld
		
		var Widget focusWidget = getFocusWidget()
		if focusWidget != null
			windowOld = focusWidget.getWindow()
		end
		
		// if window can not be activated stick with the old window
		if not windowNew.getCanActivate()
			windowNew = windowOld
		end
		
		// update focus and activation states if window changed
		if windowOld != null and windowOld != windowNew
			windowOld.setActivated(false)
		end
		
		// change focus widget sending events
		pFocusWidget = widget
		
		if focusWidget != null
			focusWidget.setHasFocus(false)
		end
		widget.setHasFocus(true)
		
		// if window changed activate new window and move it to the top
		if windowNew != windowOld
			windowNew.setActivated(true)
			if windowNew.getCanReorder()
				windowNew.moveToTop()
			end
		end
	end
	
	/**
	 * \brief Container allows child widgets to grab the focus.
	 */
	public func bool allowsChildGrabFocus()
		if not getEnabled() or not getVisible()
			return false
		end
		
		var Container parent = getParent()
		if parent == null
			return true
		end
		
		return parent.allowsChildGrabFocus()
	end
	
	/**
	 * \brief Request to capture the mouse for the specified widget.
	 */
	public func bool requestCaptureMouse(Widget widget)
		if widget == null //or pCaptureWidget != null
			return false
		end
		
		pCaptureWidget = widget
		updateHoverWidget()
		
		return true
	end
	
	/**
	 * \brief Request to release mouse capture.
	 * \returns \em true if the widget is the capture widget otherwise \em false.
	 */
	public func bool requestReleaseMouse(Widget widget)
		if widget != pCaptureWidget
			return false
		end
		
		pCaptureWidget = null
		updateHoverWidget()
		
		return true
	end
	
	
	
	/**
	 * \brief Tool tip manager or null.
	 * \version 1.7
	 */
	public func ToolTipManager getToolTipManager()
		return pToolTipManager
	end
	
	/**
	 * \brief Set tool tip manager or null.
	 * \version 1.7
	 */
	public func void setToolTipManager(ToolTipManager tooltipManager)
		if tooltipManager == pToolTipManager
			return
		end
		
		if pToolTipManager != null
			pToolTipManager.dispose()
			pToolTipManager = null
		end
		
		pToolTipManager = tooltipManager
	end
	
	
	
	/**
	 * \brief Virtual keyboard window or null.
	 * \version 1.7
	 */
	public func WindowVirtualKeyboard getWindowVirtualKeyboard()
		return pWindowVirtualKeyboard
	end
	
	/**
	 * \brief Set virtual keyboard window or null.
	 * \version 1.7
	 */
	public func void setWindowVirtualKeyboard(WindowVirtualKeyboard window)
		if window == pWindowVirtualKeyboard
			return
		end
		
		if pWindowVirtualKeyboard != null
			pWindowVirtualKeyboard.safeDispose()
			pWindowVirtualKeyboard = null
		end
		
		pWindowVirtualKeyboard = window
		
		if window != null
			window.setVisible(false)
			addWindow(window)
		end
	end
	
	
	
	/** Sends an Event to the focus widget or drop it. */
	public func void processEvent(Event event)
		var int ident = event.getIdentifier()
		var Widget eventWidget //, focusWidget
		var Event eventToSend
		
		// check if the event has to work on the focused widget or active window
		if KeyEvent.isKeyEvent(ident)
			var KeyEvent keyEvent = event cast KeyEvent
			eventWidget = getFocusWidget()
			eventToSend = KeyEvent.new(eventWidget, ident, keyEvent.getKeyCode(), \
				keyEvent.getModifiers(), keyEvent.getKeyChar(), \
				keyEvent.getSystem(), keyEvent.getDevice() , keyEvent.getButtonCode())
			// send event if an appropriate widget has been found
			if eventWidget != null
				eventWidget.sendEvent(eventToSend)
			end
			
		elif GamepadEvent.isGamepadEvent(ident)
			var Widget focusWidget = getFocusWidget()
			if focusWidget != null
				var GamepadEvent gevent = event cast GamepadEvent
				eventToSend = GamepadEvent.new(focusWidget, ident, gevent.getSystem(), \
					gevent.getDevice(), gevent.getCode(), gevent.getModifiers(), gevent.getAxisValue())
				focusWidget.sendEvent(eventToSend)
			end
			
		elif ident == MouseEvent.idMouseWheeled
			eventWidget = pCaptureWidget
			if eventWidget == null
				// always update the hover widget. if we do not do this it is possible a widget
				// changes while the mouse pointer does not move
				updateHoverWidget()
				eventWidget = getHoverWidget()
			end
			if eventWidget != null
				var MouseEvent mevent = event cast MouseEvent
				eventToSend = MouseEvent.new(eventWidget, ident, mevent.getButton(), \
					mevent.getModifiers(), mevent.getPosition(), mevent.getSystem(), mevent.getDevice())
				eventWidget.sendEvent(eventToSend)
			end
			
		// check for events working with a screen location or to a capture widget
		/*elif MouseEvent.isMouseEvent(ident)
			var MouseEvent mouseEvent = event cast MouseEvent
			setMouseLocation(pMouseLocation + \
				Point.new(mouseEvent.getX(), mouseEvent.getY()))
			if pCaptureWidget == null
				eventWidget = getWidgetAt(pMouseLocation)
			else
				eventWidget = pCaptureWidget
			end
			if eventWidget != null
				eventToSend = MouseEvent.new(eventWidget, ident, mouseEvent.getButton(), \
					mouseEvent.getModifiers(), pMouseLocation.getX() - eventWidget.getScreenX(), \
					pMouseLocation.getY() - eventWidget.getScreenY())
			end
			// store widget where the mouse is above at the moment
			pHoverWidget = eventWidget
			*/
		else
			sendEvent(event)
		end
	end
	
	
	
	/**
	 * Retrieves the desktop or null if this widget is not part of a
	 * desktop. The default implementation forwards the request to the
	 * parent with the Desktop or a subclass thereof intercepting.
	 */
	public func Desktop getDesktop()
		return this
	end
	
	/** \brief Widget position in desktop coordinates. */
	public func Point getDesktopPosition()
		return Point.new()
	end
	
	
	
	/**
	 * Layout parent if existing. Modified version to not layout of Desktop.
	 * Desktop widgets have a fixed size and do not change size if their
	 * windows change in any way. Prevents triggering parent layout calls
	 * wasting time. On the other hand check for condition changes altering
	 * stored widgets
	 */
	public func void layoutParent()
		// check if capture widget is no more existing
		if pCaptureWidget != null
			if not pCaptureWidget.hasParent(this)
				pCaptureWidget = null
			end
		end
		
		// check if hover widget changed
		updateHoverWidget()
	end
	
	
	
	/** Notification that a mouse button has been pressed. */
	public func void onButtonPress(MouseEvent event)
		if event.getSource() != this
			return // if some lazy bum send his message up to the parent ignore it
		end
		
		setMouseLocation(pMouseLocation + event.getPosition())
		
		if pCaptureWidget != null
			if pCaptureWidget != this
				pCaptureWidget.sendEvent(MouseEvent.new(pCaptureWidget, \
					event.getIdentifier(), event.getButton(), event.getModifiers(), \
					pMouseLocation - pCaptureWidget.getScreenPosition(), \
					event.getSystem(), event.getDevice()))
			end
			return
		end
		
		var int i, count = getWidgetCount()
		var Window window
		
		for i = count - 1 downto 0
			window = getWidget(i) cast Window
			if not window.getVisible()
				continue
			end
			
			var Decoration decoration = window.getDecoration()
			if decoration != null
				var Decoration.Area hitType = decoration.areaHitBy(pMouseLocation)
				if hitType != Decoration.Area.nothing
					if not window.getEnabled() or not window.getCanActivate()
						return
						
					elif window.getBlockingWindow() != null
						if window.getCanReorder()
							window.moveToTop()
						end
						window.getTopBlockingWindow().grabFocus()
						return
					end
					
					select decoration.areaHitBy(pMouseLocation)
					case Decoration.Area.close
						if event.getButton() == InputEventMouseButton.left
							decoration.setButtonState(Decoration.Button.close, true, true)
							
							pDragWindow = window
							pDragArea = Decoration.Area.close
							requestCaptureMouse(this)
						end
						return
						
					case Decoration.Area.maximize
						if event.getButton() == InputEventMouseButton.left
							decoration.setButtonState(Decoration.Button.maximize, true, true)
							
							pDragWindow = window
							pDragArea = Decoration.Area.maximize
							requestCaptureMouse(this)
						end
						return
						
					case Decoration.Area.minimize
						if event.getButton() == InputEventMouseButton.left
							decoration.setButtonState(Decoration.Button.minimize, true, true)
							
							pDragWindow = window
							pDragArea = Decoration.Area.minimize
							requestCaptureMouse(this)
						end
						return
						
					case Decoration.Area.menu
						if event.getButton() == InputEventMouseButton.left
							BaseGameApp.getApp().getConsole().addMessage("[DESKTOP] Open window menu: " + window.className() + "\n")
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
						end
						return
						
					case Decoration.Area.title
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanMove()
								pDragWindow = window
								pDragOffset = pMouseLocation - window.getPosition()
								pDragArea = Decoration.Area.title
								requestCaptureMouse(this) //captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeLeft
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								pDragWindow = window
								pDragOffset = Point.new(pMouseLocation.getX() - window.getX(), pDragOffset.getY())
								pDragArea = Decoration.Area.resizeLeft
								requestCaptureMouse(this) //captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeTop
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								pDragWindow = window
								pDragOffset = Point.new(pDragOffset.getX(), pMouseLocation.getY() - window.getY())
								pDragArea = Decoration.Area.resizeTop
								requestCaptureMouse(this) //captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeRight
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								pDragWindow = window
								pDragOffset = Point.new(pMouseLocation.getX() - window.getX() - window.getWidth(), pDragOffset.getY())
								pDragArea = Decoration.Area.resizeRight
								requestCaptureMouse(this) //captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeBottom
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								pDragWindow = window
								pDragOffset = Point.new(pDragOffset.getX(), pMouseLocation.getY() - window.getY() - window.getHeight())
								pDragArea = Decoration.Area.resizeBottom
								requestCaptureMouse(this) //captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeTopLeft
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								pDragWindow = window
								pDragOffset = pMouseLocation - window.getPosition()
								pDragArea = Decoration.Area.resizeTopLeft
								requestCaptureMouse(this) //captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeBottomLeft
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								pDragWindow = window
								pDragOffset = pMouseLocation - window.getPosition() - Point.new(0, window.getHeight())
								pDragArea = Decoration.Area.resizeBottomLeft
								requestCaptureMouse(this) //captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeTopRight
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								pDragWindow = window
								pDragOffset = pMouseLocation - window.getPosition() - Point.new(window.getWidth(), 0)
								pDragArea = Decoration.Area.resizeTopRight
								requestCaptureMouse(this) //captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeBottomRight
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								pDragWindow = window
								pDragOffset = pMouseLocation - window.getPosition() - window.getSize()
								pDragArea = Decoration.Area.resizeBottomRight
								requestCaptureMouse(this) //captureMouse()
							end
						end
						return
					end
				end
			end
			
			// decoration not hit or no decoration present
			var Widget widget = window.getWidgetAt(pMouseLocation - window.getPosition())
			if widget == null
				continue
			end
			
			if not window.getCanActivate()
				return
			end
			
			if window.getBlockingWindow() != null
				if window.getCanReorder()
					window.moveToTop()
				end
				window.getTopBlockingWindow().grabFocus()
				return
			end
			
			while widget != null and widget != this
				if not isWidgetDeepEnabled(widget)
					widget = widget.getParent()
					continue
				end
				
				if window.getCanReorder()
					window.moveToTop()
				end
				
				widget.sendEvent(MouseEvent.new(widget, event.getIdentifier(), \
					event.getButton(), event.getModifiers(), \
					pMouseLocation - widget.getScreenPosition(), \
					event.getSystem(), event.getDevice()))
				return
			end
			
			return
		end
	end
	
	/** Notification that a mouse button has been released. */
	public func void onButtonRelease(MouseEvent event)
		// if some lazy bum send his message up to the parent ignore it.
		if event.getSource() != this
			return
		end
		
		var int i, count = getWidgetCount()
		var Window window
		var Widget widget
		
		setMouseLocation(pMouseLocation + event.getPosition())
		
		if pDragWindow != null
			if event.getButton() != InputEventMouseButton.left
				return
			end
			
			requestReleaseMouse(this)
			
			select pDragArea
			case Decoration.Area.close
				if pDragWindow.getDecoration().areaHitBy(pMouseLocation) == Decoration.Area.close
					pDragWindow.getDecoration().setButtonState(Decoration.Button.close, true, false)
					pDragWindow.close()
					
				else
					pDragWindow.getDecoration().setButtonState(Decoration.Button.close, false, false)
				end
				
			case Decoration.Area.maximize
				if pDragWindow.getDecoration().areaHitBy(pMouseLocation) == Decoration.Area.maximize
					pDragWindow.getDecoration().setButtonState(Decoration.Button.maximize, true, false)
					
					if pDragWindow.getCanReorder()
						pDragWindow.moveToTop()
					end
					pDragWindow.grabFocus()
					
					if pDragWindow.getCanMaximize()
						/*
						// TODO not working correctly right now
						
						select pDragWindow.getWindowState()
						case Window.WindowState.maximized
							pDragWindow.setWindowState(Window.WindowState.normal)
							
						case Window.WindowState.normal
							pDragWindow.setWindowState(Window.WindowState.maximized)
						end
						*/
					end
					
				else
					pDragWindow.getDecoration().setButtonState(Decoration.Button.maximize, false, false)
				end
				
			case Decoration.Area.minimize
				if pDragWindow.getDecoration().areaHitBy(pMouseLocation) == Decoration.Area.minimize
					pDragWindow.getDecoration().setButtonState(Decoration.Button.minimize, true, false)
					
					//BaseGameApp.getApp().getConsole().addMessage("[DESKTOP] Minimize window: " + pDragWindow.className() + "\n")
					if pDragWindow.getCanReorder()
						pDragWindow.moveToTop()
					end
					pDragWindow.grabFocus()
					
				else
					pDragWindow.getDecoration().setButtonState(Decoration.Button.minimize, false, false)
				end
			end
			
			pDragArea = Decoration.Area.nothing
			pDragWindow = null
			
		elif pCaptureWidget != null
			//pHoverWidget = pCaptureWidget // mouse move should do this already
			
			if pCaptureWidget != this
				pCaptureWidget.sendEvent(MouseEvent.new(pCaptureWidget, \
					event.getIdentifier(), event.getButton(), event.getModifiers(), \
					pMouseLocation - pCaptureWidget.getScreenPosition(), \
					event.getSystem(), event.getDevice()))
			end
			
		else
			for i = count - 1 downto 0
				window = getWidget(i) cast Window
				if window.getVisible()
					widget = window.getWidgetAt(pMouseLocation - window.getPosition())
					if widget != null
						if isWidgetDeepEnabled(widget)
							//pHoverWidget = widget // mouse move should do this already
							widget.sendEvent(MouseEvent.new(widget, event.getIdentifier(), \
								event.getButton(), event.getModifiers(), \
								pMouseLocation - widget.getScreenPosition(), \
								event.getSystem(), event.getDevice()))
						end
						
						break
					end
				end
			end
		end
	end
	
	/** Notification that the mouse has moved. */
	public func void onMouseMove(MouseEvent event)
		// if some lazy bum send his message up to the parent ignore it.
		if event.getSource() != this
			return
		end
		
		var int i, count = getWidgetCount()
		var Window window
		var Widget widget
		var int ncx, ncy
		
		if InputSystem.getCaptureInputDevices()
			setMouseLocation(pMouseLocation + event.getPosition())
			
		else
			setMouseLocation(event.getPosition())
		end
		
		if pDragWindow != null
			select pDragArea
			case Decoration.Area.close
				pDragWindow.getDecoration().setButtonState(Decoration.Button.close, true, \
					pDragWindow.getDecoration().areaHitBy(pMouseLocation) == Decoration.Area.close)
				
			case Decoration.Area.maximize
				pDragWindow.getDecoration().setButtonState(Decoration.Button.maximize, true, \
					pDragWindow.getDecoration().areaHitBy(pMouseLocation) == Decoration.Area.maximize)
				
			case Decoration.Area.minimize
				pDragWindow.getDecoration().setButtonState(Decoration.Button.minimize, true, \
					pDragWindow.getDecoration().areaHitBy(pMouseLocation) == Decoration.Area.minimize)
				
			case Decoration.Area.title
				pDragWindow.setPosition(pMouseLocation - pDragOffset)
				
			case Decoration.Area.resizeLeft
				ncx = DEMath.max(pDragWindow.getX() + pDragWindow.getWidth() \
					- pMouseLocation.getX() + pDragOffset.getX(), \
						DEMath.max(20, pDragWindow.getMinimumSize().getX()))
				pDragWindow.setX(pDragWindow.getX() + pDragWindow.getWidth() - ncx)
				pDragWindow.setWidth(ncx)
				
			case Decoration.Area.resizeTop
				ncy = DEMath.max(pDragWindow.getY() + pDragWindow.getHeight() \
					- pMouseLocation.getY() + pDragOffset.getY(), \
						DEMath.max(10, pDragWindow.getMinimumSize().getY()))
				pDragWindow.setY(pDragWindow.getY() + pDragWindow.getHeight() - ncy)
				pDragWindow.setHeight(ncy)
				
			case Decoration.Area.resizeRight
				ncx = DEMath.max(pMouseLocation.getX() - pDragOffset.getX() \
					- pDragWindow.getX(), DEMath.max(20, pDragWindow.getMinimumSize().getX()))
				pDragWindow.setWidth(ncx)
				
			case Decoration.Area.resizeBottom
				ncy = DEMath.max(pMouseLocation.getY() - pDragOffset.getY() \
					- pDragWindow.getY(), DEMath.max(10, pDragWindow.getMinimumSize().getY()))
				pDragWindow.setHeight(ncy)
				
			case Decoration.Area.resizeTopLeft
				var Point nsize = (pDragWindow.getPosition() + pDragWindow.getSize() \
					- pMouseLocation + pDragOffset).largest(20, 10) \
						.largest(pDragWindow.getMinimumSize())
				pDragWindow.setPosition(pDragWindow.getPosition() + pDragWindow.getSize() - nsize)
				pDragWindow.setSize(nsize)
				
			case Decoration.Area.resizeBottomLeft
				var Point minsize = pDragWindow.getMinimumSize()
				ncx = DEMath.max(pDragWindow.getX() + pDragWindow.getWidth() \
					- pMouseLocation.getX() + pDragOffset.getX(), DEMath.max(20, minsize.getX()))
				ncy = DEMath.max(pMouseLocation.getY() - pDragOffset.getY() \
					- pDragWindow.getY(), DEMath.max(10, minsize.getY()))
				pDragWindow.setX(pDragWindow.getX() + pDragWindow.getWidth() - ncx)
				pDragWindow.setSize(Point.new(ncx, ncy))
				
			case Decoration.Area.resizeTopRight
				var Point minsize = pDragWindow.getMinimumSize()
				ncx = DEMath.max(pMouseLocation.getX() - pDragOffset.getX() \
					- pDragWindow.getX(), DEMath.max(20, minsize.getX()))
				ncy = DEMath.max(pDragWindow.getY() + pDragWindow.getHeight() \
					- pMouseLocation.getY() + pDragOffset.getY(), DEMath.max(10, minsize.getY()))
				pDragWindow.setY(pDragWindow.getY() + pDragWindow.getHeight() - ncy)
				pDragWindow.setSize(Point.new(ncx, ncy))
				
			case Decoration.Area.resizeBottomRight
				var Point nsize = (pMouseLocation - pDragOffset - pDragWindow.getPosition()) \
					.largest(20, 10).largest(pDragWindow.getMinimumSize())
				pDragWindow.setSize(nsize)
			end
			
		elif pCaptureWidget != null
			setHoverWidget(pCaptureWidget, event)
			
			if pCaptureWidget != this
				pCaptureWidget.sendEvent(MouseEvent.new(pCaptureWidget, \
					event.getIdentifier(), event.getButton(), event.getModifiers(), \
					pMouseLocation - pCaptureWidget.getScreenPosition(), \
					event.getSystem(), event.getDevice()))
			end
			
		else
			var Decoration decoration
			var Decoration.Area decorationArea
			var Widget hoverWidget
			
			// check if mouse hovers over window decoration
			for i = count - 1 downto 0
				window = getWidget(i) cast Window
				if not window.getVisible()
					continue
				end
				
				decoration = window.getDecoration()
				if decoration == null
					continue
				end
				
				decorationArea = decoration.areaHitBy(pMouseLocation)
				if decorationArea == Decoration.Area.nothing
					continue
				end
				
				if not window.getEnabled()
					return // do not alter hover widget
				end
				
				setTrackDecoration(window)
				setTrackDecorationAreaHover(decorationArea)
				return // do not alter hover widget
			end
			
			setTrackDecoration(null)
			
			// find widget the mouse hovers above
			for i = count - 1 downto 0
				window = getWidget(i) cast Window
				if not window.getVisible()
					continue
				end
				
				widget = window.getWidgetAt(pMouseLocation - window.getPosition())
				if widget == null
					continue
				end
				
				if not window.getEnabled()
					return // do not alter hover widget
				end
				
				hoverWidget = widget
				break
			end
			
			if hoverWidget == null
				setHoverWidget(null, event)
				
			else
				setHoverWidget(hoverWidget, event)
				hoverWidget.sendEvent(MouseEvent.new(hoverWidget, event.getIdentifier(), \
					event.getButton(), event.getModifiers(), \
					pMouseLocation - hoverWidget.getScreenPosition(), \
					event.getSystem(), event.getDevice()))
			end
		end
	end
	
	/**
	 * \brief Size changed.
	 * 
	 * Sends event to listeners.
	 */
	public func void onResize(WidgetEvent event)
		super.onResize(event)
		
		updateMaximizedWindowSizes()
		
		forEachWidget(block Window each
			each.onDesktopResized()
		end)
	end
	
	/**
	 * \brief Mouse pointer moved.
	 * \version 1.7
	 */
	public func void onMousePointerMoved(MousePointerEvent event)
		sendEventToListeners(event, false)
	end
	
	/**
	 * \brief Mouse pointer has been hidden.
	 * \version 1.7
	 */
	public func void onMousePointerHidden(MousePointerEvent event)
		sendEventToListeners(event, false)
	end
	
	/**
	 * \brief Mouse pointer has been shown.
	 * \version 1.7
	 */
	public func void onMousePointerShown(MousePointerEvent event)
		sendEventToListeners(event, false)
	end
	
	/**
	 * \brief Mouse pointer changed.
	 * \version 1.7
	 */
	public func void onMousePointerChanged(MousePointerEvent event)
		sendEventToListeners(event, false)
	end
	
	
	
	/**
	 * \brief Send event to all appropriate listeners for events of its kind.
	 * 
	 * If there are no listeners the event is send to the parent if \em sendToParent is \em true.
	 */
	public func void sendEventToListeners(Event event, bool sendToParent)
		var int identifier = event.getIdentifier()
		
		if MousePointerEvent.isMousePointerEvent(identifier)
			if pMousePointerListeners != null and pMousePointerListeners.getCount() > 0
				select identifier
				case MousePointerEvent.idMousePointerMoved
					pMousePointerListeners.forEach(block MousePointerListener each
						each.onMousePointerMoved(event cast MousePointerEvent)
					end)
					
				case MousePointerEvent.idMousePointerHidden
					pMousePointerListeners.forEach(block MousePointerListener each
						each.onMousePointerHidden(event cast MousePointerEvent)
					end)
					
				case MousePointerEvent.idMousePointerShown
					pMousePointerListeners.forEach(block MousePointerListener each
						each.onMousePointerShown(event cast MousePointerEvent)
					end)
					
				case MousePointerEvent.idMousePointerChanged
					pMousePointerListeners.forEach(block MousePointerListener each
						each.onMousePointerChanged(event cast MousePointerEvent)
					end)
				end
				
			elif sendToParent
				var Container parent = this.getParent()
				if parent != null
					parent.sendEvent(event)
				end
			end
			
		else
			super.sendEventToListeners(event, sendToParent)
		end
	end
	
	
	 
	/** Determines if a widget is enabled checking the parents too. */
	public func bool isWidgetDeepEnabled(Widget widget)
		if not widget.getEnabled()
			return false
		end
		
		var Container parent = widget.getParent()
		
		while parent != null
			if not parent.getEnabled()
				return false
			end
			
			parent = parent.getParent()
		end
		
		return true
	end
	
	
	
	/** \brief Update the size of all maximized windows to match desktop size. */
	public func void updateMaximizedWindowSizes()
		var Point size = getSize()
		forEachWidget(block Window each
			if each.getWindowState() == Window.WindowState.maximized
				// TODO we need a way to figure out the maximized area. the decoration boundary
				//      size has to be ignored for this but the title bar has to be visible.
				//      we need to store this somehow in the decoration
				each.setPosition(Point.new())
				each.setSize(size)
			end
		end)
	end
	
	/** \brief Window state changed. */
	public func void windowStateChanged(Window window)
		select window.getWindowState()
		case Window.WindowState.normal
			// TODO
			
		case Window.WindowState.minimized
			// TODO
			
		case Window.WindowState.maximized
			window.setPosition(Point.new())
			window.setSize(getSize())
		end
	end
end
