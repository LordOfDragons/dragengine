/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Events
pin Dragengine.Gui.Layouts
pin Dragengine.Gui.Decorations
pin Dragengine.Gui.MousePointers.Factories
pin Dragengine.Scenery


/**
 * \brief Desktop containing set of windows.
 * 
 * Provides typical desktop support like handling window interaction, focus and hover widget
 * as well as mouse pointer handling.
 * 
 * 
 * 
 * \todo Add support to set mouse pointers for different situations:
 * - normal mouse pointer
 * - resizing mouse pointes: 8 pointers for each direction
 * these also have to go into a new DefaultDesktopDesigner class.
 * change the mouse pointer depending on the situation. mouse pointers should have only the
 * responsibility to provide and update a canvas. complex logic like showing additional
 * widgets like the InfoMousePointer does have to be moved into MouseListener which update
 * widgets matching the mouse pointer position. this separates extended logic from basic
 * design which can be done using XML. It also allows to attach logic to a MousePointer
 * without the need to alter the instance itself.
 */
class Desktop extends Container
	/** \brief widget having the focus or \em null. */
	private var Widget pFocusWidget
	
	/** \brief Grab focus in progress used to solve recusion-problems. */
	private var Widget pFocusInProgress
	
	
	
	/** \brief Widget where the mouse hovers above or \em null. */
	private var Widget pHoverWidget
	
	/** \brief Decoration whose state is tracked or \em null. */
	private var Window pTrackDecoration
	
	/** \brief Tracked decoration area the mouse hovers above. */
	private var Decoration.Area pTrackDecorationAreaHover
	
	
	
	/** \brief Widget having captured the mouse or \em null. */
	private var Widget pCaptureWidget
	
	
	
	/** \brief Mouse pointer location. */
	private var Point pMouseLocation
	
	/** \brief Active mouse pointer factory. */
	private var MousePointerFactory pActiveMousePointer
	
	/** \brief Mouse pointer instance or null. */
	private var MousePointer pMousePointerInstance
	
	/** \brief Mouse movement area restriction or \em null. */
	private var RectArea pMouseArea
	
	/** \brief Mouse pointer is hidden. */
	private var bool pMouseHidden
	
	
	
	/** \brief Drag window or \em null. */
	private var Window pDragWindow
	
	/** \brief Drag offset. */
	private var Point pDragOffset
	
	/** \brief Drag area. */
	private var Decoration.Area pDragArea
	
	
	
	/** \brief Area along the borders no window can occupy. */
	private var BorderSize pNoWindowBorder
	
	
	
	/** \brief Create desktop widget. */
	public func new( int width, int height ) this( 0, 0, width, height )
	end
	
	/** \brief Create desktop widget. */
	public func new( Point size ) this( 0, 0, size.getX(), size.getY() )
	end
	
	/** \brief Create desktop widget. */
	public func new( int x, int y, int width, int height ) super( x, y, width, height )
		this.pDragOffset = Point.new()
		this.pNoWindowBorder = BorderSize.new()
		
		this.pTrackDecorationAreaHover = Decoration.Area.nothing
		
		this.setDesignerSelector( "Desktop" )
		this.setLayout( FixedLayout.new() )
		this.pMouseLocation = Point.new( width / 2, height / 2 )
		this.pMouseHidden = false
	end
	
	
	/** \brief Disposes of widget. */
	public func void dispose()
		this.pFocusWidget = null
		this.pFocusInProgress = null
		
		this.pHoverWidget = null
		this.pTrackDecoration = null
		
		this.pCaptureWidget = null
		
		super.dispose()
	end
	
	
	
	/** \brief Active window or \em null. */
	public func Window getActiveWindow()
		if this.pFocusWidget != null
			return this.pFocusWidget.getWindow()
			
		else
			return null
		end
	end
	
	/** \brief Focused widget or \em null. */
	public func Widget getFocusWidget()
		return this.pFocusWidget
	end
	
	
	
	/** \brief Widget the mouse hovers above or \em null. */
	public func Widget getHoverWidget()
		if this.pHoverWidget != null
			return this.pHoverWidget
			
		else
			return this
		end
	end
	
	/**
	 * \brief Set widget the mouse hovers above.
	 * \details If widget is different than the old one enter and leave messages are send.
	 */
	protected func void setHoverWidget( Widget widget, MouseEvent event )
		if widget == this.pHoverWidget
			return
		end
		
		var Widget leaveWidget = this.pHoverWidget
		
		this.pHoverWidget = widget
		
		if leaveWidget != null
			// runWhileBlockingLayout added to deal with problem of layoutParent calling updateHoverWidget
			// which in turn overwrites pHoverWidget while the next call is running. this results in
			// pHoverWidget different than widget which is wrong
			this.runWhileBlockingLayout( block
				leaveWidget.sendEvent( MouseEvent.new( leaveWidget, \
					MouseEvent.idMouseLeave, event.getButton(), \
					event.getModifiers(), event.getDevice() ) )
			end )
		end
		
		if widget == null
			this.setActiveMousePointer( this.getFirstMousePointer() )
			
		else
			this.setActiveMousePointer( widget.getFirstMousePointer() )
			widget.sendEvent( MouseEvent.new( widget, MouseEvent.idMouseEnter, \
				event.getButton(), event.getModifiers(), event.getDevice() ) )
		end
	end
	
	/**
	 * \brief Update hover widget.
	 * \details Call if the hover widget is removed from the desktop.
	 */
	public func void updateHoverWidget()
		var Widget hoverWidget
		
		if this.pDragWindow != null
			
		elif this.pCaptureWidget != null
			hoverWidget = this.pCaptureWidget
			
		else
			var int i, count = this.getWidgetCount()
			var Window window
			var Widget widget
			
			for i = count - 1 downto 0
				window = this.getWidget( i ) cast Window
				if not window.getVisible()
					continue
				end
				
				widget = window.getWidgetAt( this.pMouseLocation - window.getPosition() )
				if widget == null
					continue
				end
				
				hoverWidget = widget
				break
			end
		end
		
		if hoverWidget == this.pHoverWidget
			return
		end
		
		var MouseEvent event = MouseEvent.new( hoverWidget, MouseEvent.idMouseMoved, 0, 0, Point.new(), -1 )
		
		if hoverWidget == null
			this.setHoverWidget( null, event )
			
		else
			this.setHoverWidget( hoverWidget, event )
		end
	end
	
	/** \brief Clear hover widget. */
	protected func void clearHoverWidget()
		if this.pHoverWidget != null
			this.setHoverWidget( null, MouseEvent.new( this.pHoverWidget, \
				MouseEvent.idMouseLeave, 0, 0, -1 ) )
		end
	end
	
	
	/** \brief Decoration whose state is tracked or \em null. */
	protected func Window getTrackDecoration()
		return this.pTrackDecoration
	end
	
	/** \brief Set decoration whose state is tracked or \em null. */
	protected func void setTrackDecoration( Window window )
		if window == this.pTrackDecoration
			return
		end
		
		this.setTrackDecorationAreaHover( Decoration.Area.nothing )
		this.pTrackDecoration = window
	end
	
	/** \brief Tracked decoration area the mouse hovers above. */
	protected func Decoration.Area getTrackDecorationAreaHover()
		return this.pTrackDecorationAreaHover
	end
	
	/** \brief Set tracked decoration area the mouse hovers above. */
	protected func void setTrackDecorationAreaHover( Decoration.Area areaHover )
		if areaHover == this.pTrackDecorationAreaHover
			return
		end
		
		if this.pTrackDecoration != null
			select this.pTrackDecorationAreaHover
			case Decoration.Area.close
				this.pTrackDecoration.getDecoration().setButtonState( Decoration.Button.close, false, false )
				
			case Decoration.Area.maximize
				this.pTrackDecoration.getDecoration().setButtonState( Decoration.Button.maximize, false, false )
				
			case Decoration.Area.minimize
				this.pTrackDecoration.getDecoration().setButtonState( Decoration.Button.minimize, false, false )
			end
		end
		
		this.pTrackDecorationAreaHover = areaHover
		
		if this.pTrackDecoration != null
			select areaHover
			case Decoration.Area.close
				this.pTrackDecoration.getDecoration().setButtonState( Decoration.Button.close, true, false )
				
			case Decoration.Area.maximize
				this.pTrackDecoration.getDecoration().setButtonState( Decoration.Button.maximize, true, false )
				
			case Decoration.Area.minimize
				this.pTrackDecoration.getDecoration().setButtonState( Decoration.Button.minimize, true, false )
			end
		end
	end
	
	
	
	/** Retrieves the widget having captured the mouse. */
	public func Widget getMouseCaptureWidget()
		return this.pCaptureWidget
	end
	
	
	
	/** \brief Location of mouse pointer. */
	public func Point getMouseLocation()
		return this.pMouseLocation
	end
	
	/**
	 * \brief Set location of mouse pointer.
	 * 
	 * Location is clamped to the mouse movement area.
	 */
	public func void setMouseLocation( Point location )
		if this.pMouseArea != null
			location = this.pMouseArea.clamp( location )
		end
		location = RectArea.new( 0, 0, getWidth() - 1, getHeight() - 1 ).clamp( location )
		if location.equals( this.pMouseLocation )
			return
		end
		
		this.pMouseLocation = location
		
		if this.pMousePointerInstance != null
			this.pMousePointerInstance.setPosition( location )
		end
	end
	
	/**
	 * \brief Warp mouse pointer.
	 * 
	 * Use this method if you move the moue pointer directly as otherwise the appropriate
	 * messages are not send.
	 */
	public func void warpMousePointer( Point location )
		this.onMouseMove( MouseEvent.new( this, MouseEvent.idMouseMoved, 0, 0, \
			location - this.pMouseLocation, -1 ) )
	end
	
	/**
	 * \brief Warp mouse pointer relative to widget.
	 * 
	 * Use this method if you move the moue pointer directly as otherwise the appropriate
	 * messages are not send.
	 */
	public func void warpMouseIn( Widget widget, Point location )
		this.warpMousePointer( widget.getDesktopPosition() + location )
	end
	
	/**
	 * \brief Warp mouse pointer centered in desktop.
	 * 
	 * Use this method if you move the moue pointer directly as otherwise the appropriate
	 * messages are not send.
	 */
	public func void warpCenterMouse()
		this.warpMousePointer( this.getSize() / 2 )
	end
	
	/**
	 * \brief Warp mouse pointer centered inside widget.
	 * 
	 * Use this method if you move the moue pointer directly as otherwise the appropriate
	 * messages are not send.
	 */
	public func void warpCenterMouseIn( Widget widget )
		this.warpMouseIn( widget, widget.getSize() / 2 )
	end
	
	/** \brief Active mouse pointer factory or \em null. */
	public func MousePointerFactory getActiveMousePointer()
		return this.pActiveMousePointer
	end
	
	/**
	 * \brief Set active mouse pointer or \em null.
	 * 
	 * If factory changes a new mouse pointer instance is created if not null.
	 */
	public func void setActiveMousePointer( MousePointerFactory mousePointer )
		if mousePointer == this.pActiveMousePointer
			return
		end
		
		if this.pMousePointerInstance != null
			this.getCanvasWidget().removeCanvas( this.pMousePointerInstance.getCanvas() )
			this.pMousePointerInstance = null
		end
		
		this.pActiveMousePointer = mousePointer
		
		if mousePointer != null
			this.pMousePointerInstance = mousePointer.createMousePointer()
			this.pMousePointerInstance.setPosition( this.pMouseLocation )
			
			var Canvas canvas = this.pMousePointerInstance.getCanvas()
			canvas.setOrder( 1.5 ) // between content and border
			canvas.setVisible( not this.pMouseHidden )
			this.getCanvasWidget().addCanvas( canvas )
		end
	end
	
	/** \brief Mouse pointer instance or null. */
	public func MousePointer getMousePointerInstance()
		return this.pMousePointerInstance
	end
	
	/** \brief Movement area of mouse pointer or \em null if not set. */
	public func RectArea getMouseArea()
		return this.pMouseArea
	end
	
	/** \brief Set movement area of the mouse pointer or \em null to clear. */
	public func void setMouseArea( RectArea area )
		if area != null
			area = area.orientate()
		end
		this.pMouseArea = area
	end
	
	/** \brief Mouse pointer is hidden. */
	public func bool getIsMouseHidden()
		return this.pMouseHidden
	end
	
	/** \brief Set if mouse pointer is hidden. */
	public func void setIsMouseHidden( bool hidden )
		if hidden == this.pMouseHidden
			return
		end
		
		this.pMouseHidden = hidden
		
		if this.pMousePointerInstance != null
			this.pMousePointerInstance.getCanvas().setVisible( not hidden )
		end
	end
	
	
	
	/** \brief Area along the borders no window can occupy. */
	public func BorderSize getNoWindowBorder()
		return this.pNoWindowBorder
	end
	
	/** \brief Set area along the borders no window can occupy. */
	public func void setNoWindowBorder( BorderSize size )
		if size == null
			throw EInvalidParam.new()
		end
		
		if size.equals( this.pNoWindowBorder )
			return
		end
		
		this.pNoWindowBorder = size
	end
	
	/** \brief Top left position excluding no window border. */
	public func Point getNoBorderPosition()
		return Point.new( this.pNoWindowBorder.getLeft(), this.pNoWindowBorder.getTop() )
	end
	
	/** \brief Maximum size excluding no window border. */
	public func Point getNoBorderSize()
		return this.getSize() - this.pNoWindowBorder.getSize()
	end
	
	
	
	/** \brief Add window to desktop. */
	public func void addWidget( Widget widget )
		this.addWidget( widget, null )
	end
	
	/**
	 * \brief Add window to desktop.
	 * \details To add windows use this function rather than addWidget.
	 */
	public func void addWindow( Window window )
		this.addWidget( window, null )
	end
	
	/** \brief Add window to desktop. */
	public func void addWidget( Widget widget, Object settings )
		if not widget castable Window
			throw EInvalidParam.new()
		end
		
		super.addWidget( widget, settings )
		
		if ( widget cast Window ).getWindowState() == Window.WindowState.maximized
			// TODO this is duplicate code. move this code and the one from updateMaximizedWindowSizes()
			//      into Window class. then also store the restored position
			widget.setPosition( Point.new() )
			widget.setSize( this.getSize() )
		end
		
		if widget.getVisible()
			widget.grabFocus()
		end
	end
	
	/**
	 * \brief Add window to desktop.
	 * \details To add windows use this function rather than addWidget.
	 */
	public func void addWindow( Window window, Object settings )
		this.addWidget( window, settings )
	end
	
	/** \brief Remove window from desktop. */
	public func void removeWidget( Widget widget )
		var Window window = widget cast Window
		
		if window == this.pTrackDecoration
			this.setTrackDecoration( null )
		end
		if window.getActivated()
			this.clearFocusWidget()
		end
		this.clearHoverWidget()
		
		if this.pHoverWidget != null
			throw EInvalidParam.new()
		end
		super.removeWidget( widget )
		
		if this.pFocusWidget == null
			this.focusActiveWidgetOfFirstUsableWindow()
		end
		this.updateHoverWidget()
	end
	
	/** \brief Remove all windows from desktop. */
	public func void removeAllWidgets()
		this.clearFocusWidget()
		this.clearHoverWidget()
		super.removeAllWidgets()
	end
	
	
	
	/** Notifies that the current focus widget can no longer hold the focus. */
	public func void giveUpFocus()
		this.clearFocusWidget()
		this.focusActiveWidgetOfFirstUsableWindow()
	end
	
	/** Clears the focus widget. */
	public func void clearFocusWidget()
		if this.pFocusWidget == null
			return
		end
		
		var Window window = this.pFocusWidget.getWindow()
		if window != null
			window.setActivated( false )
		end
		
		var Widget focusWidget = this.pFocusWidget
		
		this.pFocusWidget = null
		focusWidget.setHasFocus( false )
	end
	
	/** \brief Focus the active widget of the top window supporting it if possible. */
	public func void focusActiveWidgetOfFirstUsableWindow()
		var int count = this.getWidgetCount()
		if count == 0
			return
		end
		
		var Window window
		var int i
		
		for i = count - 1 downto 0
			window = this.getWidget( i ) cast Window
			if not window.getVisible() or not window.getCanActivate() \
			or window.getBlockingWindow() != null
				continue
			end
			
			if window.getCanReorder()
				window.moveToTop()
			end
			window.grabFocus()
			return
		end
	end
	
	
	
	/** Request to focus the specified widget. */
	public func void requestGrabFocus( Widget widget )
		super.requestGrabFocus( widget )
		
		// get the windows of the current and new focus widget if existing
		var Window windowNew = widget.getWindow()
		var Window windowOld
		
		if this.pFocusWidget != null
			windowOld = this.pFocusWidget.getWindow()
		end
		
		// if window can not be activated stick with the old window
		if not windowNew.getCanActivate()
			windowNew = windowOld
		end
		
		// update focus and activation states if window changed
		if windowOld != null and windowOld != windowNew
			windowOld.setActivated( false )
		end
		
		// change focus widget sending events
		var Widget focusWidget = this.pFocusWidget
		
		this.pFocusWidget = widget
		
		if focusWidget != null
			focusWidget.setHasFocus( false )
		end
		widget.setHasFocus( true )
		
		// if window changed activate new window and move it to the top
		if windowNew != windowOld
			windowNew.setActivated( true )
			if windowNew.getCanReorder()
				windowNew.moveToTop()
			end
		end
	end
	
	/**
	 * \brief Container allows child widgets to grab the focus.
	 */
	public func bool allowsChildGrabFocus()
		if not this.getEnabled() or not this.getVisible()
			return false
		end
		
		var Container parent = this.getParent()
		if parent == null
			return true
		end
		
		return parent.allowsChildGrabFocus()
	end
	
	/**
	 * \brief Request to capture the mouse for the specified widget.
	 */
	public func bool requestCaptureMouse( Widget widget )
		if widget == null //or this.pCaptureWidget != null
			return false
		end
		
		this.pCaptureWidget = widget
		
		return true
	end
	
	/**
	 * \brief Request to release mouse capture.
	 * \returns \em true if the widget is the capture widget otherwise \em false.
	 */
	public func bool requestReleaseMouse( Widget widget )
		if widget != this.pCaptureWidget
			return false
		end
		
		this.pCaptureWidget = null
		
		this.updateHoverWidget()
		
		return true
	end
	
	
	
	/** Sends an Event to the focus widget or drop it. */
	public func void processEvent( Event event )
		var int ident = event.getIdentifier()
		var Widget eventWidget //, focusWidget
		var Event eventToSend
		
		// check if the event has to work on the focused widget or active window
		if KeyEvent.isKeyEvent( ident )
			var KeyEvent keyEvent = event cast KeyEvent
			eventWidget = this.pFocusWidget
			eventToSend = KeyEvent.new( eventWidget, ident, keyEvent.getKeyCode(), \
				keyEvent.getModifiers(), keyEvent.getKeyChar(), \
				keyEvent.getDevice() , keyEvent.getButtonCode() )
			// send event if an appropriate widget has been found
			if eventWidget != null
				eventWidget.sendEvent( eventToSend )
			end
			
		elif GamepadEvent.isGamepadEvent( ident )
			if this.pFocusWidget != null
				var GamepadEvent gevent = event cast GamepadEvent
				eventToSend = GamepadEvent.new( this.pFocusWidget, ident, gevent.getDevice(), \
					gevent.getCode(), gevent.getModifiers(), gevent.getAxisValue() )
				this.pFocusWidget.sendEvent( eventToSend )
			end
			
		elif ident == MouseEvent.idMouseWheeled
			eventWidget = this.pCaptureWidget
			if eventWidget == null
				// always update the hover widget. if we do not do this it is possible a widget
				// changes while the mouse pointer does not move
				this.updateHoverWidget()
				eventWidget = this.pHoverWidget
			end
			if eventWidget != null
				var MouseEvent mevent = event cast MouseEvent
				eventToSend = MouseEvent.new( eventWidget, ident, mevent.getButton(), \
					mevent.getModifiers(), mevent.getPosition(), mevent.getDevice() )
				eventWidget.sendEvent( eventToSend )
			end
			
		// check for events working with a screen location or to a capture widget
		/*elif MouseEvent.isMouseEvent( ident )
			var MouseEvent mouseEvent = event cast MouseEvent
			this.setMouseLocation( this.pMouseLocation + \
				Point.new( mouseEvent.getX(), mouseEvent.getY() ) )
			if this.pCaptureWidget == null
				eventWidget = this.getWidgetAt( this.pMouseLocation )
			else
				eventWidget = this.pCaptureWidget
			end
			if eventWidget != null
				eventToSend = MouseEvent.new( eventWidget, ident, mouseEvent.getButton(), \
					mouseEvent.getModifiers(), this.pMouseLocation.getX() - eventWidget.getScreenX(), \
					this.pMouseLocation.getY() - eventWidget.getScreenY() )
			end
			// store widget where the mouse is above at the moment
			this.pHoverWidget = eventWidget
			*/
		else
			this.sendEvent( event )
		end
	end
	
	
	
	/**
	 * Retrieves the desktop or null if this widget is not part of a
	 * desktop. The default implementation forwards the request to the
	 * parent with the Desktop or a subclass thereof intercepting.
	 */
	public func Desktop getDesktop()
		return this
	end
	
	/** \brief Widget position in desktop coordinates. */
	public func Point getDesktopPosition()
		return Point.new()
	end
	
	
	
	/**
	 * Layout parent if existing. Modified version to not layout of Desktop.
	 * Desktop widgets have a fixed size and do not change size if their
	 * windows change in any way. Prevents triggering parent layout calls
	 * wasting time. On the other hand check for condition changes altering
	 * stored widgets
	 */
	public func void layoutParent()
		// check if capture widget is no more existing
		if this.pCaptureWidget != null
			if not this.pCaptureWidget.hasParent( this )
				this.pCaptureWidget = null
			end
		end
		
		// check if hover widget changed
		this.updateHoverWidget()
	end
	
	
	
	/** Notification that a mouse button has been pressed. */
	public func void onButtonPress( MouseEvent event )
		if event.getSource() != this
			return // if some lazy bum send his message up to the parent ignore it
		end
		
		this.setMouseLocation( this.pMouseLocation + event.getPosition() )
		
		if this.pCaptureWidget != null
			if this.pCaptureWidget != this
				this.pCaptureWidget.sendEvent( MouseEvent.new( this.pCaptureWidget, \
					event.getIdentifier(), event.getButton(), event.getModifiers(), \
					this.pMouseLocation - this.pCaptureWidget.getScreenPosition(), \
					event.getDevice() ) )
			end
			return
		end
		
		var int i, count = this.getWidgetCount()
		var Window window
		
		for i = count - 1 downto 0
			window = this.getWidget( i ) cast Window
			if not window.getVisible()
				continue
			end
			
			var Decoration decoration = window.getDecoration()
			if decoration != null
				var Decoration.Area hitType = decoration.areaHitBy( this.pMouseLocation )
				if hitType != Decoration.Area.nothing
					if not window.getEnabled() or not window.getCanActivate()
						return
						
					elif window.getBlockingWindow() != null
						if window.getCanReorder()
							window.moveToTop()
						end
						window.getTopBlockingWindow().grabFocus()
						return
					end
					
					select decoration.areaHitBy( this.pMouseLocation )
					case Decoration.Area.close
						if event.getButton() == InputEventMouseButton.left
							decoration.setButtonState( Decoration.Button.close, true, true )
							
							this.pDragWindow = window
							this.pDragArea = Decoration.Area.close
							this.requestCaptureMouse( this )
						end
						return
						
					case Decoration.Area.maximize
						if event.getButton() == InputEventMouseButton.left
							decoration.setButtonState( Decoration.Button.maximize, true, true )
							
							this.pDragWindow = window
							this.pDragArea = Decoration.Area.maximize
							this.requestCaptureMouse( this )
						end
						return
						
					case Decoration.Area.minimize
						if event.getButton() == InputEventMouseButton.left
							decoration.setButtonState( Decoration.Button.minimize, true, true )
							
							this.pDragWindow = window
							this.pDragArea = Decoration.Area.minimize
							this.requestCaptureMouse( this )
						end
						return
						
					case Decoration.Area.menu
						if event.getButton() == InputEventMouseButton.left
							BaseGameApp.getApp().getConsole().addMessage( "[DESKTOP] Open window menu: " + window.className() + "\n" )
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
						end
						return
						
					case Decoration.Area.title
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanMove()
								this.pDragWindow = window
								this.pDragOffset = this.pMouseLocation - window.getPosition()
								this.pDragArea = Decoration.Area.title
								this.requestCaptureMouse( this ) //this.captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeLeft
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								this.pDragWindow = window
								this.pDragOffset = Point.new( this.pMouseLocation.getX() - window.getX(), this.pDragOffset.getY() )
								this.pDragArea = Decoration.Area.resizeLeft
								this.requestCaptureMouse( this ) //this.captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeTop
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								this.pDragWindow = window
								this.pDragOffset = Point.new( this.pDragOffset.getX(), this.pMouseLocation.getY() - window.getY() )
								this.pDragArea = Decoration.Area.resizeTop
								this.requestCaptureMouse( this ) //this.captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeRight
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								this.pDragWindow = window
								this.pDragOffset = Point.new( this.pMouseLocation.getX() - window.getX() - window.getWidth(), this.pDragOffset.getY() )
								this.pDragArea = Decoration.Area.resizeRight
								this.requestCaptureMouse( this ) //this.captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeBottom
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								this.pDragWindow = window
								this.pDragOffset = Point.new( this.pDragOffset.getX(), this.pMouseLocation.getY() - window.getY() - window.getHeight() )
								this.pDragArea = Decoration.Area.resizeBottom
								this.requestCaptureMouse( this ) //this.captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeTopLeft
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								this.pDragWindow = window
								this.pDragOffset = this.pMouseLocation - window.getPosition()
								this.pDragArea = Decoration.Area.resizeTopLeft
								this.requestCaptureMouse( this ) //this.captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeBottomLeft
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								this.pDragWindow = window
								this.pDragOffset = this.pMouseLocation - window.getPosition() - Point.new( 0, window.getHeight() )
								this.pDragArea = Decoration.Area.resizeBottomLeft
								this.requestCaptureMouse( this ) //this.captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeTopRight
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								this.pDragWindow = window
								this.pDragOffset = this.pMouseLocation - window.getPosition() - Point.new( window.getWidth(), 0 )
								this.pDragArea = Decoration.Area.resizeTopRight
								this.requestCaptureMouse( this ) //this.captureMouse()
							end
						end
						return
						
					case Decoration.Area.resizeBottomRight
						if event.getButton() == InputEventMouseButton.left
							if window.getCanReorder()
								window.moveToTop()
							end
							window.grabFocus()
							if window.getCanResize()
								this.pDragWindow = window
								this.pDragOffset = this.pMouseLocation - window.getPosition() - window.getSize()
								this.pDragArea = Decoration.Area.resizeBottomRight
								this.requestCaptureMouse( this ) //this.captureMouse()
							end
						end
						return
					end
				end
			end
			
			// decoration not hit or no decoration present
			var Widget widget = window.getWidgetAt( this.pMouseLocation - window.getPosition() )
			if widget == null
				continue
			end
			
			if not window.getCanActivate()
				return
			end
			
			if window.getBlockingWindow() != null
				if window.getCanReorder()
					window.moveToTop()
				end
				window.getTopBlockingWindow().grabFocus()
				return
			end
			
			while widget != null and widget != this
				if not this.isWidgetDeepEnabled( widget )
					widget = widget.getParent()
					continue
				end
				
				if window.getCanReorder()
					window.moveToTop()
				end
				
				widget.sendEvent( MouseEvent.new( widget, event.getIdentifier(), \
					event.getButton(), event.getModifiers(), \
					this.pMouseLocation - widget.getScreenPosition(), \
					event.getDevice() ) )
				return
			end
			
			return
		end
	end
	
	/** Notification that a mouse button has been released. */
	public func void onButtonRelease( MouseEvent event )
		// if some lazy bum send his message up to the parent ignore it.
		if event.getSource() != this
			return
		end
		
		var int i, count = this.getWidgetCount()
		var Window window
		var Widget widget
		
		this.setMouseLocation( this.pMouseLocation + event.getPosition() )
		
		if this.pDragWindow != null
			if event.getButton() != InputEventMouseButton.left
				return
			end
			
			this.requestReleaseMouse( this )
			
			select this.pDragArea
			case Decoration.Area.close
				if this.pDragWindow.getDecoration().areaHitBy( this.pMouseLocation ) == Decoration.Area.close
					this.pDragWindow.getDecoration().setButtonState( Decoration.Button.close, true, false )
					this.pDragWindow.close()
					
				else
					this.pDragWindow.getDecoration().setButtonState( Decoration.Button.close, false, false )
				end
				
			case Decoration.Area.maximize
				if this.pDragWindow.getDecoration().areaHitBy( this.pMouseLocation ) == Decoration.Area.maximize
					this.pDragWindow.getDecoration().setButtonState( Decoration.Button.maximize, true, false )
					
					if this.pDragWindow.getCanReorder()
						this.pDragWindow.moveToTop()
					end
					this.pDragWindow.grabFocus()
					
					if this.pDragWindow.getCanMaximize()
						/*
						// TODO not working correctly right now
						
						select this.pDragWindow.getWindowState()
						case Window.WindowState.maximized
							this.pDragWindow.setWindowState( Window.WindowState.normal )
							
						case Window.WindowState.normal
							this.pDragWindow.setWindowState( Window.WindowState.maximized )
						end
						*/
					end
					
				else
					this.pDragWindow.getDecoration().setButtonState( Decoration.Button.maximize, false, false )
				end
				
			case Decoration.Area.minimize
				if this.pDragWindow.getDecoration().areaHitBy( this.pMouseLocation ) == Decoration.Area.minimize
					this.pDragWindow.getDecoration().setButtonState( Decoration.Button.minimize, true, false )
					
					//BaseGameApp.getApp().getConsole().addMessage( "[DESKTOP] Minimize window: " + this.pDragWindow.className() + "\n" )
					if this.pDragWindow.getCanReorder()
						this.pDragWindow.moveToTop()
					end
					this.pDragWindow.grabFocus()
					
				else
					this.pDragWindow.getDecoration().setButtonState( Decoration.Button.minimize, false, false )
				end
			end
			
			this.pDragArea = Decoration.Area.nothing
			this.pDragWindow = null
			
		elif this.pCaptureWidget != null
			//this.pHoverWidget = this.pCaptureWidget // mouse move should do this already
			
			if this.pCaptureWidget != this
				this.pCaptureWidget.sendEvent( MouseEvent.new( this.pCaptureWidget, \
					event.getIdentifier(), event.getButton(), event.getModifiers(), \
					this.pMouseLocation - this.pCaptureWidget.getScreenPosition(), \
					event.getDevice() ) )
			end
			
		else
			for i = count - 1 downto 0
				window = this.getWidget( i ) cast Window
				if window.getVisible()
					widget = window.getWidgetAt( this.pMouseLocation - window.getPosition() )
					if widget != null
						if this.isWidgetDeepEnabled( widget )
							//this.pHoverWidget = widget // mouse move should do this already
							widget.sendEvent( MouseEvent.new( widget, event.getIdentifier(), \
								event.getButton(), event.getModifiers(), \
								this.pMouseLocation - widget.getScreenPosition(), \
								event.getDevice() ) )
						end
						
						break
					end
				end
			end
		end
	end
	
	/** Notification that the mouse has moved. */
	public func void onMouseMove( MouseEvent event )
		// if some lazy bum send his message up to the parent ignore it.
		if event.getSource() != this
			return
		end
		
		var int i, count = this.getWidgetCount()
		var Window window
		var Widget widget
		var int ncx, ncy
		
		if InputSystem.getCaptureInputDevices()
			this.setMouseLocation( this.pMouseLocation + event.getPosition() )
			
		else
			this.setMouseLocation( event.getPosition() )
		end
		
		if this.pDragWindow != null
			select this.pDragArea
			case Decoration.Area.close
				this.pDragWindow.getDecoration().setButtonState( Decoration.Button.close, true, \
					this.pDragWindow.getDecoration().areaHitBy( this.pMouseLocation ) == Decoration.Area.close )
				
			case Decoration.Area.maximize
				this.pDragWindow.getDecoration().setButtonState( Decoration.Button.maximize, true, \
					this.pDragWindow.getDecoration().areaHitBy( this.pMouseLocation ) == Decoration.Area.maximize )
				
			case Decoration.Area.minimize
				this.pDragWindow.getDecoration().setButtonState( Decoration.Button.minimize, true, \
					this.pDragWindow.getDecoration().areaHitBy( this.pMouseLocation ) == Decoration.Area.minimize )
				
			case Decoration.Area.title
				this.pDragWindow.setPosition( this.pMouseLocation - this.pDragOffset )
				
			case Decoration.Area.resizeLeft
				ncx = DEMath.max( this.pDragWindow.getX() + this.pDragWindow.getWidth() \
					- this.pMouseLocation.getX() + this.pDragOffset.getX(), \
						DEMath.max( 20, this.pDragWindow.getMinimumSize().getX() ) )
				this.pDragWindow.setX( this.pDragWindow.getX() + this.pDragWindow.getWidth() - ncx )
				this.pDragWindow.setWidth( ncx )
				
			case Decoration.Area.resizeTop
				ncy = DEMath.max( this.pDragWindow.getY() + this.pDragWindow.getHeight() \
					- this.pMouseLocation.getY() + this.pDragOffset.getY(), \
						DEMath.max( 10, this.pDragWindow.getMinimumSize().getY() ) )
				this.pDragWindow.setY( this.pDragWindow.getY() + this.pDragWindow.getHeight() - ncy )
				this.pDragWindow.setHeight( ncy )
				
			case Decoration.Area.resizeRight
				ncx = DEMath.max( this.pMouseLocation.getX() - this.pDragOffset.getX() \
					- this.pDragWindow.getX(), DEMath.max( 20, this.pDragWindow.getMinimumSize().getX() ) )
				this.pDragWindow.setWidth( ncx )
				
			case Decoration.Area.resizeBottom
				ncy = DEMath.max( this.pMouseLocation.getY() - this.pDragOffset.getY() \
					- this.pDragWindow.getY(), DEMath.max( 10, this.pDragWindow.getMinimumSize().getY() ) )
				this.pDragWindow.setHeight( ncy )
				
			case Decoration.Area.resizeTopLeft
				var Point nsize = ( this.pDragWindow.getPosition() + this.pDragWindow.getSize() \
					- this.pMouseLocation + this.pDragOffset ).largest( 20, 10 ) \
						.largest( this.pDragWindow.getMinimumSize() )
				this.pDragWindow.setPosition( this.pDragWindow.getPosition() + this.pDragWindow.getSize() - nsize )
				this.pDragWindow.setSize( nsize )
				
			case Decoration.Area.resizeBottomLeft
				var Point minsize = this.pDragWindow.getMinimumSize()
				ncx = DEMath.max( this.pDragWindow.getX() + this.pDragWindow.getWidth() \
					- this.pMouseLocation.getX() + this.pDragOffset.getX(), DEMath.max( 20, minsize.getX() ) )
				ncy = DEMath.max( this.pMouseLocation.getY() - this.pDragOffset.getY() \
					- this.pDragWindow.getY(), DEMath.max( 10, minsize.getY() ) )
				this.pDragWindow.setX( this.pDragWindow.getX() + this.pDragWindow.getWidth() - ncx )
				this.pDragWindow.setSize( Point.new( ncx, ncy ) )
				
			case Decoration.Area.resizeTopRight
				var Point minsize = this.pDragWindow.getMinimumSize()
				ncx = DEMath.max( this.pMouseLocation.getX() - this.pDragOffset.getX() \
					- this.pDragWindow.getX(), DEMath.max( 20, minsize.getX() ) )
				ncy = DEMath.max( this.pDragWindow.getY() + this.pDragWindow.getHeight() \
					- this.pMouseLocation.getY() + this.pDragOffset.getY(), DEMath.max( 10, minsize.getY() ) )
				this.pDragWindow.setY( this.pDragWindow.getY() + this.pDragWindow.getHeight() - ncy )
				this.pDragWindow.setSize( Point.new( ncx, ncy ) )
				
			case Decoration.Area.resizeBottomRight
				var Point nsize = ( this.pMouseLocation - this.pDragOffset - this.pDragWindow.getPosition() ) \
					.largest( 20, 10 ).largest( this.pDragWindow.getMinimumSize() )
				this.pDragWindow.setSize( nsize )
			end
			
		elif this.pCaptureWidget != null
			this.setHoverWidget( this.pCaptureWidget, event )
			
			if this.pCaptureWidget != this
				this.pCaptureWidget.sendEvent( MouseEvent.new( this.pCaptureWidget, \
					event.getIdentifier(), event.getButton(), event.getModifiers(), \
					this.pMouseLocation - this.pCaptureWidget.getScreenPosition(), \
					event.getDevice() ) )
			end
			
		else
			var Decoration decoration
			var Decoration.Area decorationArea
			var Widget hoverWidget
			
			// check if mouse hovers over window decoration
			for i = count - 1 downto 0
				window = this.getWidget( i ) cast Window
				if not window.getVisible()
					continue
				end
				
				decoration = window.getDecoration()
				if decoration == null
					continue
				end
				
				decorationArea = decoration.areaHitBy( this.pMouseLocation )
				if decorationArea == Decoration.Area.nothing
					continue
				end
				
				if not window.getEnabled()
					return // do not alter hover widget
				end
				
				this.setTrackDecoration( window )
				this.setTrackDecorationAreaHover( decorationArea )
				return // do not alter hover widget
			end
			
			this.setTrackDecoration( null )
			
			// find widget the mouse hovers above
			for i = count - 1 downto 0
				window = this.getWidget( i ) cast Window
				if not window.getVisible()
					continue
				end
				
				widget = window.getWidgetAt( this.pMouseLocation - window.getPosition() )
				if widget == null
					continue
				end
				
				if not window.getEnabled()
					return // do not alter hover widget
				end
				
				hoverWidget = widget
				break
			end
			
			if hoverWidget == null
				this.setHoverWidget( null, event )
				
			else
				this.setHoverWidget( hoverWidget, event )
				hoverWidget.sendEvent( MouseEvent.new( hoverWidget, event.getIdentifier(), \
					event.getButton(), event.getModifiers(), \
					this.pMouseLocation - hoverWidget.getScreenPosition(), \
					event.getDevice() ) )
			end
		end
	end
	
	/**
	 * \brief Size changed.
	 * 
	 * Sends event to listeners.
	 */
	public func void onResize( WidgetEvent event )
		super.onResize( event )
		
		this.updateMaximizedWindowSizes()
		
		this.forEachWidget( block Window each
			each.onDesktopResized()
		end )
	end
	
	
	 
	/** Determines if a widget is enabled checking the parents too. */
	public func bool isWidgetDeepEnabled( Widget widget )
		if not widget.getEnabled()
			return false
		end
		
		var Container parent = widget.getParent()
		
		while parent != null
			if not parent.getEnabled()
				return false
			end
			
			parent = parent.getParent()
		end
		
		return true
	end
	
	
	
	/** \brief Update the size of all maximized windows to match desktop size. */
	public func void updateMaximizedWindowSizes()
		var Point size = this.getSize()
		this.forEachWidget( block Window each
			if each.getWindowState() == Window.WindowState.maximized
				// TODO we need a way to figure out the maximized area. the decoration boundary
				//      size has to be ignored for this but the title bar has to be visible.
				//      we need to store this somehow in the decoration
				each.setPosition( Point.new() )
				each.setSize( size )
			end
		end )
	end
	
	/** \brief Window state changed. */
	public func void windowStateChanged( Window window )
		select window.getWindowState()
		case Window.WindowState.normal
			// TODO
			
		case Window.WindowState.minimized
			// TODO
			
		case Window.WindowState.maximized
			window.setPosition( Point.new() )
			window.setSize( this.getSize() )
		end
	end
end
