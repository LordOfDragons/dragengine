/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

namespace Dragengine.Gui


/**
 * \brief Immutable rectangular area.
 * 
 * Coordinate (x2,y2) is exclusive. Hence the rectangular area includes all points except
 * row y2 and column x2.
 */
fixed class RectArea
	var int pX1, pY1, pX2, pY2
	
	
	
	/** \name Constructors */
	/*@{*/
	/** \brief Create rectangular area with all coordinates set to 0. */
	func new()
	end
	
	/** \brief Create rectangular area with initial coordinates. */
	func new(int x1, int y1, int x2, int y2)
		pX1 = x1
		pY1 = y1
		pX2 = x2
		pY2 = y2
	end
	
	/** \brief Create copy of rectangular area. */
	func new(RectArea rect)
		pX1 = rect.pX1
		pY1 = rect.pY1
		pX2 = rect.pX2
		pY2 = rect.pY2
	end
	
	/** \brief Create recangular area from a point and size. */
	func new(Point position, Point size)
		pX1 = position.getX()
		pY1 = position.getY()
		pX2 = pX1 + size.getX()
		pY2 = pY1 + size.getY()
	end
	/*@}*/
	
	
	
	/** \name Management */
	/*@{*/
	/** \brief X1-Coordinate. */
	func int getX1()
		return pX1
	end
	
	/** \brief Y1-Coordinate. */
	func int getY1()
		return pY1
	end
	
	/** \brief X2-Coordinate. */
	func int getX2()
		return pX2
	end
	
	/** \brief Y2-Coordinate. */
	func int getY2()
		return pY2
	end
	
	/** \brief Orientate rectangular area placing (x1,y1) top-left and (x2,y2) bottom-right. */
	func RectArea orientate()
		var int x1, x2, y1, y2
		
		if pX2 > pX1
			x1 = pX1
			x2 = pX2
		else
			x1 = pX2
			x2 = pX1
		end
		if pY2 > pY1
			y1 = pY1
			y2 = pY2
		else
			y1 = pY2
			y2 = pY1
		end
		
		return RectArea.new(x1, y1, x2, y2)
	end
	
	/** \brief Position. */
	func Point getPosition()
		return Point.new(pX1, pY1)
	end
	
	/** \brief Size. */
	func Point getSize()
		return Point.new(pX2 - pX1, pY2 - pY1)
	end
	
	/**
	 * \brief Width.
	 * \version 1.13
	 */
	func int getWidth()
		return pX2 - pX1
	end
	
	/**
	 * \brief Height.
	 * \version 1.13
	 */
	func int getHeight()
		return pY2 - pY1
	end
	
	/** 
	 * \brief Top-left corner (x1, y1).
	 * \version 1.13
	 */
	func Point getTopLeft()
		return Point.new(pX1, pY1)
	end
	
	/** 
	 * \brief Top-right corner (x2, y1).
	 * \version 1.13
	 */
	func Point getTopRight()
		return Point.new(pX2, pY1)
	end
	
	/** 
	 * \brief Bottom-left corner (x1, y2).
	 * \version 1.13
	 */
	func Point getBottomLeft()
		return Point.new(pX1, pY2)
	end
	
	/** 
	 * \brief Bottom-right corner (x2, y2).
	 * \version 1.13
	 */
	func Point getBottomRight()
		return Point.new(pX2, pY2)
	end
	
	/** \brief Rectangular area moved by offset. */
	func RectArea move(int x, int y)
		return new(pX1 + x, pY1 + y, pX2 + x, pY2 + y)
	end
	
	/** \brief Rectangular area moved by offset. */
	func RectArea move(Point distance)
		return move(distance.getX(), distance.getY())
	end
	
	/** \brief Rectangular area grown by size at bottom right. */
	func RectArea grow(int x, int y)
		return new(pX1, pY1, pX2 + x, pY2 + y)
	end
	
	/** \brief Rectangular area grown by size at bottom right. */
	func RectArea grow(Point size)
		return grow(size.getX(), size.getY())
	end
	
	/** \brief Rectangular area grown by size at top left. */
	func RectArea growInverse(int x, int y)
		return new(pX1 - x, pY1 - y, pX2, pY2)
	end
	
	/** \brief Rectangular area grown by size at top left. */
	func RectArea growInverse(Point size)
		return growInverse(size.getX(), size.getY())
	end
	
	/** \brief Rectangular area grown to include another rectangular area. */
	func RectArea include(RectArea rect)
		return RectArea.new(DEMath.min(pX1, rect.pX1), DEMath.min(pY1, rect.pY1), \
			DEMath.max(pX2, rect.pX2), DEMath.max(pY2, rect.pY2))
	end
	
	/** \brief Rectangular area set to the intersection area between two rectangular areas. */
	func RectArea intersect(RectArea rect)
		return RectArea.new(DEMath.max(pX1, rect.pX1), DEMath.max(pY1, rect.pY1), \
			DEMath.min(pX2, rect.pX2), DEMath.min(pY2, rect.pY2))
	end
	
	/**
	 * \brief Point clamped to rectangular area.
	 * 
	 * This excludes the row y2 and column x2 unless the width or height is 0.
	 */
	func Point clamp(Point point)
		return Point.new(DEMath.clamp(point.getX(), pX1, pX2 - 1),\
			DEMath.clamp(point.getY(), pY1, pY2 - 1))
	end
	
	/**
	 * \brief Width is 0 (x1=x2).
	 * \version 1.29
	 */
	func bool isZeroWidth()
		return pX1 == pX2
	end
	
	/**
	 * \brief Height is 0 (y1=y2).
	 * \version 1.29
	 */
	func bool isZeroHeight()
		return pY1 == pY2
	end
	
	/**
	 * \brief Size is 0 (x1=x2, y1=y2).
	 * \version 1.29
	 */
	func bool isZeroSize()
		return pX1 == pX2 and pY1 == pY2
	end
	
	/**
	 * \brief Width or height is 0 (x1=x2 or y1=y2).
	 * \version 1.29
	 */
	func bool isZeroWidthOrHeight()
		return pX1 == pX2 or pY1 == pY2
	end
	
	/**
	 * \brief Point is inside rectangular area.
	 * 
	 * This excludes the row y2 and column x2. If the width or height is 0 the point is never inside.
	 */
	func bool isInside(int x, int y)
		return x >= pX1 and x < pX2 and y >= pY1 and y < pY2
	end
	
	/**
	 * \brief Point is inside rectangular area along X axis.
	 * \version 1.29
	 * 
	 * This excludes the column x2. If the width is 0 the point is never inside.
	 */
	func bool isInsideX(int x)
		return x >= pX1 and x < pX2
	end
	
	/**
	 * \brief Point is inside rectangular area along Y axis.
	 * \version 1.29
	 * 
	 * This excludes the row y2. If the height is 0 the point is never inside.
	 */
	func bool isInsideY(int y)
		return y >= pY1 and y < pY2
	end
	
	/**
	 * \brief Rectangular areas overlap.
	 * \version 1.29
	 */
	func bool isOverlapping(RectArea rect)
		return rect.pX1 < pX2 and rect.pX2 > pX1 and rect.pY1 < pY2 and rect.pY2 > pY1
	end
	
	/**
	 * \brief Rectangular areas overlap in X direction.
	 * \version 1.29
	 */
	func bool isOverlappingX(RectArea rect)
		return rect.pX1 < pX2 and rect.pX2 > pX1
	end
	
	/**
	 * \brief Rectangular areas overlap in Y direction.
	 * \version 1.29
	 */
	func bool isOverlappingY(RectArea rect)
		return rect.pY1 < pY2 and rect.pY2 > pY1
	end
	
	
	
	/** \brief Rectangular areas is equal to another rectangular area. */
	func bool isEqual(RectArea rect)
		return pX1 == rect.pX1 and pY1 == rect.pY1 and pX2 == rect.pX2 and pY2 == rect.pY2
	end
	
	/** \brief String representation. */
	func String toString()
		return "RectArea({},{},{},{})".format(Array.newWith(pX1, pY1, pX2, pY2))
	end
	/*@}*/
	
	
	
	/** \name File Handling */
	/*@{*/
	/** \brief Read rectangular area from file reader. */
	static func RectArea readFromFile(FileReader reader)
		var RectArea area = RectArea.new()
		area.pX1 = reader.readInt()
		area.pY1 = reader.readInt()
		area.pX2 = reader.readInt()
		area.pY2 = reader.readInt()
		return area
	end
	
	/** \brief Write rectangular area to file writer. */
	func void writeToFile(FileWriter writer)
		writer.writeInt(pX1)
		writer.writeInt(pY1)
		writer.writeInt(pX2)
		writer.writeInt(pY2)
	end
	/*@}*/
end
