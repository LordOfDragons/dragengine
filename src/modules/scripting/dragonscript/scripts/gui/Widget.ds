/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Borders
pin Dragengine.Gui.CanvasCreators
pin Dragengine.Gui.Designers
pin Dragengine.Gui.Events
pin Dragengine.Gui.MousePointers.Factories
pin Dragengine.Scenery
pin Dragengine.Utils


/**
 * Widget base class. Represents a graphical screen component.
 */
class Widget
	/** \brief Repeat key event timer. */
	class RepeatKeyEventTimer extends Timer
		var Widget pWidget
		var KeyEvent pEvent
		
		/** \brief Create time. */
		func new(Widget widget, KeyEvent event) super(0.5, true)
			pWidget = widget
			pEvent = event
		end
		
		/** \brief Timer elapsed. */
		func void fire()
			setTriggerTime(0.05)
			pWidget.sendEvent(pEvent)
		end
		
		/** \brief Event to repeat. */
		func KeyEvent getEvent()
			return pEvent
		end
	end
	
	/** \brief Frame update listener. */
	private class FrameUpdater extends FrameUpdateListener
		/** \brief Widget to update. */
		var Widget pWidget
		
		/** \brief Create frame update listener. */
		func new(Widget widget)
			pWidget = widget
		end
		
		/** \brief Do frame update. */
		func void frameUpdate(float elapsed)
			pWidget.onFrameUpdate(elapsed)
		end
	end
	
	
	
	var Container pParent
	var Border pBorder
	var Point pPosition, pSize, pMinSize
	var bool pVisible, pEnabled, pHasFocus, pCanFocus, pCanFocusDirectional
	var Color pTextColor
	var float pTransparency
	var Font pFont
	var String pTitle
	
	var TexMatrix2 pTransformation
	
	var Array pKeyListeners, pMouseListeners, pDragListeners, pFocusListeners, pWidgetListeners,\
		pStateChangeListeners, pGamepadListeners
	
	var MousePointerFactory pMousePointer
	
	var GuiTheme pTheme
	var String pThemeSelector
	
	var RepeatKeyEventTimer pRepeatEventTimer
	var FrameUpdater pFrameUpdater
	
	var CanvasView pCanvasWidget, pCanvasBackground, pCanvasContent
	var CanvasCreator pBackgroundCanvasCreator
	
	var WidgetDesigner pDesigner
	var bool pIsDesignerSet
	var String pDesignerSelector
	
	var BorderSize pPadding
	
	var bool pProtectBackgroundCanvasCreator, pProtectBorder, pProtectPadding, pProtectFont,\
		pProtectTextColor, pProtectMinimumSize, pProtectMousePointer
	
	var Object pToolTip
	
	var Clipboard pClipboard
	
	var TranslationManager pTranslationManager
	
	var bool pBlockLayoutParent, pHasBlockedLayoutParent
	
	
	
	/** \brief Create widget. */
	func new() this(0, 0, 0, 0)
	end
	
	/**
	 * \brief Create widget with initial location and size.
	 * 
	 * Width and height are clamped to 0 at minimum. Negative sizes can not be used.
	 */
	func new(int x, int y, int width, int height) \
	this(Point.new(x, y), Point.new(width, height))
	end
	
	/**
	 * \brief Create widget with initial location and size.
	 * 
	 * Width and height are clamped to 0 at minimum. Negative sizes can not be used.
	 */
	func new(Point position, Point size)
		pPosition = position
		pSize = Point.new().largest(size)
		
		pVisible = pEnabled = true
		pTitle = ""
		
		pTransparency = 1
		pIsDesignerSet = false
		pPadding = BorderSize.new()
		
		pKeyListeners = Array.new()
		pMouseListeners = Array.new()
		pDragListeners = Array.new()
		pFocusListeners = Array.new()
		pWidgetListeners = Array.new()
		pStateChangeListeners = Array.new()
		pGamepadListeners = Array.new()
		
		createCanvas()
		updateCanvasGeometry()
		updateCanvasBackground()
	end
	
	
	
	/**
	 * Disposes of the widget cleaning references.
	 * 
	 * \warning
	 * This does not remove the widget from the parent container if present. Calling this
	 * method while a widget is still inside a parent container will cause exceptions.
	 * Use \ref #safeDispose() to safely dispose of a widget.
	 */
	func void dispose()
		pBlockLayoutParent = true
		
		if pWidgetListeners == null
			return // already disposed
		end
		
		// can be expensive if every widget calls it although there is no really use case
		// in sight. if this really becomes necessary somewhere down the line add an option
		// to enable this notification only where required. until then disabled
		if pWidgetListeners.getCount() > 0
			onDispose(WidgetEvent.new(this, WidgetEvent.idWidgetDispose))
		end
		
		stopRepeatEventTimer()
		stopFrameUpdater()
		
		pBackgroundCanvasCreator = null
		pEnabled = false
		pVisible = false
		pParent = null
		pKeyListeners = null
		pMouseListeners = null
		pDragListeners = null
		pFocusListeners = null
		pWidgetListeners = null
		pStateChangeListeners = null
		pGamepadListeners = null
		pCanvasContent = null
		pCanvasBackground = null
		pCanvasWidget = null
		pBorder = null
		pDesigner = null
	end
	
	/**
	 * \brief Safely dispose of widget.
	 * 
	 * If widget has parent removes the widget from the parent before calling \ref #dispose().
	 * 
	 * \note
	 * 
	 * It is recommended to use \ref #safeDispose() instead of \ref #dispose() to be on the safe side.
	 */
	func void safeDispose()
		if pParent != null
			pParent.removeWidget(this)
		end
		dispose()
	end
	
	
	
	/** Retrieves the parent of widget or null if there is none. */
	func Container getParent()
		return pParent
	end
	
	/** Determines if this widget is parent directly or indirectly to a given container. */
	func bool hasParent(Container container)
		if container == null or pParent == null
			return false
			
		elif pParent == container
			return true
			
		else
			return pParent.hasParent(container)
		end
	end
	
	
	
	/** Layout parent if existing. Call if a change potentially alters the size requirements. */
	func void layoutParent()
		// this is an optimization which causes a problem with one particular situation.
		// if setVisible(false) is called while the widget is visible the final layoutParent()
		// call is skipped if this optimization below is in place. we need though this to
		// properly layout parents if widgets become invisible so this check is removed.
		// performance impact should be acceptable if all widgets try to avoid calling
		// layoutParent() if they are not visible
		/*
		if not pVisible
			return
		end
		*/
		if pParent == null
			return
		end
		
		if pBlockLayoutParent
			pHasBlockedLayoutParent = true
			return
		end
		
		pHasBlockedLayoutParent = false
		pParent.doLayout()
	end
	
	/**
	 * \brief Calls layoutParent if getHasBlockedLayoutParent() is true.
	 * \version 1.23
	 * 
	 * Call this instead of calling layoutParent() directly to improve performance by not
	 * calling layoutParent() if not required. This method is typically called after calling
	 * runWhileBlockingLayoutParent().
	 */
	func void layoutParentIfBlocked()
		if pHasBlockedLayoutParent
			layoutParent()
		end
	end
	
	/**
	 * \brief layoutParent calls happened during runWhileBlockingLayoutParent.
	 * \version 1.23
	 */
	func bool getHasBlockedLayoutParent()
		return pHasBlockedLayoutParent
	end
	
	/**
	 * \brief Set if layoutParent calls happened during runWhileBlockingLayoutParent.
	 * \version 1.23
	 */
	func void setHasBlockedLayoutParent(bool hasBlockedLayoutParent)
		pHasBlockedLayoutParent = hasBlockedLayoutParent
	end
	
	/**
	 * \brief Block layoutParent calls.
	 * \version 1.23
	 * 
	 * Used to prevent deadloops and performance problems with layoutParent/doLayout calls.
	 * Be careful to disable blocking even in case of exceptions. Also make sure to restore
	 * the block layout call in place before changing it by yourself to not break chains.
	 */
	func bool getBlockLayoutParent()
		return pBlockLayoutParent
	end
	
	/**
	 * \brief Set block layoutParent calls.
	 * \version 1.23
	 * 
	 * Used to prevent deadloops and performance problems with layoutParent/doLayout calls.
	 * Be careful to disable blocking even in case of exceptions. Also make sure to restore
	 * the block layout call in place before changing it by yourself to not break chains.
	 */
	func void setBlockLayoutParent(bool blockLayoutParent)
		pBlockLayoutParent = blockLayoutParent
	end
	
	/**
	 * \brief Run block while layouting is blocked.
	 * \version 1.23
	 * 
	 * This method is useful when you do multiple changes to a widget avoiding layoutParent
	 * calls to be done for each modification except once to avoid performance loss. The
	 * method ensures the blocking state is restored to the value present before even in
	 * case of exceptions. You still have to call layoutParent() to trigger an update after
	 * returning from the method call. This method call can be nested safely.
	 */
	func void runWhileBlockingLayoutParent(Block ablock)
		if pBlockLayoutParent
			ablock.run()
			return
		end
		
		pBlockLayoutParent = true
		
		try
			ablock.run()
			pBlockLayoutParent = false
			
		catch Exception e
			pBlockLayoutParent = false
			throw
		end
	end
	
	
	
	/** Retrieves the border or null if not set. */
	func Border getBorder()
		return pBorder
	end
	
	/** Sets the border or null if not set. */
	func void setBorder(Border border)
		if border == pBorder
			return
		end
		
		if pBorder != null
			getCanvasWidget().removeCanvas(pBorder.getCanvas())
			pBorder.setWidget(null)
		end
		
		pBorder = border
		
		if border != null
			border.setWidget(this)
			border.resizeCanvas(pSize)
			border.getCanvas().setOrder(2.0)
			getCanvasWidget().addCanvas(border.getCanvas())
		end
		
		updateCanvasGeometry()
		layoutParent()
	end
	
	/** Get border size. If no border is set an empty border size is returned.*/
	func BorderSize getBorderSize()
		if pBorder == null
			return BorderSize.new()
		end
		return pBorder.getBorderSize()
	end
	
	/** Notify border about changes to the widget parameters potentially affecing the border. */
	func void notifyBorderParametersChanged()
		if pBorder != null
			pBorder.onWidgetParametersChanged()
		end
	end
	
	
	
	/** \brief Position of the widget. */
	func Point getPosition()
		return pPosition
	end
	
	/** \brief X position of widget. */
	func int getX()
		return pPosition.getX()
	end
	
	/** \brief Y position of widget. */
	func int getY()
		return pPosition.getY()
	end
	
	/** \brief Set position of widget. */
	func void setPosition(Point position)
		if position.isEqualTo(pPosition)
			return
		end
		
		pPosition = position
		
		onReposition(WidgetEvent.new(this, WidgetEvent.idWidgetReposition))
		updateCanvasGeometry()
	end
	
	/** \brief Set X position of widget. */
	func void setX(int x)
		setPosition(Point.new(x, pPosition.getY()))
	end
	
	/** \brief Set Y Position of widget. */
	func void setY(int y)
		setPosition(Point.new(pPosition.getX(), y))
	end
	
	
	
	/** \brief Size of the widget. */
	func Point getSize()
		return pSize
	end
	
	/** \brief Width of widget. */
	func int getWidth()
		return pSize.getX()
	end
	
	/** \brief Height of widget. */
	func int getHeight()
		return pSize.getY()
	end
	
	/** \brief Set size of widget. */
	func void setSize(Point size)
		size = Point.new().largest(size)
		if size.isEqualTo(pSize)
			return
		end
		
		pSize = size
		
		updateCanvasGeometry()
		onResize(WidgetEvent.new(this, WidgetEvent.idWidgetResized))
		updateCanvasBackground()
	end
	
	/** \brief Set width of widget. */
	func void setWidth(int width)
		setSize(Point.new(width, pSize.getY()))
	end
	
	/** \brief Set height of widget. */
	func void setHeight(int height)
		setSize(Point.new(pSize.getX(), height))
	end
	
	/** \brief Rectangular boundary of the widget. */
	func RectArea getBoundary()
		return RectArea.new(pPosition, pSize)
	end
	
	/** \brief Rectangular boundary of the widget including border. */
	func RectArea getBoundaryWithBorder()
		if pBorder == null
			return getBoundary()
		end
		
		var BorderSize size = pBorder.getBorderSize()
		return RectArea.new(pPosition - Point.new(size.getLeft(), size.getTop()), pSize + size.getSize())
	end
	
	/**
	 * \brief Rectangular boundary of widget relative to parent.
	 * \version 1.29
	 */
	func RectArea getRelativeBoundary(Container parent)
		return RectArea.new(getRelativePosition(parent), pSize)
	end
	
	/**
	 * \brief Rectangular boundary of widget including border relative to parent.
	 */
	func RectArea getRelativeBoundaryWithBorder(Container parent)
		if pBorder == null
			return getRelativeBoundary(parent)
		end
		
		var BorderSize size = pBorder.getBorderSize()
		return RectArea.new(getRelativePosition(parent)\
			- Point.new(size.getLeft(), size.getTop()), pSize + size.getSize())
	end
	
	/**
	 * \brief Rectangular boundary of widget relative to desktop.
	 * \version 1.29
	 */
	func RectArea getDesktopBoundary()
		return RectArea.new(getDesktopPosition(), pSize)
	end
	
	/**
	 * \brief Rectangular boundary of widget including border relative to parent.
	 */
	func RectArea getDesktopBoundaryWithBorder()
		if pBorder == null
			return getDesktopBoundary()
		end
		
		var BorderSize size = pBorder.getBorderSize()
		return RectArea.new(getDesktopPosition()\
			- Point.new(size.getLeft(), size.getTop()), pSize + size.getSize())
	end
	
	
	/** Retrieve the minimal size of widget. */
	func Point getMinimumSize()
		if pMinSize != null
			return pMinSize
			
		else
			return Point.new()
		end
	end
	
	/** Retrieve the minimal size of widget including the border size if one is set. */
	func Point getMinimumSizeWithBorder()
		if pBorder == null
			return getMinimumSize()
		end
		return getMinimumSize() + pBorder.getBorderSize().getSize()
	end
	
	/** Retrieve the set minimal size of widget or null. */
	func Point getSetMinimumSize()
		return pMinSize
	end
	
	/** Determines if the minimal size is set explicitly. */
	func bool isMinimumSizeSet()
		return pMinSize != null
	end
	
	
	
	/**
	 * \brief Minimum size of widget using reference widget width and variable height.
	 * \details Default implementation uses getMinimumSize().
	 */
	func Point getMinimumSizeForWidth(int width)
		return getMinimumSize()
	end
	
	/**
	 * \brief Minimum size of widget using reference widget height and variable width.
	 * \details Default implementation uses getMinimumSize().
	 */
	func Point getMinimumSizeForHeight(int height)
		return getMinimumSize()
	end
	
	/**
	 * \brief Minimum size of widget with border for reference width.
	 * 
	 * Convenience method for Layout implementations to get the minimum size of a widget
	 * using getMinimumSizeForWidth() including border. Calls getMinimumSizeForWidth()
	 * with the border width (if present) subtracted from width. The border size is then
	 * added to the result.
	 */
	func Point getMinimumSizeWithBorderForWidth(int width)
		if pBorder == null
			return getMinimumSizeForWidth(width)
			
		else
			var BorderSize borderSize = pBorder.getBorderSize()
			return getMinimumSizeForWidth(\
				DEMath.max(width - borderSize.getWidth(), 0)) \
					+ borderSize.getSize()
		end
	end
	
	/**
	 * \brief Minimum size of widget with border using reference height.
	 * 
	 * Convenience method for Layout implementations to get the minimum size of a widget
	 * using getMinimumSizeForHeight() including border. Calls getMinimumSizeForHeight()
	 * with the border height (if present) subtracted from height. The border size is then
	 * added to the result.
	 */
	func Point getMinimumSizeWithBorderForHeight(int height)
		if pBorder == null
			return getMinimumSizeForHeight(height)
			
		else
			var BorderSize borderSize = pBorder.getBorderSize()
			return getMinimumSizeForHeight(\
				DEMath.max(height - borderSize.getHeight(), 0)) \
					+ borderSize.getSize()
		end
	end
	
	
	
	/** \brief Padding. */
	func BorderSize getPadding()
		return pPadding
	end
	
	/** \brief Set padding. */
	func void setPadding(BorderSize padding)
		if padding.equals(pPadding)
			return
		end
		
		pPadding = padding
		onPaddingChanged()
	end
	
	
	
	/** Retrieve if widget is visible. */
	func bool getVisible()
		return pVisible
	end
	
	/** Retrieve if widget is enabled. */
	func bool getEnabled()
		return pEnabled
	end
	
	/** \brief Widget and all parent widgets are enabled. */
	func bool isFullEnabled()
		if pParent == null
			return pEnabled
			
		else
			return pEnabled and pParent.isFullEnabled()
		end
	end
	
	/** Retrieve if widget has the focus. */
	func bool getHasFocus()
		return pHasFocus
	end
	
	/** Retrieve if widget can get the focus. */
	func bool getCanFocus()
		return pCanFocus
	end
	
	/** \brief Text color. */
	func Color getTextColor()
		return pTextColor
	end
	
	/** Retrieve transparency of widget. */
	func float getTransparency()
		return pTransparency
	end
	
	/**
	 * Retrieve total transparency of widget. This is the transparency of this
	 * widget multiplied by the total transparency of the parent.
	 */
	func float getTotalTransparency()
		if pParent == null
			return pTransparency
		end
		return pTransparency * pParent.getTotalTransparency()
	end
	
	/** Retrieve font of widget. */
	func Font getFont()
		if pFont != null
			return pFont
		end
		
		var GuiTheme guiTheme = getGuiTheme()
		if guiTheme != null
			return guiTheme.getWidgetFont()
		end
		
		return null
	end
	
	/** Transformation or null if not set. */
	func TexMatrix2 getTransformation()
		return pTransformation
	end
	
	/** Set transformation or null if not set. */
	func void setTransformation(TexMatrix2 transformation)
		pTransformation = transformation
	end
	
	/** Transformation is set. */
	func bool isTransformationSet()
		return pTransformation != null
	end
	
	/** \brief Color transformation. */
	func ColorMatrix getColorTransformation()
		return pCanvasWidget.getColorTransform()
	end
	
	/** \brief Set color transformation. */
	func void setColorTransformation(ColorMatrix transformation)
		pCanvasWidget.setColorTransform(transformation)
	end
	
	
	
	/**
	 * \brief Widget title.
	 * \version 1.13
	 * 
	 * For use by borders and decorators to provide a title to a widget.
	 */
	func String getTitle()
		return pTitle
	end
	
	/**
	 * \brief Set widget title.
	 * \version 1.13
	 * 
	 * For use by borders and decorators to provide a title to a widget.
	 */
	func void setTitle(String title)
		if title.equals(pTitle)
			return
		end
		
		pTitle = title
		notifyBorderParametersChanged()
	end
	
	
	
	/** \brief Background canvas creator or \em null to use background color. */
	func CanvasCreator getBackgroundCanvasCreator()
		return pBackgroundCanvasCreator
	end
	
	/** \brief Set background canvas creator or \em null to use background color. */
	func void setBackgroundCanvasCreator(CanvasCreator creator)
		if creator == pBackgroundCanvasCreator
			return
		end
		
		pBackgroundCanvasCreator = creator
		updateCanvasBackground()
	end
	
	
	
	/** \brief Designer. */
	func WidgetDesigner getDesigner()
		return pDesigner
	end
	
	/** \brief Set designer. */
	func void setDesigner(WidgetDesigner designer)
		if designer != null and designer == pDesigner
			return
		end
		
		if designer == null
			designer = getDesignerFromTheme()
			pIsDesignerSet = false
			
		else
			pIsDesignerSet = true
		end
		
		pDesigner = designer
		
		onDesignerChanged()
		
		design()
	end
	
	/** \brief Get designer from gui theme. */
	protected func WidgetDesigner getDesignerFromTheme()
		if pDesignerSelector == null
			return null
		end
		
		var GuiTheme guitheme = getGuiTheme()
		if guitheme == null
			return null
		end
		
		return guitheme.getWidgetDesigner(pDesignerSelector)
	end
	
	/** \brief Custom designer is set. */
	func bool isDesignerSet()
		return pIsDesignerSet
	end
	
	/**
	 * \brief Designer selector.
	 * 
	 * Selects designer from gui theme. Selector composes of alphanumeric identifier.
	 * A chain of identifiers can be specified separated by periods. If a chain is
	 * defined the full chain is first checked to find the designer. If not found the
	 * right most identifier is stripped and the remaining chain checked for a match.
	 * The first match is used. This allows to add optional quallifier identifers at
	 * the end of the chain for future use while still matching broader designers
	 * in the mean time.
	 * 
	 * If null no designer is used from gui theme. Otherwise use class name (for example
	 * Widget) with optional qualifiers appended if necessary.
	 */
	func String getDesignerSelector()
		return pDesignerSelector
	end
	
	/**
	 * \brief Set designer selector.
	 * 
	 * Selects designer from gui theme. Selector composes of alphanumeric identifier.
	 * A chain of identifiers can be specified separated by periods. If a chain is
	 * defined the full chain is first checked to find the designer. If not found the
	 * right most identifier is stripped and the remaining chain checked for a match.
	 * The first match is used. This allows to add optional quallifier identifers at
	 * the end of the chain for future use while still matching broader designers
	 * in the mean time.
	 * 
	 * If null no designer is used from gui theme. Otherwise use class name (for example
	 * Widget) with optional qualifiers appended if necessary.
	 */
	func void setDesignerSelector(String selector)
		if pDesignerSelector == null
			if selector == null
				return
			end
			
		else
			if pDesignerSelector.equals(selector)
				return
			end
		end
		
		pDesignerSelector = selector
		
		if not pIsDesignerSet
			setDesigner(null) // set designer from gui theme
		end
		
		onDesignerSelectorChanged()
	end
	
	
	
	/** \brief Protect custom set background canvas creator. */
	func bool getProtectBackgroundCanvasCreator()
		return pProtectBackgroundCanvasCreator
	end
	
	/** \brief Set protect custom set background canvas creator. */
	func void setProtectBackgroundCanvasCreator(bool protect)
		pProtectBackgroundCanvasCreator = protect
	end
	
	/** \brief Protect custom set border. */
	func bool getProtectBorder()
		return pProtectBorder
	end
	
	/** \brief Set protect custom set border. */
	func void setProtectBorder(bool protect)
		pProtectBorder = protect
	end
	
	/** \brief Protect custom set padding. */
	func bool getProtectPadding()
		return pProtectPadding
	end
	
	/** \brief Set protect custom set padding. */
	func void setProtectPadding(bool protect)
		pProtectPadding = protect
	end
	
	/** \brief Protect custom set font. */
	func bool getProtectFont()
		return pProtectFont
	end
	
	/** \brief Set protect custom set font. */
	func void setProtectFont(bool protect)
		pProtectFont = protect
	end
	
	/** \brief Protect custom set text color. */
	func bool getProtectTextColor()
		return pProtectTextColor
	end
	
	/** \brief Set protect custom set text color. */
	func void setProtectTextColor(bool protect)
		pProtectTextColor = protect
	end
	
	/** \brief Protect custom set minimumsize. */
	func bool getProtectMinimumSize()
		return pProtectMinimumSize
	end
	
	/** \brief Set protect custom set minimumsize. */
	func void setProtectMinimumSize(bool protect)
		pProtectMinimumSize = protect
	end
	
	/** \brief Protect custom set mouse pointer. */
	func bool getProtectMousePointer()
		return pProtectMousePointer
	end
	
	/** \brief Set protect custom set mouse pointer. */
	func void setProtectMousePointer(bool protect)
		pProtectMousePointer = protect
	end
	
	
	
	/**
	 * \brief Tooltip or null.
	 * \version 1.7
	 * 
	 * Object is typically of type String or StyledTextDocument. Other object types are
	 * possible if the tool tip providing object supports it.
	 */
	func Object getToolTip()
		return pToolTip
	end
	
	/**
	 * \brief Set tooltip or null.
	 * \version 1.7
	 * 
	 * Object is typically of type String or StyledTextDocument. Other object types are
	 * possible if the tool tip providing object supports it.
	 */
	func void setToolTip(Object toolTip)
		if toolTip == pToolTip
			return
		end
		
		pToolTip = toolTip
		
		var Desktop desktop = getDesktop()
		if desktop != null and getHoverWidget() == this and desktop.getToolTipManager() != null
			desktop.getToolTipManager().update()
		end
	end
	
	
	/**
	 * \brief Mouse pointer to use.
	 * 
	 * If widget has no mouse pointer the parent mouse pointer is used.
	 */
	func MousePointerFactory getMousePointer()
		return pMousePointer
	end
	
	/**
	 * \brief Set mouse pointer to use.
	 * 
	 * If widget has no mouse pointer the parent mouse pointer is used.
	 */
	func void setMousePointer(MousePointerFactory mousePointer)
		if mousePointer == pMousePointer
			return
		end
		
		pMousePointer = mousePointer
		
		var Desktop desktop = getDesktop()
		if desktop != null and getHoverWidget() == this
			desktop.setActiveMousePointer(getFirstMousePointer())
		end
		
		notifyBorderParametersChanged()
	end
	
	/**
	 * \brief First assigned mouse pointer.
	 * 
	 * If the Widget has a mouse pointer this one is returned otherwise the one of the
	 * parent. Can be null if no widget up to top most one has an assigned mouse pointer.
	 */
	func MousePointerFactory getFirstMousePointer()
		if pMousePointer != null
			return pMousePointer
			
		elif pParent != null
			return pParent.getFirstMousePointer()
			
		else
			return null
		end
	end
	
	
	
	/** \brief Widget position in window coordinates. */
	func Point getWindowPosition()
		if pParent == null
			return pPosition
			
		else
			return pParent.getWindowPosition() + pPosition
		end
	end
	
	/** \brief Widget position in desktop coordinates. */
	func Point getDesktopPosition()
		if pParent == null
			return pPosition
			
		else
			return pParent.getDesktopPosition() + pPosition
		end
	end
	
	/** \brief Widget position in screen coordinates. */
	func Point getScreenPosition()
		if pParent == null
			return pPosition
			
		else
			return pParent.getScreenPosition() + pPosition
		end
	end
	
	/** \brief Widget position in parent widget coordinates. */
	func Point getRelativePosition(Container parent)
		if this == parent
			return Point.new()
			
		elif pParent == null or pParent == parent
			return pPosition
			
		else
			return pParent.getRelativePosition(parent) + pPosition
		end
	end
	
	/** Retrieves the rect area on the screen of the widget. */
	func RectArea getScreenRectArea()
		return RectArea.new(getScreenPosition(), pSize)
	end
	
	/**
	 * \brief Parent desktop mouse location in widget coordinates.
	 * \version 1.23
	 * 
	 * If no parent desktop is found zero point is returned.
	 */
	func Point getLocalMouseLocation()
		var Desktop desktop = getDesktop()
		if desktop != null
			return desktop.getMouseLocation() - getDesktopPosition()
			
		else
			return Point.new()
		end
	end
	
	
	
	/** Sets if widget is visible. */
	func void setVisible(bool visible)
		if pVisible == visible
			return
		end
		
		pVisible = visible
		
		if not visible
			stopRepeatEventTimer()
		end
		
		pCanvasWidget.setVisible(visible)
		
		if visible
			onShown(WidgetEvent.new(this, WidgetEvent.idWidgetShown))
			
		else
			onHidden(WidgetEvent.new(this, WidgetEvent.idWidgetHidden))
		end
		
		layoutParent()
	end
	
	/** Sets if widget is enabled. */
	func void setEnabled(bool enabled)
		if pEnabled == enabled
			return
		end
		
		pEnabled = enabled
		
		//if not enabled
		//	releaseMouse()
		//end
		
		if pHasFocus and not enabled
			setHasFocus(false)
		end
		
		notifyBorderParametersChanged()
		onStateChanged(StateChangeEvent.new(this, StateChangeEvent.idStateChanged))
	end
	
	/** Sets if widget has the focus. */
	func void setHasFocus(bool hasFocus)
		if pHasFocus == hasFocus
			return
		end
		
		pHasFocus = hasFocus
		
		if not hasFocus
			stopRepeatEventTimer()
		end
		
		notifyBorderParametersChanged()
		
		if hasFocus
			onFocusReceived(FocusEvent.new(this, FocusEvent.idFocusReceived))
			
		else
			onFocusLost(FocusEvent.new(this, FocusEvent.idFocusLost))
		end
	end
	
	/** Sets if widget can get the focus. */
	func void setCanFocus(bool canFocus)
		if pCanFocus == canFocus
			return
		end
		
		pCanFocus = canFocus
		
		if not pCanFocus and pHasFocus
			setHasFocus(false)
		end
		
		notifyBorderParametersChanged()
		onStateChanged(StateChangeEvent.new(this, StateChangeEvent.idStateChanged))
	end
	
	/** Sets the minimum size of widget or null if there is no limit. */
	func void setMinimumSize(Point size)
		if size != null
			size = Point.new().largest(size)
		end
		
		if size == pMinSize or (size != null and size.equals(pMinSize))
			return
		end
		
		pMinSize = size
		layoutParent()
	end
	
	/** \brief Set text color. */
	func void setTextColor(Color color)
		if color == pTextColor or (color != null and color.equals(pTextColor))
			return
		end
		
		pTextColor = color
		onSetTextColor()
	end
	
	/** Sets transparency of widget. */
	func void setTransparency(float transparency)
		transparency = DEMath.clamp(transparency, 0.0, 1.0)
		if DEMath.fabs(transparency - pTransparency) < 0.001
			return
		end
		
		pTransparency = transparency
		pCanvasWidget.setTransparency(transparency)
	end
	
	/** Sets new font of widget or null to use the gui theme one. */
	func void setFont(Font font)
		if pFont == font
			return
		end
		
		pFont = font
		onSetFont()
	end
	
	/**
	 * \brief Widget can get focus using directional navigation.
	 * \version 1.29
	 */
	func bool getCanFocusDirectional()
		return pCanFocusDirectional
	end
	
	/**
	 * \brief Set if widget can get focus using directional navigation.
	 * \version 1.29
	 */
	func void setCanFocusDirectional(bool canFocus)
		pCanFocusDirectional = canFocus
	end
	
	
	/**
	 * Sets the parent of widget. Use this function with caution. It should
	 * only be used by widgets which can contain other widgets to set their
	 * parent widget.
	 */
	func void setParent(Container parent)
		if parent == pParent
			return
		end
		
		if parent == null
			// avoid triggering costly updates if not connected to visible gui anymore
			pParent = parent
			return
		end
		
		var GuiTheme oldGuiTheme = getGuiTheme()
		pParent = parent
		
		if getGuiTheme() != oldGuiTheme
			onGuiThemeChanged()
		end
	end
	
	
	
	/**
	 * \brief Vertical range model for viewports to synchronize the vertical scrollbar.
	 * \details If this widget has no reasonable vertical range model it should return \em null.
	 */
	func RangeModel getVerticalRangeModel()
		return null
	end
	
	/**
	 * \brief Horizontal range model for viewports to synchronize the horizontal scrollbar.
	 * \details If this widget has no reasonable horizontal range model it should return \em null.
	 */
	func RangeModel getHorizontalRangeModel()
		return null
	end
	
	
	
	/** Canvas view for the entire widget. */
	func CanvasView getCanvasWidget()
		return pCanvasWidget
	end
	
	/** Canvas view for the widget background. */
	func CanvasView getCanvasBackground()
		return pCanvasBackground
	end
	
	/** Canvas view for the widget content. */
	func CanvasView getCanvasContent()
		return pCanvasContent
	end
	
	
	
	/**
	 * \brief Widget the mouse hovers above or null.
	 * \version 1.11
	 * 
	 * Asks parent for hover widget otherwise returns null.
	 */
	func Widget getHoverWidget()
		return pParent != null if pParent.getHoverWidget() else null
	end
	
	/**
	 * \brief Mouse is hovering over this widget.
	 * \details Tests if the hover widget of the parent desktop is this widget.
	 */
	func bool isMouseInside()
		return getHoverWidget() == this
	end
	
	
	
	/** Add key listener. */
	func void addKeyListener(KeyListener listener)
		if listener == null
			throw EInvalidParam.new()
		end
		pKeyListeners.add(listener)
	end
	
	/** Remove key listener. */
	func void removeKeyListener(KeyListener listener)
		pKeyListeners.remove(listener)
	end
	
	/** Add mouse listener. */
	func void addMouseListener(MouseListener listener)
		if listener == null
			throw EInvalidParam.new()
		end
		pMouseListeners.add(listener)
	end
	
	/** Remove mouse listener. */
	func void removeMouseListener(MouseListener listener)
		pMouseListeners.remove(listener)
	end
	
	/** Add drag listener. */
	func void addDragListener(DragListener listener)
		if listener == null
			throw EInvalidParam.new()
		end
		
		pDragListeners.add(listener)
	end
	
	/** Remove a drag listener. */
	func void removeDragListener(DragListener listener)
		pDragListeners.remove(listener)
	end
	
	/** \brief Add focus listener. */
	func void addFocusListener(FocusListener listener)
		if listener == null
			throw EInvalidParam.new()
		end
		pFocusListeners.add(listener)
	end
	
	/** \brief Remove focus listener. */
	func void removeFocusListener(FocusListener listener)
		pFocusListeners.remove(listener)
	end
	
	/** \brief Add widget listener. */
	func void addWidgetListener(WidgetListener listener)
		if listener == null
			throw EInvalidParam.new()
		end
		pWidgetListeners.add(listener)
	end
	
	/** \brief Remove widget listener. */
	func void removeWidgetListener(WidgetListener listener)
		pWidgetListeners.remove(listener)
	end
	
	/** \brief Add state change listener. */
	func void addStateChangeListener(StateChangeListener listener)
		if listener == null
			throw EInvalidParam.new()
		end
		pStateChangeListeners.add(listener)
	end
	
	/** \brief Remove state change listener. */
	func void removeStateChangeListener(StateChangeListener listener)
		pStateChangeListeners.remove(listener)
	end
	
	/** \brief Add gamepad listener. */
	func void addGamepadListener(GamepadListener listener)
		if listener == null
			throw EInvalidParam.new()
		end
		pGamepadListeners.add(listener)
	end
	
	/** \brief Remove gamepad listener. */
	func void removeGamepadListener(GamepadListener listener)
		pGamepadListeners.remove(listener)
	end
	
	
	
	/**
	 * Sends an event to the widget. The Widget will check for focus grab
	 * and other situations and sends the event to all registered listeners.
	 */
	func void sendEvent(Event event)
		select event.getIdentifier()
		case KeyEvent.idKeyPressed
			if pHasFocus and event.getSource() == this
				startRepeatKey(event cast KeyEvent)
			end
			onKeyPress(event cast KeyEvent)
			
		case KeyEvent.idKeyReleased
			stopRepeatEventTimer()
			onKeyRelease(event cast KeyEvent)
			
			
			
		case MouseEvent.idMousePressed
			onButtonPress(event cast MouseEvent)
			
		case MouseEvent.idMouseReleased
			onButtonRelease(event cast MouseEvent)
			
		case MouseEvent.idMouseMoved
			onMouseMove(event cast MouseEvent)
			
		case MouseEvent.idMouseWheeled
			onMouseWheel(event cast MouseEvent)
			
		case MouseEvent.idMouseEnter
			onMouseEnter(event cast MouseEvent)
			
		case MouseEvent.idMouseLeave
			onMouseLeave(event cast MouseEvent)
			
			
			
		case DragEvent.idDragEnter
			onDragEnter(event cast DragEvent)
			
		case DragEvent.idDragLeave
			onDragLeave(event cast DragEvent)
			
		case DragEvent.idDragOver
			onDragOver(event cast DragEvent)
			
		case DragEvent.idDragDrop
			onDragDrop(event cast DragEvent)
			
			
			
		case FocusEvent.idFocusReceived
			onFocusReceived(event cast FocusEvent)
			
		case FocusEvent.idFocusLost
			onFocusLost(event cast FocusEvent)
			
			
			
		case WidgetEvent.idWidgetShown
			onShown(event cast WidgetEvent)
			
		case WidgetEvent.idWidgetHidden
			onHidden(event cast WidgetEvent)
			
		case WidgetEvent.idWidgetReposition
			onReposition(event cast WidgetEvent)
			
		case WidgetEvent.idWidgetResized
			onResize(event cast WidgetEvent)
			
		case WidgetEvent.idWidgetDispose
			onDispose(event cast WidgetEvent)
			
			
			
		case StateChangeEvent.idStateChanged
			onStateChanged(event cast StateChangeEvent)
			
			
			
		case GamepadEvent.idGamepadAxisMoved
			onGamepadAxisMoved(event cast GamepadEvent)
			
		case GamepadEvent.idGamepadButtonPressed
			onGamepadButtonPressed(event cast GamepadEvent)
			
		case GamepadEvent.idGamepadButtonReleased
			onGamepadButtonReleased(event cast GamepadEvent)
		end
	end
	
	/**
	 * \brief Send event to all appropriate listeners for events of its kind.
	 * \details If there are no listeners the event is send to the parent if
	 *          \em sendToParent is \em true.
	 */
	func void sendEventToListeners(Event event, bool sendToParent)
		var int ident = event.getIdentifier()
		
		if KeyEvent.isKeyEvent(ident)
			if pKeyListeners != null and pKeyListeners.getCount() > 0
				select ident
				case KeyEvent.idKeyPressed
					pKeyListeners.forEach(block KeyListener each
						each.onKeyPress(event cast KeyEvent)
					end)
					
				case KeyEvent.idKeyReleased
					pKeyListeners.forEach(block KeyListener each
						each.onKeyRelease(event cast KeyEvent)
					end)
				end
				
			elif sendToParent and pParent != null
				pParent.sendEvent(event)
			end
			
		elif MouseEvent.isMouseEvent(ident)
			if pMouseListeners != null and pMouseListeners.getCount() > 0
				select ident
				case MouseEvent.idMousePressed
					pMouseListeners.forEach(block MouseListener each
						each.onButtonPress(event cast MouseEvent)
					end)
					
				case MouseEvent.idMouseReleased
					pMouseListeners.forEach(block MouseListener each
						each.onButtonRelease(event cast MouseEvent)
					end)
					
				case MouseEvent.idMouseMoved
					pMouseListeners.forEach(block MouseListener each
						each.onMouseMove(event cast MouseEvent)
					end)
					
				case MouseEvent.idMouseWheeled
					pMouseListeners.forEach(block MouseListener each
						each.onMouseWheel(event cast MouseEvent)
					end)
					
				case MouseEvent.idMouseEnter
					pMouseListeners.forEach(block MouseListener each
						each.onMouseEnter(event cast MouseEvent)
					end)
					
				case MouseEvent.idMouseLeave
					pMouseListeners.forEach(block MouseListener each
						each.onMouseLeave(event cast MouseEvent)
					end)
				end
				
			elif sendToParent and pParent != null
				pParent.sendEvent(event)
			end
			
		elif DragEvent.isDragEvent(ident)
			if pDragListeners != null and pDragListeners.getCount() > 0
				select ident
				case DragEvent.idDragEnter
					pDragListeners.forEach(block DragListener each
						each.onDragEnter(event cast DragEvent)
					end)
					
				case DragEvent.idDragLeave
					pDragListeners.forEach(block DragListener each
						each.onDragLeave(event cast DragEvent)
					end)
					
				case DragEvent.idDragOver
					pDragListeners.forEach(block DragListener each
						each.onDragOver(event cast DragEvent)
					end)
					
				case DragEvent.idDragDrop
					pDragListeners.forEach(block DragListener each
						each.onDragDrop(event cast DragEvent)
					end)
				end
				
			elif sendToParent and pParent != null
				pParent.sendEvent(event)
			end
			
		elif FocusEvent.isFocusEvent(ident)
			if pFocusListeners != null and pFocusListeners.getCount() > 0
				select ident
				case FocusEvent.idFocusReceived
					pFocusListeners.forEach(block FocusListener each
						each.onFocusReceived(event cast FocusEvent)
					end)
					
				case FocusEvent.idFocusLost
					pFocusListeners.forEach(block FocusListener each
						each.onFocusLost(event cast FocusEvent)
					end)
				end
			end
			
		elif WidgetEvent.isWidgetEvent(ident)
			if pWidgetListeners != null and pWidgetListeners.getCount() > 0
				select ident
				case WidgetEvent.idWidgetShown
					pWidgetListeners.forEach(block WidgetListener each
						each.onWidgetShown(event cast WidgetEvent)
					end)
					
				case WidgetEvent.idWidgetHidden
					pWidgetListeners.forEach(block WidgetListener each
						each.onWidgetHidden(event cast WidgetEvent)
					end)
					
				case WidgetEvent.idWidgetReposition
					pWidgetListeners.forEach(block WidgetListener each
						each.onWidgetReposition(event cast WidgetEvent)
					end)
					
				case WidgetEvent.idWidgetResized
					pWidgetListeners.forEach(block WidgetListener each
						each.onWidgetResize(event cast WidgetEvent)
					end)
					
				case WidgetEvent.idWidgetDispose
					pWidgetListeners.forEach(block WidgetListener each
						each.onWidgetDispose(event cast WidgetEvent)
					end)
				end
			end
			
		elif StateChangeEvent.isStateChangeEvent(ident)
			if pStateChangeListeners != null and pStateChangeListeners.getCount() > 0
				select ident
				case StateChangeEvent.idStateChanged
					pStateChangeListeners.forEach(block StateChangeListener each
						each.onStateChanged(event cast StateChangeEvent)
					end)
				end
			end
			
		elif GamepadEvent.isGamepadEvent(ident)
			if pGamepadListeners != null and pGamepadListeners.getCount() > 0
				select ident
				case GamepadEvent.idGamepadAxisMoved
					pGamepadListeners.forEach(block GamepadListener each
						each.onGamepadAxisMoved(event cast GamepadEvent)
					end)
					
				case GamepadEvent.idGamepadButtonPressed
					pGamepadListeners.forEach(block GamepadListener each
						each.onGamepadButtonPressed(event cast GamepadEvent)
					end)
					
				case GamepadEvent.idGamepadButtonReleased
					pGamepadListeners.forEach(block GamepadListener each
						each.onGamepadButtonReleased(event cast GamepadEvent)
					end)
				end
				
			elif sendToParent and pParent != null
				pParent.sendEvent(event)
			end
		end
	end
	
	
	
	/**
	 * \brief Gui theme to use for this widget.
	 * 
	 * If an explicit gui theme is assigned it is used. Otherwise the gui theme of the
	 * parent widget is requested if present. If a gui theme selector is assigned the
	 * parent gui theme is queried for the gui theme with matching name. If no such
	 * gui theme exists the parent gui theme itself is used.
	 * 
	 * This list details the gui theme chosen in order of preference:
	 * - Assigned gui theme if not null
	 * - Named gui theme of parent gui theme if not null
	 * - Parent gui theme if not null
	 * - null gui theme
	 */
	func GuiTheme getGuiTheme()
		if pTheme != null
			return pTheme
		end
		
		if pParent == null
			return null
		end
		
		var GuiTheme theme = pParent.getGuiTheme()
		
		if theme != null and pThemeSelector != null
			var GuiTheme selected = theme.getNamedGuiTheme(pThemeSelector)
			if selected != null
				theme = selected
			end
		end
		
		return theme
	end
	
	/** Sets the gui theme for this widget. */
	func void setGuiTheme(GuiTheme theme)
		if pTheme == theme
			return
		end
		
		pTheme = theme
		
		onGuiThemeChanged()
	end
	
	/** Determines if this widget has the theme set explicitly. */
	func bool isGuiThemeSet()
		return pTheme != null
	end
	
	/** \brief Gui theme selector or \em null if not used. */
	func String getThemeSelector()
		return pThemeSelector
	end
	
	/** \brief Set gui theme selector or \em null if not used. */
	func void setThemeSelector(String selector)
		if pThemeSelector == null
			if selector == null
				return
			end
			
		else
			if pThemeSelector.equals(selector)
				return
			end
		end
		
		pThemeSelector = selector
		
		onGuiThemeChanged()
	end
	
	
	
	/**
	 * \brief Translation manager to use for this widget.
	 * \version 1.20
	 * 
	 * Can be null to disable translations. Initialized with BaseGameApp TranslationManager.
	 * 
	 * If an explicit translation manager is assigned it is used. Otherwise the translation
	 * manager of the parent widget is requested. If the parent can not provide a translation
	 * manager TranslationManager.get() is used.
	 */
	func TranslationManager getTranslationManager()
		if pTranslationManager != null
			return pTranslationManager
		end
		
		var TranslationManager tm
		if pParent != null
			tm = pParent.getTranslationManager()
		end
		
		if tm == null
			tm = TranslationManager.get()
		end
		
		return tm
	end
	
	/**
	 * \brief Set translation manager to use.
	 * \version 1.20
	 */
	func void setTranslationManager(TranslationManager translationManager)
		if pTranslationManager == translationManager
			return
		end
		
		pTranslationManager = translationManager
		
		onTranslationChanged()
	end
	
	/**
	 * \brief Widget has language translation set explicitly.
	 * \version 1.20
	 */
	func bool isTranslationManagerSet()
		return pTranslationManager != null
	end
	
	/**
	 * \brief Translate text if it is a translateable.
	 * \version 1.20
	 * 
	 * Translates text of the form "@Translation.Entry.Name". If the translation entry can not
	 * be found the text itself is returned. Translation is first attempted using
	 * getTranslationManager(). If this yields no result EngineTranslations.get() is used.
	 */
	func String translate(String text)
		if text.startsWith("@")
			var UnicodeString t = translateEntry(text.substring(1))
			if t != null
				text = t.toUTF8()
			end
		end
		return text
	end
	
	/**
	 * \brief Get translation for translation entry name if found.
	 * \version 1.20
	 * 
	 * If the translation entry can not be found null is returned. Translation is first
	 * attempted using getTranslationManager(). If this yields no result
	 * EngineTranslations.get() is used.
	 */
	func UnicodeString translateEntry(String name)
		var UnicodeString t = getTranslationManager().translate(name, null)
		if t == null
			t = EngineTranslations.get().translate(name, null)
		end
		return t
	end
	
	
	
	/**
	 * Notification that a mouse button has been pressed. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onButtonPress(MouseEvent event)
		if event.getSource() == this
			grabFocus()
		end
		sendEventToListeners(event, true)
	end
	
	/**
	 * Notification that a mouse button has been released. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onButtonRelease(MouseEvent event)
		sendEventToListeners(event, true)
	end
	
	/**
	 * Notification that the mouse has moved. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onMouseMove(MouseEvent event)
		sendEventToListeners(event, true)
	end
	
	/**
	 * \brief Mouse wheel has moved.
	 * 
	 * Default behaviour sends event to listeners or propagates event to parent if allowed.
	 */
	func void onMouseWheel(MouseEvent event)
		sendEventToListeners(event, true)
	end
	
	/**
	 * Notification that the mouse entered the widget. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onMouseEnter(MouseEvent event)
		design()
		sendEventToListeners(event, true)
	end
	
	/**
	 * Notification that the mouse left the widget. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onMouseLeave(MouseEvent event)
		design()
		sendEventToListeners(event, true)
	end
	
	
	
	/**
	 * Notification that a key on the keyboard has been pressed. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onKeyPress(KeyEvent event)
		select event.getKeyCode()
		case InputEventKey.tab
			if not pHasFocus
				break
			end
			
			var Widget widget
			
			if (event.getModifiers() & ModifiableEvent.shift) == ModifiableEvent.shift
				widget = prevFocusWidget()
			
			else
				widget = nextFocusWidget()
			end
			
			if widget != null
				widget.grabFocus()
			end
		end
		
		sendEventToListeners(event, true)
	end
	
	/**
	 * Notification that a key on the keyboard has been released. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onKeyRelease(KeyEvent event)
		sendEventToListeners(event, true)
	end
	
	
	
	/**
	 * Notification that a drag operation enters the widget. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onDragEnter(DragEvent event)
		sendEventToListeners(event, true)
	end
	
	/**
	 * Notification that a drag operation leaves the widget. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onDragLeave(DragEvent event)
		sendEventToListeners(event, true)
	end
	
	/**
	 * Notification that a drag operatio is in progress over the widget. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onDragOver(DragEvent event)
		sendEventToListeners(event, true)
	end
	
	/**
	 * Notification that a drag operation ends with a drop on the widget. The default behaviour
	 * is to send the message to all registered listeners or propagate it back
	 * to the parent if allowed.
	 */
	func void onDragDrop(DragEvent event)
		sendEventToListeners(event, true)
	end
	
	
	
	/**
	 * \brief Gamepad axis has been moved.
	 * 
	 * Default behaviour sends event to all gamepad listeners or propagates event
	 * to parent if allowed.
	 */
	func void onGamepadAxisMoved(GamepadEvent event)
		if event.getSource() == this
			grabFocus()
		end
		sendEventToListeners(event, true)
	end
	
	/**
	 * \brief Gamepad button has been pressed.
	 * 
	 * Default behaviour sends event to all gamepad listeners or propagates event
	 * to parent if allowed.
	 */
	func void onGamepadButtonPressed(GamepadEvent event)
		if event.getSource() == this
			grabFocus()
		end
		sendEventToListeners(event, true)
	end
	
	/**
	 * \brief Gamepad button has been released.
	 * 
	 * Default behaviour sends event to all gamepad listeners or propagates event
	 * to parent if allowed.
	 */
	func void onGamepadButtonReleased(GamepadEvent event)
		sendEventToListeners(event, true)
	end
	
	
	
	/**
	 * Determines if the given point lies inside the widget. This returns true if
	 * the x and y coordinates are bigger or equal 0 and are less tha width or
	 * height of the widget.
	 */
	func bool isPointInside(Point position)
		return position.isAtLeast(0) and position < pSize
	end
	
	/** \brief Widget at coordinates or \em null if not found. */
	func Widget getWidgetAt(Point position)
		return isPointInside(position) if this else null
	end
	
	
	
	/** Makes the widget grab the focus if possible. */
	func void grabFocus()
		if pHasFocus
			return
		end
		
		if pCanFocus
			requestGrabFocus(this)
			
		elif pParent != null
			pParent.grabFocus()
		end
	end
	
	/** Request to focus the specified widget. */
	func void requestGrabFocus(Widget widget)
		if pEnabled and pVisible and pParent != null
			pParent.requestGrabFocus(widget)
		end
	end
	
	/** Find first widget that can grab the focus or null if none exists. */
	func Widget findFocusableWidget()
		return pEnabled and pVisible and pCanFocus if this else null
	end
	
	/** Find last widget that can grab the focus or null if none exists. */
	func Widget findLastFocusableWidget()
		return pEnabled and pVisible and pCanFocus if this else null
	end
	
	/**
	 * \brief Find next widget in the focus cycle that can grab the focus.
	 */
	func Widget nextFocusWidget()
		return pParent != null if pParent.nextFocusWidgetAfter(this) else null
	end
	
	/**
	 * \brief Find previous widget in the focus cycle that can grab the focus.
	 */
	func Widget prevFocusWidget()
		if pParent == null
			return null
		end
		return pParent.prevFocusWidgetAfter(this)
	end
	
	/**
	 * \brief Find closest focus widget for directional navigation.
	 * \version 1.29
	 * \param finder Finder to add candidate widgets.
	 * \param origin Origin in widget coordinates.
	 */
	func void collectClosestFocusWidget(ClosestDirectionFocusFinder finder, Point origin)
		if pEnabled and pVisible and pCanFocusDirectional
			finder.processWidget(this, -origin, pSize)
		end
	end
	
	/**
	 * \brief Focus widget in direction that can grab the focus.
	 * \version 1.29
	 * \param direction Direction as \ref InputEventKey#arrowLeft, \ref InputEventKey#arrowRight,
	 *                  \ref InputEventKey#arrowUp or \ref InputEventKey#arrowDown.
	 */
	func void focusDirectional(int direction)
		var Window window = getWindow()
		/*
		if window != null
			window.focusDirectionalInside(direction)
		end
		*/
		
		var Container parent = pParent
		if parent == null
			return
		end
		
		var ClosestDirectionFocusFinder finder = ClosestDirectionFocusFinder.new(direction)
		finder.addIgnoreWidget(this)
		
		var Point origin = pPosition + pSize / 2
		var Widget widget
		
		while parent != null
			finder.reset()
			parent.collectClosestFocusWidget(finder, origin)
			
			widget = finder.getBestWidget()
			if widget != null
				widget.grabFocus()
				widget.desktopWarpMouseFocusHere()
				return
			end
			
			if parent == window
				return
			end
			
			origin = origin + parent.getPosition()
			finder.addIgnoreWidget(parent)
			parent = parent.getParent()
		end
	end
	
	/**
	 * \brief Focus mouse location in widget coordinates.
	 * \version 1.29
	 * 
	 * Used for directional focus change.
	 */
	func Point getFocusMouseLocation()
		return Point.new(DEMath.max(pSize.getX() - 5, 0), DEMath.max(pSize.getY() - 5, 0))
	end
	
	/**
	 * \brief Warp mouse to focus location on desktop focus widget.
	 * \version 1.29
	 * 
	 * Does nothing if desktop is not present.
	 */
	func void desktopWarpMouseFocusLocation()
		var Desktop desktop = getDesktop()
		if desktop != null
			desktop.warpMouseFocusLocation()
		end
	end
	
	/**
	 * \brief Warp mouse to focus location on this widget.
	 * \version 1.29
	 * 
	 * Does nothing if desktop is not present.
	 */
	func void desktopWarpMouseFocusHere()
		var Desktop desktop = getDesktop()
		if desktop != null
			desktop.warpMouseFocusLocation(this)
		end
	end
	
	/**
	 * Determines if a widget can grab the full focus. Full focus means that all
	 * parents above the widget are visible and enabled
	 */
	func bool canGrabFullFocus()
		return pEnabled and pVisible and pCanFocus and pParent != null\
			if pParent.allowsChildGrabFocus() else false
	end
	
	/** Captures the mouse if not already captured by another widget. */
	func void captureMouse()
		if pParent == null
			return
		end
		
		pParent.requestCaptureMouse(this)
	end
	
	/** Release mouse capture. */
	func void releaseMouse()
		if pParent == null
			return
		end
		
		pParent.requestReleaseMouse(this)
	end
	
	/**
	 * \brief Widget having captured the mouse.
	 * \version 1.29
	 */
	func Widget getMouseCaptureWidget()
		return pParent != null if pParent.getMouseCaptureWidget() else null
	end
	
	/**
	 * \brief Widget is capturing mouse.
	 * \version 1.29
	 */
	func bool isCapturingMouse()
		return getMouseCaptureWidget() == this
	end
	
	
	/**
	 * Retrieves the window or null if this widget is not part of a
	 * window. The default implementation forwards the request to the
	 * parent with the Window or a subclass thereof intercepting.
	 */
	func Window getWindow()
		if pParent != null
			return pParent.getWindow()
		end
		return null
	end
	
	/**
	 * Retrieves the desktop or null if this widget is not part of a
	 * desktop. The default implementation forwards the request to the
	 * parent with the Desktop or a subclass thereof intercepting.
	 */
	func Desktop getDesktop()
		if pParent != null
			return pParent.getDesktop()
		end
		return null
	end
	
	
	
	/**
	 * \brief Process an event.
	 * 
	 * This allows the widget to be used as the root widget in a game. Using this function
	 * you can implement your own desktop management routines or use no windows at all.
	 * An event is send to the root widget using this function. No other widget has to get
	 * an event sent through this function. Use the sendEvent function to further dispatch
	 * events through all widgets.
	 * 
	 * The default implementation is to send the event to yourself. Overwrite this behaviour
	 * to implement Desktop Widgets.
	 */
	func void processEvent(Event event)
		sendEvent(event)
	end
	
	/**
	 * \brief Simulate keyboard press event.
	 * \version 1.29
	 * \param keyCode Key code of the key to simulate. Use \ref InputEventKey constant.
	 */
	func void simulateKeyPress(int keyCode, int keyChar)
		sendEvent(KeyEvent.new(this, KeyEvent.idKeyPressed,\
			keyCode, InputEventModifier.none, keyChar, -1, -1))
	end
	
	/**
	 * \brief Simulate keyboard release event.
	 * \version 1.29
	 * \param keyCode Key code of the key to simulate. Use \ref InputEventKey constant.
	 */
	func void simulateKeyRelease(int keyCode, int keyChar)
		sendEvent(KeyEvent.new(this, KeyEvent.idKeyReleased,\
			keyCode, InputEventModifier.none, keyChar, -1, -1))
	end
	
	/**
	 * \brief Simulate keyboard press and release event.
	 * \version 1.29
	 * \param keyCode Key code of the key to simulate. Use \ref InputEventKey constant.
	 */
	func void simulateKeyPressRelease(int keyCode, int keyChar)
		simulateKeyPress(keyCode, keyChar)
		simulateKeyRelease(keyCode, keyChar)
	end
	
	
	
	/**
	 * \brief Widget has been shown.
	 * \details Sends event to listeners.
	 */
	func void onShown(WidgetEvent event)
		sendEventToListeners(event, false)
	end
	
	/**
	 * \brief Widget has been hidden.
	 * \details Sends event to listeners.
	 */
	func void onHidden(WidgetEvent event)
		sendEventToListeners(event, false)
	end
	
	/**
	 * \brief State changed.
	 * \details Sends event to listeners.
	 */
	func void onStateChanged(StateChangeEvent event)
		design()
		sendEventToListeners(event, false)
	end
	
	/**
	 * \brief Parent state changed.
	 * 
	 * Called by some certain widgets supporting childs widgets able to track their state.
	 * 
	 * The default implementation triggers a design() call.
	 */
	func void onParentStateChanged()
		design()
	end
	
	/**
	 * \brief Parent state changed.
	 * \version 1.7
	 * 
	 * Calls onParentStateChanged(bool) on all child widgets. Supports forcing update on the
	 * entire children chain.
	 */
	func void onParentStateChanged(bool force)
		design()
	end
	
	/**
	 * \brief Widget received focus.
	 * \details Sends event to listeners.
	 */
	func void onFocusReceived(FocusEvent event)
		design()
		sendEventToListeners(event, false)
	end
	
	/**
	 * \brief Widget lost focus.
	 * \details Sends event to listeners.
	 */
	func void onFocusLost(FocusEvent event)
		design()
		sendEventToListeners(event, false)
	end
	
	/** \brief Text color changed. */
	func void onSetTextColor()
	end
	
	/** Notification that the widget font changed. */
	func void onSetFont()
	end
	
	/**
	 * \brief Position changed.
	 * \details Sends event to listeners.
	 */
	func void onReposition(WidgetEvent event)
		sendEventToListeners(event, false)
	end
	
	/**
	 * \brief Size changed.
	 * \details Sends event to listeners.
	 */
	func void onResize(WidgetEvent event)
		sendEventToListeners(event, false)
	end
	
	/**
	 * \brief Window is disposing.
	 * 
	 * Sends event to listeners of this widget only. Method is only
	 * called if widget listeners are present.
	 */
	func void onDispose(WidgetEvent event)
		sendEventToListeners(event, false)
	end
	
	/** \brief Designer selector changed. */
	func void onDesignerSelectorChanged()
	end
	
	/**
	 * Notification that the gui theme changed.
	 * Attention! You have to super-call this method since it is used a bit
	 *            differently than the other callback methods.
	 */
	func void onGuiThemeChanged()
		if not pIsDesignerSet
			setDesigner(null) // set designer from gui theme
		end
		
		if pBorder != null
			pBorder.onGuiThemeChanged()
		end
		
		updateCanvasBackground()
	end
	
	/** \brief Padding changed. */
	func void onPaddingChanged()
	end
	
	/** \brief Designer changed. */
	func void onDesignerChanged()
	end
	
	/**
	 * \brief Translation manager or active language pack changed.
	 * \version 1.20
	 */
	func void onTranslationChanged()
		if pBorder != null
			pBorder.onWidgetParametersChanged()
		end
	end
	
	
	
	/** \brief Design widget using WidgetDesigner. */
	func void design()
		if pDesigner == null
			return
		end
		
		runWhileBlockingLayoutParent(block
			pDesigner.designWidget(this)
		end)
		layoutParentIfBlocked()
	end
	
	
	
	/** Stops the repeat key event timer. */
	func void stopRepeatEventTimer()
		if pRepeatEventTimer == null
			return
		end
		
		pRepeatEventTimer.giveUp()
		pRepeatEventTimer = null
	end
	
	/** Starts a repeat key event timer. */
	private func void startRepeatKey(KeyEvent event)
		if pRepeatEventTimer == null
			pRepeatEventTimer = RepeatKeyEventTimer.new(this, event)
			
		elif not pRepeatEventTimer.getEvent().equalKeyEvents(event)
			pRepeatEventTimer.giveUp()
			pRepeatEventTimer = RepeatKeyEventTimer.new(this, event)
		end
	end
	
	
	
	/**
	 * \brief Start frame updater if not running.
	 * 
	 * Once running the widget receives onFrameUpdate() calls every frame update.
	 */
	func void startFrameUpdater()
		if pFrameUpdater == null
			pFrameUpdater = FrameUpdater.new(this)
		end
	end
	
	/**
	 * \brief Stop frame updater if running.
	 */
	func void stopFrameUpdater()
		if pFrameUpdater != null
			pFrameUpdater.giveUp()
			pFrameUpdater = null
		end
	end
	
	/**
	 * \brief Do frame update.
	 * 
	 * Called every frame update if startFrameUpdater() is called.
	 * 
	 * \param elapsed Elapsed time since the last frame update. Equals Engine.getElapsedTime().
	 */
	func void onFrameUpdate(float elapsed)
	end
	
	
	
	
	/**
	 * \brief Popup virtual keyboard if Desktop has one assigned.
	 * \version 1.7
	 * 
	 * Does nothing if the virtual keyboard is shown and already assigned to this widget.
	 */
	func void popupVirtualKeyboard()
		var Desktop desktop = getDesktop()
		if desktop == null
			return
		end
		
		var WindowVirtualKeyboard vk = desktop.getWindowVirtualKeyboard()
		if vk == null or vk.getInputWidget() == this
			return
		end
		
		vk.popup(this)
	end
	
	/**
	 * \brief Popdown virtual keyboard if Desktop has one assigned.
	 * \version 1.7
	 * 
	 * Does nothing if the virtual keyboard is shown and not assigned to this widget.
	 */
	func void popdownVirtualKeyboard()
		var Desktop desktop = getDesktop()
		if desktop == null
			return
		end
		
		var WindowVirtualKeyboard vk = desktop.getWindowVirtualKeyboard()
		if vk == null or vk.getInputWidget() != this
			return
		end
		
		vk.popdown()
	end
	
	/**
	 * \brief Popdown virtual keyboard if Desktop has one assigned and direction focus widget.
	 * \version 1.29
	 * 
	 * Does nothing if the virtual keyboard is shown and not assigned to this widget.
	 */
	func void popdownVirtualKeyboardDirectional()
		popdownVirtualKeyboard()
		
		var Desktop desktop = getDesktop()
		if desktop != null
			desktop.warpMouseFocusLocation(this)
		end
	end
	
	
	/**
	 * \brief Clipboard or null to use parent clipboard.
	 * \version 1.11
	 */
	func Clipboard getClipboard()
		if pClipboard != null
			return pClipboard
			
		elif pParent != null
			return pParent.getClipboard()
			
		else
			return null
		end
	end
	
	/**
	 * \brief Set clipboard or null to use parent clipboard.
	 * \version 1.11
	 */
	func void setClipboard(Clipboard clipboard)
		pClipboard = clipboard
	end
	
	
	
	/**
	 * \brief Create widget, background and content canvas.
	 * 
	 * Widget canvas is a view canvas containing the entire widget including the border if
	 * existing. This canvas is potentially larger than the widget. This is compensated using
	 * the background and content canvas. Background canvas is a view canvas with order 0
	 * containing all canvas required to paint the background. By default this is empty.
	 * Content canvas is a view canvas with order 1 containing all canvas required to paint
	 * the content of the widget. By default this is empty. Border canvas is added if
	 * existing and is required to have order larger 1 (typically 2).
	 */
	private func void createCanvas()
		pCanvasWidget = CanvasView.new()
		pCanvasWidget.setVisible(pVisible)
		pCanvasWidget.setTransparency(pTransparency)
		
		pCanvasBackground = CanvasView.new()
		pCanvasBackground.setOrder(0.0)
		pCanvasWidget.addCanvas(pCanvasBackground)
		
		pCanvasContent = CanvasView.new()
		pCanvasContent.setOrder(1.0)
		pCanvasWidget.addCanvas(pCanvasContent)
	end
	
	/**
	 * \brief Update canvas position and size.
	 * 
	 * The position and size of the background and content canvas are adjusted to match the
	 * position and size of the widget in the parent container. Border canvas if existing
	 * is adjusted to always fit properly around the canvas background and content.
	 * 
	 * \warning This method is also called from the constructor. Subclasses overwriting this
	 *          method have to be able to run while the subclass constructor has not yet
	 *          been processed.
	 */
	protected func void updateCanvasGeometry()
		var Point position = pPosition
		var Point size = pSize
		var BorderSize borderSize = BorderSize.new()
		
		if pBorder != null
			borderSize = pBorder.getBorderSize()
		end
		
		var Point offset = Point.new(borderSize.getLeft(), borderSize.getTop())
		
		pCanvasWidget.setPosition(position - offset)
		pCanvasWidget.setSize(size + borderSize.getSize())
		
		pCanvasBackground.setPosition(offset)
		pCanvasBackground.setSize(size)
		
		pCanvasContent.setPosition(offset)
		pCanvasContent.setSize(size)
		
		if pBorder != null
			pBorder.resizeCanvas(pSize)
		end
	end
	
	/**
	 * \brief Update background canvas content.
	 * 
	 * Sets the content of the background canvas to canvas created by canvas creator if existing.
	 * Widget calls this method if background canvas creator or gui theme changed.
	 */
	protected func void updateCanvasBackground()
		pCanvasBackground.removeAllCanvas()
		
		if pBackgroundCanvasCreator != null
			var Canvas canvas = pBackgroundCanvasCreator.createCanvas(pSize)
			if canvas != null
				pCanvasBackground.addCanvas(canvas)
			end
		end
	end
end
