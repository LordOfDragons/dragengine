/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Borders
pin Dragengine.Gui.Events
pin Dragengine.Gui.Layouts


/**
 * \brief Scrollable list of elements of same size.
 * 
 * Elements are created using a ListElementRenderer to properly display ListModel
 * content. List can be displayed in three different ways. Type.vertical displays the
 * elements as a single column list from top to bottom. Type.verticalWrap displays
 * the elements in as many columns fitting into the list width and as many rows
 * required for the entire list. Type.horizontalWrap displays the elements in as many
 * rows fitting into the list height and as many columns required for the entire
 * list. Type.vertical is best suited for common lists the user can select values from
 * fitting into a single column scrolling up and down. Type.verticalWrap and
 * Type.horizontalWrap are best suited to display larger lists or lists with more
 * square like elements lik file listings with file type icons.
 * 
 * Supports designing using designer selector "ListBox".
 */
class ListBox extends Container implements RangeModelListener, ListModelListener
	/** \brief Type. */
	enum Type
		/**
		* \brief Displays the elements as a single column list from top to bottom.
		* \details best suited for common lists the user can select values from
		*          fitting into a single column scrolling up and down.
		*/
		vertical
		
		/**
		* \brief displays the elements in as many columns fitting into the list
		*        width and as many rows required for the entire list.
		* \details best suited to display larger lists or lists with more square
		*          like elements lik file listings with file type icons.
		*/
		verticalWrap
		
		/**
		* \brief displays the elements in as many rows fitting into the list height
		*        and as many columns required for the entire list.
		* \details best suited to display larger lists or lists with more square
		*          like elements lik file listings with file type icons.
		*/
		horizontalWrap
	end
	
	
	var DefaultRangeModel pHorzRangeModel, pVertRangeModel
	var ListModel pListModel
	var ListElementRenderer pRenderer
	var int pElementHeight, pElementWidth
	var Type pType
	var Panel pPanelVisibleElements
	var Point pContentSize
	var bool pModelDirty
	var int pSelectedElement, pVisibleRows, pVisibleColumns, pNumDispLines
	var Array pSelectionListeners
	
	
	
	/** \brief Create list box. */
	func new()
		pType = Type.vertical
		pVisibleRows = 1
		pVisibleColumns = 1
		pNumDispLines = 5
		pContentSize = Point.new( 1, 1 )
		pSelectedElement = -1
		pSelectionListeners = Array.new()
		setCanFocus(true)
		setCanFocusDirectional(true)
		pModelDirty = true
		pHorzRangeModel = DefaultRangeModel.new( 0, 0, 1, 0, 1 )
		pHorzRangeModel.addListener( this )
		pVertRangeModel = DefaultRangeModel.new( 0, 0, 1, 0, 1 )
		pVertRangeModel.addListener( this )
		pListModel = DefaultListModel.new()
		pListModel.addListener( this )
		pRenderer = DefaultListElementRenderer.new()
		pElementHeight = 0
		pElementWidth = 0
		
		setLayout( FixedLayout.new() )
		setDesignerSelector( "ListBox" )
		
		pPanelVisibleElements = Panel.new()
		//pPanelVisibleElements.setLayout( FlowLayout.new( LayoutAxis.y ) )
		pPanelVisibleElements.setLayout( GridLayout.new( 1, 0 ) )
		addWidget( pPanelVisibleElements )
		
		setBorder( BevelBorder.new( false ) )
	end
	
	/** \brief Create list box using model. */
	func new( ListModel model ) this()
		setModel( model )
	end
	
	/** \brief Create list box using model and element renderer. */
	func new( ListModel model, ListElementRenderer renderer ) this()
		setElementRenderer( renderer )
		setModel( model )
	end
	
	/** \brief Dispose of widget. */
	func void dispose()
		pSelectionListeners.removeAll()
		
		pListModel.removeListener( this )
		pListModel = null
		
		pPanelVisibleElements = null
		
		pVertRangeModel.removeListener( this )
		pVertRangeModel = null
		
		pHorzRangeModel.removeListener( this )
		pHorzRangeModel = null
		
		pRenderer = null
		
		super.dispose()
	end
	
	
	
	/**
	 * \brief Vertical range model for viewports to synchronize the vertical scrollbar.
	 * \details If this widget has no reasonable vertical range model it should return \em null.
	 */
	func RangeModel getVerticalRangeModel()
		return pVertRangeModel
	end
	
	/**
	 * \brief Horizontal range model for viewports to synchronize the horizontal scrollbar.
	 * \details If this widget has no reasonable horizontal range model it should return \em null.
	 */
	func RangeModel getHorizontalRangeModel()
		return pHorzRangeModel
	end
	
	
	
	/** \brief List model. */
	func ListModel getModel()
		return pListModel
	end
	
	/** \brief Set list model. */
	func void setModel( ListModel model )
		if model == null
			throw EInvalidParam.new()
		end
		
		if model == pListModel
			return
		end
		
		pListModel.removeListener( this )
		pListModel = model
		pListModel.addListener( this )
		pModelDirty = true
		pSelectedElement = pListModel.getSelected()
		
		updateRenderWidgets()
	end
	
	/** \brief List element renderer. */
	func ListElementRenderer getElementRenderer()
		return pRenderer
	end
	
	/** \brief Set list element renderer. */
	func void setElementRenderer( ListElementRenderer renderer )
		if renderer == null
			throw EInvalidParam.new()
		end
		
		if renderer == pRenderer
			return
		end
		
		runWhileBlockingLayout( block
			// runWhileBlockingLayout is important here otherwise the doLayout after removing
			// the widgets can trigger an onResize triggering updateRenderWidgets. if this
			// happens pPanelVisibleElements is not empty as we need it for a proper change
			// of list element renderer
			pPanelVisibleElements.removeAllWidgets()
		end )
		
		pRenderer = renderer
		pElementHeight = 0
		pElementWidth = 0
		
		pModelDirty = true
		updateRenderWidgets()
	end
	
	/** \brief List type. */
	func Type getType()
		return pType
	end
	
	/** \brief Set list type. */
	func void setType( Type type )
		if type == pType
			return
		end
		
		pType = type
		
		runWhileBlockingLayout( block
			// runWhileBlockingLayout is important here otherwise the doLayout after removing
			// the widgets can trigger an onResize triggering updateRenderWidgets. if this
			// happens pPanelVisibleElements is not empty as we need it for a proper change
			// of list element renderer
			pPanelVisibleElements.removeAllWidgets()
		end )
		
		pModelDirty = true
		updateRenderWidgets()
	end
	
	/** \brief Number of lines to display. */
	func int getNumberDisplayLines()
		return pNumDispLines
	end
	
	/** \brief Set number of lines to display. */
	func void setNumberDisplayLines( int lines )
		if lines < 0
			throw EInvalidParam.new()
		end
		
		if lines == pNumDispLines
			return
		end
		
		pNumDispLines = lines
		updateRenderWidgets()
	end
	
	/**
	 * \brief Count of visible rows.
	 * \version 1.17
	 */
	func int getVisibleRowCount()
		return pVisibleRows
	end
	
	/**
	 * \brief Count of visible columns.
	 * \version 1.17
	 */
	func int getVisibleColumnCount()
		return pVisibleColumns
	end
	
	
	
	/** \brief Index of the first visible element. */
	func int getFirstElement()
		select pType
		case Type.vertical
			return pVertRangeModel.getValue() / getElementHeight()
			
		case Type.verticalWrap
			return pVisibleColumns * (pVertRangeModel.getValue() / getElementHeight())
			
		case Type.horizontalWrap
			return pVisibleRows * (pHorzRangeModel.getValue() / getElementWidth())
			
		else
			throw EInvalidParam.new()
		end
	end
	
	/**
	 * \brief Index of the last visible element.
	 * \version 1.11
	 */
	func int getLastElement()
		var int index = getFirstElement()
		
		select pType
		case Type.vertical
			var int containerHeight = getContainerHeight()
			var int elementHeight = getElementHeight()
			var int y = index * elementHeight - pVertRangeModel.getValue()
			index += (containerHeight - y - 2) / elementHeight
			
		case Type.verticalWrap
			var int containerHeight = getContainerHeight()
			var int elementHeight = getElementHeight()
			var int row = index / pVisibleColumns
			var int y = row * elementHeight - pVertRangeModel.getValue()
			row += (containerHeight - y - 2) / elementHeight
			index = (row + 1) * pVisibleColumns - 1
			
		case Type.horizontalWrap
			var int containerWidth = getContainerWidth()
			var int elementWidth = getElementWidth()
			var int column = index / pVisibleRows
			var int x = column * elementWidth - pHorzRangeModel.getValue()
			column += (containerWidth - x - 2) / elementWidth
			index = (column + 1) * pVisibleRows - 1
			
		else
			throw EInvalidParam.new()
		end
		
		return DEMath.min(index, pListModel.getCount() - 1)
	end
	
	/** \brief Index of selected item or -1 if none is selected. */
	func int getSelectedElement()
		return pListModel.getSelected()
	end
	
	/** \brief Set index of selected item or -1 if none is selected. */
	func void setSelectedElement( int index )
		pListModel.setSelected( index )
	end
	
	
	
	/** \brief Index of element at position or -1 if not found. */
	func int getElementAt( int x, int y )
		return getElementAt( Point.new( x, y ) )
	end
	
	/** \brief Index of the element at position or -1 if not found. */
	func int getElementAt( Point position )
		var int elementIndex
		
		select pType
		case Type.vertical
			var int elementHeight = getElementHeight()
			elementIndex = (pVertRangeModel.getValue() + position.getY()) / elementHeight
			
		case Type.verticalWrap
			var int elementWidth = getElementWidth()
			var int elementHeight = getElementHeight()
			var int row = (pVertRangeModel.getValue() + position.getY()) / elementHeight
			var int column = position.getX() / elementWidth
			elementIndex = pVisibleColumns * row + column
			
		case Type.horizontalWrap
			var int elementWidth = getElementWidth()
			var int elementHeight = getElementHeight()
			var int column = (pHorzRangeModel.getValue() + position.getX()) / elementWidth
			var int row = position.getY() / elementHeight
			elementIndex = pVisibleRows * column + row
			
		else
			throw EInvalidParam.new()
		end
		
		if elementIndex < 0 or elementIndex >= pListModel.getCount()
			elementIndex = -1
		end
		
		return elementIndex
	end
	
	/** \brief Make element fully visible by adjusting scroll position if required. */
	func void makeElementVisible( int index )
		if index < -1 or index >= pListModel.getCount()
			throw EInvalidParam.new()
		end
		
		select pType
		case Type.vertical
			var int elementHeight = getElementHeight()
			var int elementY = elementHeight * index - pVertRangeModel.getValue()
			var int height = getContainerHeight()
			
			if elementY < 0
				pVertRangeModel.setValue( elementHeight * index )
				
			elif elementY > height - elementHeight
				pVertRangeModel.setValue( elementHeight * index - height + elementHeight )
			end
			
		case Type.verticalWrap
			var int elementWidth = getElementWidth()
			var int elementHeight = getElementHeight()
			var int row = index / pVisibleColumns
			var int column = index % pVisibleColumns
			var int elementX = elementWidth * column - pHorzRangeModel.getValue()
			var int elementY = elementHeight * row - pVertRangeModel.getValue()
			var int width = getContainerWidth()
			var int height = getContainerHeight()
			
			if elementX < 0
				pHorzRangeModel.setValue( elementWidth * column )
				
			elif elementX > width - elementWidth
				pHorzRangeModel.setValue( elementWidth * column - width + elementWidth )
			end
			
			if elementY < 0
				pVertRangeModel.setValue( elementHeight * row )
				
			elif elementY > height - elementHeight
				pVertRangeModel.setValue( elementHeight * row - height + elementHeight )
			end
			
		case Type.horizontalWrap
			var int elementWidth = getElementWidth()
			var int elementHeight = getElementHeight()
			var int row = index % pVisibleRows
			var int column = index / pVisibleRows
			var int elementX = elementWidth * column - pHorzRangeModel.getValue()
			var int elementY = elementHeight * row - pVertRangeModel.getValue()
			var int width = getContainerWidth()
			var int height = getContainerHeight()
			
			if elementX < 0
				pHorzRangeModel.setValue( elementWidth * column )
				
			elif elementX > width - elementWidth
				pHorzRangeModel.setValue( elementWidth * column - width + elementWidth )
			end
			
			if elementY < 0
				pVertRangeModel.setValue( elementHeight * row )
				
			elif elementY > height - elementHeight
				pVertRangeModel.setValue( elementHeight * row - height + elementHeight )
			end
			
		else
			throw EInvalidParam.new()
		end
	end
	
	/** \brief Make selected element fully visible by adjusting scroll position if required. */
	func void makeSelectedElementVisible()
		if pSelectedElement != -1
			makeElementVisible( pSelectedElement )
		end
	end
	
	
	
	/** \brief Minimal size of widget. */
	func Point getMinimumSize()
		if isMinimumSizeSet()
			return super.getMinimumSize()
		end
		
		select pType
		case Type.vertical
			return getPadding().getSize() + Point.new( \
				DEMath.max( getElementWidth(), 50 ), \
				getElementHeight() * pNumDispLines )
			
		case Type.verticalWrap, Type.horizontalWrap
			return getPadding().getSize() + Point.new( getElementWidth(), \
				getElementHeight() * pNumDispLines )
			
		else
			throw EInvalidParam.new()
		end
	end
	
	/**
	 * \brief Minimum size of widget using reference widget width and variable height.
	 * \details Default implementation uses getMinimumSize().
	 */
	func Point getMinimumSizeForWidth( int width )
		return getMinimumSize()
		/*
		if isMinimumSizeSet()
			return super.getMinimumSize()
		end
		
		return Point.new( width, getPadding().getHeight() \
			+ getElementHeight() * pNumDispLines )
		*/
	end
	
	/**
	 * \brief Minimum size of widget using reference widget height and variable width.
	 * \details Default implementation uses getMinimumSize().
	 */
	func Point getMinimumSizeForHeight( int height )
		return getMinimumSize()
		/*
		if isMinimumSizeSet()
			return super.getMinimumSize()
		end
		
		select pType
		case Type.vertical
			return Point.new( getPadding().getWidth() + 50, height )
			
		case Type.verticalWrap, Type.horizontalWrap
			return Point.new( getPadding().getWidth() + getElementWidth(), height )
			
		else
			throw EInvalidParam.new()
		end
		*/
	end
	
	
	
	/** \brief First widget that can grab the focus or \em null if absent. */
	func Widget findFocusableWidget()
		if getEnabled() and getVisible() and getCanFocus()
			return this
		end
		
		return null
	end
	
	/** \brief Last widget that can grab the focus or \em null if absent. */
	func Widget findLastFocusableWidget()
		if getEnabled() and getVisible() and getCanFocus()
			return this
		end
		
		return null
	end
	
	/** \brief Find next widget in the focus cycle that can grab the focus. */
	func Widget nextFocusWidgetAfter( Widget widget )
		if getParent() == null
			return null
		end
		
		return getParent().nextFocusWidgetAfter( widget )
	end
	
	/** \brief Find previous widget in the focus cycle that can grab the focus. */
	func Widget prevFocusWidgetAfter( Widget widget )
		if getParent() == null
			return null
		end
		
		return getParent().prevFocusWidgetAfter( widget )
	end
	
	/** \brief Container allows child widgets to grab the focus. */
	func bool allowsChildGrabFocus()
		return false
	end
	
	/** \brief Focus widget is inside container somewhere. */
	func bool hasFocusWidget()
		return false
	end
	
	
	
	/**
	 * \brief Gui theme changed.
	 * \details Called if setGuiTheme is used or parent changed.
	 * \warning You have to super-call this method since it is used a bit differently than the other callback methods.
	 */
	func void onGuiThemeChanged()
		// usually contains text which is based on gui theme font
		pElementHeight = 0
		pElementWidth = 0
		
		runWhileBlockingLayout( block
			super.onGuiThemeChanged()
		end )
		
		updateRenderWidgets()
	end
	
	/** \brief Size changed. */
	func void onResize( WidgetEvent event )
		pModelDirty = true
		updateRenderWidgets()
		
		super.onResize( event ) // order here is different because we alter widget and not canvas
	end
	
	
	
	/** \brief Key pressed. */
	func void onKeyPress( KeyEvent event )
		var int count = pListModel.getCount()
		checkModel()
		
		select event.getKeyCode()
		// move cursor up
		case InputEventKey.arrowUp
			if pSelectedElement == -1 and count > 0
				setSelectedElement( 0 )
				makeSelectedElementVisible()
				
			elif pSelectedElement > 0
				if pType == Type.verticalWrap
					setSelectedElement( DEMath.max( pSelectedElement - pVisibleColumns, 0 ) )
					
				else
					setSelectedElement( pSelectedElement - 1 )
				end
				makeSelectedElementVisible()
			end
			
			sendEventToListeners( event, false )
			
		// move cursor left
		case InputEventKey.arrowLeft
			if pSelectedElement == -1 and count > 0
				setSelectedElement( 0 )
				makeSelectedElementVisible()
				
			elif pSelectedElement > 0
				if pType == Type.horizontalWrap
					setSelectedElement( DEMath.max( pSelectedElement - pVisibleRows, 0 ) )
					
				else
					setSelectedElement( pSelectedElement - 1 )
				end
				makeSelectedElementVisible()
			end
			
			sendEventToListeners( event, false )
			
		// move cursor down
		case InputEventKey.arrowDown
			if pSelectedElement == -1 and count > 0
				setSelectedElement( 0 )
				makeSelectedElementVisible()
				
			elif pSelectedElement < count - 1
				if pType == Type.verticalWrap
					setSelectedElement( DEMath.min( pSelectedElement + pVisibleColumns, count - 1 ) )
					
				else
					setSelectedElement( pSelectedElement + 1 )
				end
				makeSelectedElementVisible()
			end
			
			sendEventToListeners( event, false )
			
		// move cursor right
		case InputEventKey.arrowRight
			if pSelectedElement == -1 and count > 0
				setSelectedElement( 0 )
				makeSelectedElementVisible()
				
			elif pSelectedElement < count - 1
				if pType == Type.horizontalWrap
					setSelectedElement( DEMath.min( pSelectedElement + pVisibleRows, count - 1 ) )
					
				else
					setSelectedElement( pSelectedElement + 1 )
				end
				makeSelectedElementVisible()
			end
			
			sendEventToListeners( event, false )
			
		// move page up
		case InputEventKey.pageUp
			if pSelectedElement == -1 and count > 0
				setSelectedElement( 0 )
				makeSelectedElementVisible()
				
			elif pSelectedElement > 0
				select pType
				case Type.vertical
					setSelectedElement( DEMath.max( pSelectedElement - ( pVisibleRows - 2 ), 0 ) )
					
				case Type.verticalWrap
					setSelectedElement( DEMath.max( pSelectedElement - pVisibleColumns * ( pVisibleRows - 2 ), 0 ) )
					
				case Type.horizontalWrap
					setSelectedElement( DEMath.max( pSelectedElement - pVisibleRows * ( pVisibleColumns - 1 ), 0 ) )
					
				else
					throw EInvalidParam.new()
				end
				
				makeSelectedElementVisible()
			end
			
			sendEventToListeners( event, false )
			
		// move page down
		case InputEventKey.pageDown
			if pSelectedElement == -1 and count > 0
				setSelectedElement( 0 )
				makeSelectedElementVisible()
				
			elif pSelectedElement < count - 1
				select pType
				case Type.vertical
					setSelectedElement( DEMath.min( pSelectedElement + ( pVisibleRows - 2 ), count - 1 ) )
					
				case Type.verticalWrap
					setSelectedElement( DEMath.min( pSelectedElement + pVisibleColumns * ( pVisibleRows - 2 ), count - 1 ) )
					
				case Type.horizontalWrap
					setSelectedElement( DEMath.min( pSelectedElement + pVisibleRows * ( pVisibleColumns - 1 ), count - 1 ) )
					
				else
					throw EInvalidParam.new()
				end
				
				makeSelectedElementVisible()
			end
			
			sendEventToListeners( event, false )
			
		// move to the beginning of the list
		case InputEventKey.home
			if count > 0 and pSelectedElement != 0
				setSelectedElement( 0 )
				makeSelectedElementVisible()
			end
			
			sendEventToListeners( event, false )
			
		// move to the end of the list
		case InputEventKey.last
			if count > 0 and pSelectedElement != count - 1
				setSelectedElement( count - 1 )
				makeSelectedElementVisible()
			end
			
			sendEventToListeners( event, false )
			
		// otherwise send to super
		else
			super.onKeyPress( event )
		end
	end
	
	
	
	/** \brief Mouse button pressed. */
	func void onButtonPress( MouseEvent event )
		select event.getButton()
		case InputEventMouseButton.left
			var Widget source = event.getSource() cast Widget
			var Point position = source.getRelativePosition(this) + event.getPosition()
			var int elementIndex = getElementAt(position)
			
			if elementIndex != -1 and isPointInside(position)
				setSelectedElement( elementIndex )
				makeSelectedElementVisible()
			end
			
			grabFocus()
			sendEventToListeners( event, false )
			
		else
			super.onButtonPress( event )
		end
	end
	
	/** \brief Mouse button released. */
	func void onButtonRelease( MouseEvent event )
		select event.getButton()
		case InputEventMouseButton.left
			sendEventToListeners( event, false )
			
		else
			super.onButtonRelease( event )
		end
	end
	
	/** \brief Mouse moved. */
	func void onMouseMove( MouseEvent event )
		/*
		var int scrollOffsetY = pVertRangeModel.getValue() * pFontHeight
		var int realX, realY
		if pOldCursorPos != -1
			realX = event.getX() - getPadding().getLeft()
			realY = event.getY() + scrollOffsetY - getPadding().getTop()
			pCursorPos = pBestCharNear( pBestLineNear( realY ), realX )
			if pCursorPos == pOldCursorPos
				pSelection = null
			elif pCursorPos < pOldCursorPos
				pSelection = Point.new( pCursorPos, pOldCursorPos )
			else
				pSelection = Point.new( pOldCursorPos, pCursorPos )
			end
			pSelXOffsets = null
			pCaret = null
			pRefXPosDirty = true
		end
		*/
		super.onMouseMove( event )
	end
	
	/** \brief Mouse wheel has moved. */
	func void onMouseWheel( MouseEvent event )
		var int y = event.getPosition().getY()
		if y == 0
			super.onMouseWheel( event )
			return
		end
		
		select pType
		case Type.vertical, Type.verticalWrap
			if ( event.getModifiers() & ModifiableEvent.shift ) == ModifiableEvent.shift
				pVertRangeModel.setValue( pVertRangeModel.getValue() \
					- pVertRangeModel.getPageSize() * y )
				
			else
				pVertRangeModel.setValue( pVertRangeModel.getValue() \
					- pVertRangeModel.getIncrement() * y )
			end
			
		case Type.horizontalWrap
			if ( event.getModifiers() & ModifiableEvent.shift ) == ModifiableEvent.shift
				pHorzRangeModel.setValue( pHorzRangeModel.getValue() \
					- pHorzRangeModel.getPageSize() * y )
				
			else
				pHorzRangeModel.setValue( pHorzRangeModel.getValue() \
					- pHorzRangeModel.getIncrement() * y )
			end
		end
		
		sendEventToListeners( event, false )
	end
	
	/**
	 * \brief State changed.
	 * 
	 * Extends base class behavior sending onParentStateChanged() to children.
	 */
	func void onStateChanged( StateChangeEvent event )
		runWhileBlockingLayout( block
			notifyBorderParametersChanged()
			super.onStateChanged( event )
		end )
		doLayoutIfBlocked()
	end
	
	
	
	/** \brief Range properties changed. */
	func void rangeChanged( RangeModel rangeModel )
	end
	
	/** \brief Value changed. */
	func void valueChanged( RangeModel rangeModel )
		updateRenderWidgets()
	end
	
	
	
	/**
	 * \brief Elements added.
	 * \param listModel ListModel sending the notification
	 * \param fromIndex Index of first added element.
	 * \param toIndex Index of last added element.
	 */
	func void elementsAdded( ListModel listModel, int fromIndex, int toIndex )
		pModelDirty = true
		updateRenderWidgets()
	end
	
	/**
	 * \brief Elements removed.
	 * \param listModel ListModel sending the notification
	 * \param fromIndex Index of first removed element.
	 * \param toIndex Index of last removed element.
	 */
	func void elementsRemoved( ListModel listModel, int fromIndex, int toIndex )
		pModelDirty = true
		updateRenderWidgets()
	end
	
	/**
	 * \brief Content of the model changed.
	 * \param listModel ListModel sending the notification
	 * \param fromIndex Index of first changed element.
	 * \param toIndex Index of last changed element.
	 */
	func void contentChanged( ListModel listModel, int fromIndex, int toIndex )
		pModelDirty = true
		updateRenderWidgets()
	end
	
	/**
	 * \brief Selection in the model changed.
	 */
	func void selectionChanged( ListModel listModel )
		if getGuiTheme() == null
			pSelectedElement = pListModel.getSelected()
			
		else
			var int firstElement = getFirstElement()
			var int visibleElementCount = pVisibleColumns * pVisibleRows
			
			if pSelectedElement >= firstElement \
			and pSelectedElement < firstElement + visibleElementCount \
			and pSelectedElement < pListModel.getCount()
				pRenderer.updateRenderer( this, \
					pPanelVisibleElements.getWidget( pSelectedElement - firstElement ), \
					pListModel.getAt( pSelectedElement ), false, false )
			end
			
			pSelectedElement = pListModel.getSelected()
			
			if pSelectedElement >= firstElement \
			and pSelectedElement < firstElement + visibleElementCount
				pRenderer.updateRenderer( this, \
					pPanelVisibleElements.getWidget( pSelectedElement - firstElement ), \
					pListModel.getAt( pSelectedElement ), true, false )
			end
		end
		
		makeSelectedElementVisible()
	end
	
	
	
	/** \brief Check if model is dirty and update parameters if required. */
	protected func void checkModel()
		if not pModelDirty
			return
		end
		
		updateRangeModels()
		
		pModelDirty = false
	end
	
	/** \brief Update range model. */
	protected func void updateRangeModels()
		var int elementCount = pListModel.getCount()
		
		select pType
		case Type.vertical
			var int elementHeight = getElementHeight()
			var int visibleHeight = getContainerHeight()
			var int maxHeight = DEMath.max( elementHeight * elementCount - visibleHeight, 0 )
			pVertRangeModel.setAll( 0, maxHeight, visibleHeight, pVertRangeModel.getValue(), elementHeight )
			pHorzRangeModel.setAll( 0, 0, 1, 0, 1 )
			
		case Type.verticalWrap
			var int elementHeight = getElementHeight()
			var int visibleHeight = getContainerHeight()
			var int rowCount = ( ( elementCount - 1 ) / pVisibleColumns ) + 1
			var int maxHeight = DEMath.max( elementHeight * rowCount - visibleHeight, 0 )
			pVertRangeModel.setAll( 0, maxHeight, visibleHeight, pVertRangeModel.getValue(), elementHeight )
			pHorzRangeModel.setAll( 0, 0, 1, 0, 1 )
			
		case Type.horizontalWrap
			var int elementWidth = getElementWidth()
			var int visibleWidth = getContainerWidth()
			var int columnCount = ( ( elementCount - 1 ) / pVisibleRows ) + 1
			var int maxWidth = DEMath.max( elementWidth * columnCount - visibleWidth, 0 )
			pHorzRangeModel.setAll( 0, maxWidth, visibleWidth, pHorzRangeModel.getValue(), elementWidth )
			pVertRangeModel.setAll( 0, 0, 1, 0, 1 )
			
		else
			throw EInvalidParam.new()
		end
	end
	
	
	
	/** \brief Element width. */
	func int getElementWidth()
		if pElementWidth == 0
			updateElementSize()
		end
		return pElementWidth
	end
	
	/** \brief Element height. */
	func int getElementHeight()
		if pElementHeight == 0
			updateElementSize()
		end
		return pElementHeight
	end
	
	/**
	 * \brief Position of element at index.
	 * \version 1.11
	 * 
	 * Returns top left corner.
	 */
	func Point getElementPositionAt(int index)
		if index < 0
			throw EInvalidParam.new("index < 0")
		end
		if index >= pListModel.getCount()
			throw EInvalidParam.new("index >= model.count")
		end
		
		var Point position = Point.new(getPadding().getLeft(), getPadding().getTop())
		
		select pType
		case Type.vertical
			position = position + Point.new(0, index * getElementHeight() - pVertRangeModel.getValue())
			
		case Type.verticalWrap
			var int column = index % pVisibleColumns
			var int row = index / pVisibleColumns
			position = position + Point.new(column * getElementWidth(),\
				row * getElementHeight() - pVertRangeModel.getValue())
			
		case Type.horizontalWrap
			var int row = index % pVisibleRows
			var int column = index / pVisibleRows
			position = position + Point.new(column * getElementWidth()\
				- pHorzRangeModel.getValue(), row * getElementHeight())
			
		else
			throw EInvalidParam.new()
		end
		
		return position
	end
	
	/** \brief Update element size. */
	protected func void updateElementSize()
		pElementWidth = 1
		pElementHeight = 1
		
		if getGuiTheme() != null
			var Point size = Point.new( 1, 1 ).largest( pRenderer.getDefaultSize( this ) )
			pElementWidth = size.getX()
			pElementHeight = size.getY()
		end
	end
	
	/** \brief Recalculate number of visible elements. */
	protected func void recalcVisibleElements()
		var int height = getContainerHeight()
		var int width = getContainerWidth()
		if width == 0 or height == 0
			pVisibleRows = 1
			pVisibleColumns = 1
			return
		end
		
		select pType
		case Type.vertical
			var int elementHeight = getElementHeight()
			
			pVisibleColumns = 1
			pVisibleRows = DEMath.clamp( \
				( height + elementHeight * 2 - 2 ) / elementHeight, \
				1, pListModel.getCount() - getFirstElement() )
			
		case Type.verticalWrap
			var int elementWidth = getElementWidth()
			var int elementHeight = getElementHeight()
			
			pVisibleColumns = DEMath.max( width / elementWidth, 1 )
			pVisibleRows = DEMath.clamp( \
				( height + elementHeight * 2 - 2 ) / elementHeight, \
				1, ( ( pListModel.getCount() - getFirstElement() - 1 ) / pVisibleColumns ) + 1 )
			
		case Type.horizontalWrap
			var int elementWidth = getElementWidth()
			var int elementHeight = getElementHeight()
			
			pVisibleRows = DEMath.max( height / elementHeight, 1 )
			pVisibleColumns = DEMath.clamp( \
				( width + elementWidth * 2 - 2 ) / elementWidth, \
				1, ( ( pListModel.getCount() - getFirstElement() - 1 ) / pVisibleRows ) + 1 )
			
		else
			throw EInvalidParam.new()
		end
	end
	
	/** \brief Update render widgets if required. */
	protected func void updateRenderWidgets()
		if getGuiTheme() == null
			return
		end
		
		runWhileBlockingLayout( block
			// calculate visible lines
			recalcVisibleElements()
			
			// update model if dirty. comes after recalcVisibleElements since these values are used
			if pListModel.getCount() > 0
				checkModel()
			end
			
			// update visible elements panel position to account for pixel offset
			var int elementWidth = getElementWidth()
			var int elementHeight = getElementHeight()
			var BorderSize padding = getPadding()
			
			// update panel visible elements
			pPanelVisibleElements.runWhileBlockingLayout( block
				var GridLayout layout = pPanelVisibleElements.getLayout() cast GridLayout
				var int elementCount = pListModel.getCount()
				var int firstElement = getFirstElement()
				var int i, elementIndex
				
				// set position
				pPanelVisibleElements.setPosition( Point.new( \
					padding.getLeft() - ( pHorzRangeModel.getValue() % elementWidth ), \
					padding.getTop() - ( pVertRangeModel.getValue() % elementHeight ) ) )
				
				// synchronize the widget count with the visible element count and resize panel.
				// the resizing has to be done after removing surplus elements since otherwise
				// the GridLayout throws an exception if the row count does not match the
				// number of widgets to lay out
				var int widgetCount = pPanelVisibleElements.getWidgetCount()
				var int visibleElementCount = \
					DEMath.min( pVisibleColumns * pVisibleRows, \
						DEMath.max( elementCount - firstElement, 0 ) )
				
				while widgetCount > visibleElementCount
					widgetCount--
					pPanelVisibleElements.getWidget( widgetCount ).safeDispose()
				end
				
				select pType
				case Type.vertical
					pPanelVisibleElements.setSize( Point.new( \
						getContainerWidth(), pVisibleRows * elementHeight ) )
					layout.setAxis( LayoutAxis.y )
					
				case Type.verticalWrap
					pPanelVisibleElements.setSize( Point.new( \
						pVisibleColumns * elementWidth, pVisibleRows * elementHeight ) )
					layout.setAxis( LayoutAxis.y )
					
				case Type.horizontalWrap
					pPanelVisibleElements.setSize( Point.new( \
						pVisibleColumns * elementWidth, pVisibleRows * elementHeight ) )
					layout.setAxis( LayoutAxis.x )
					
				else
					throw EInvalidParam.new()
				end
				
				layout.setColumnCount( pVisibleColumns )
				layout.setRowCount( pVisibleRows )
				
				while pPanelVisibleElements.getWidgetCount() < visibleElementCount
					pPanelVisibleElements.addWidget( pRenderer.createRenderer( this ) )
				end
				
				// update visibility and content of the renderers
				for i = 0 to visibleElementCount
					elementIndex = firstElement + i
					if elementIndex < elementCount
						pRenderer.updateRenderer( this, pPanelVisibleElements.getWidget( i ), \
							pListModel.getAt( elementIndex ), elementIndex == pSelectedElement, false )
					end
				end
			end )
			
			pPanelVisibleElements.doLayoutIfBlocked()
		end )
		
		doLayoutIfBlocked()
	end
end
