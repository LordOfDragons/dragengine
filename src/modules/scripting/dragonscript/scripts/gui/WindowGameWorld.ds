/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Gui

pin Dragengine.CameraDirectors
pin Dragengine.Gui.Events
pin Dragengine.Gui.Layouts
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.Preloading



/**
 * \brief Window running a GameWorld.
 * 
 * Simple way to run a game world. All you need to do is subclassing WindowGameWorld.Loader
 * load and assign a game world to the widget. If a game world is present it is updated every
 * frame update. Optionally the updating of the game world and camera director can be
 * individually disabled. This can be used for example to pause the game world processing or
 * to show a main menu without consuming processing time.
 * 
 * The panel contains a WorldRenderer widget showing the content of a GameWorld object if
 * present. The game world is loaded using a subclass of GameWorldLoader. For convenience the
 * class WindowGameWorld.Loader provides support of updating the WindowGameWorld once finished.
 * The most simple solution is to subclass WindowGameWorld.Loader instead of GameWorldLoader.
 * 
 * A CameraDirector can be set to operate the camera and microphone resource. This is the
 * preferred way since it allows to easily change the directory taking control of these
 * resources without having to worry about all  Typically you use ElementCameraDirector
 * to handle camera and microphone relative to a player actor and ConversationCameraDirector
 * to play back conversations.
 * 
 * Window can be styled using designer named "WindowGameWorld". The default style makes the
 * window borderless with no mouse pointer suitable for full screen use.
 * 
 * \par Version 1.12
 * 
 * The layout is enhanced like this to allow for more possibilities:
 * 
 * - WindowGameWorld (StackLayout, designer selector "WindowGameWorld")
 *   - Panel (BorderLayout, getPanelBorder())
 *     - Panel (StackLayout, getPanelStack())
 *       - WorldRenderer (designer selector "WorldRenderer.WindowGameWorld")
 * 
 * The window stack layout allows to stack widgets over the world render panels which should
 * cover the entire window. Typically these are UI widgets not directly interacting with the
 * world renderer panel content.
 * 
 * The getPanelBorder() allows to add UI widgets at the borders of the window to create the
 * UI layouts typically used for games where the world renderer is part of a UI interface
 * the player interacts with (hence not first person shooter type games). Using this panel
 * makes the world renderer and widgets stacked over it to occupy the empty space.
 * 
 * The getPanelStack() allows to add stack widgets over the world renderer itself. These
 * widgets have the same size as the world renderer in contrary to being added to the window
 * itself. This is useful for adding widgets that should only cover the world renderer like
 * targeting reticules or damage indicators.
 */
class WindowGameWorld extends Window
	/**
	 * \brief Game loader for use with WindowGameWorld.
	 * 
	 * Create subclass to implement your game loading while this class handles the window.
	 * If the loading succeeds the loaded game world is set as world in the window.
	 * If loading fails null is set as game world in the window.
	 */
	public class Loader extends GameWorldLoader
		private var WindowGameWorld pWindow
		
		
		
		/** \brief Create game world loader. */
		public func new(WindowGameWorld window)
			if window == null
				throw EInvalidParam.new()
			end
			pWindow = window
		end
		
		/** \brief Create game world loader. */
		public func new(WindowGameWorld window, Console console, Loaders loaders,\
		ElementClassList elementClassList) this(window, console, loaders, elementClassList, null)
		end
		
		/**
		 * \brief Create game world loader.
		 * \version 1.8
		 */
		public func new(WindowGameWorld window, Console console, Loaders loaders,\
		ElementClassList elementClassList, MutableID idGenerator) \
		super(console, loaders, elementClassList, idGenerator)
			if window == null
				throw EInvalidParam.new()
			end
			pWindow = window
		end
		
		/** \brief Dispose of game world loader to break reference loops. */
		public func void dispose()
			super.dispose()
			pWindow = null
		end
		
		
		
		/** \brief Window to update. */
		public func WindowGameWorld getWindow()
			return pWindow
		end
		
		
		
		/**
		 * \brief Loading world finished.
		 * 
		 * Game loader has been cleaned up before calling this method. For this reason the
		 * result of loading is provided as parameters. It is safe to dispose() of the
		 * game loader upon entering this method.
		 */
		public func void onLoadWorldFinished()
			pWindow.setGameWorld(getStubWorld().getGameWorld())
		end
		
		/**
		 * \brief Loading world failed.
		 * 
		 * Game loader has been cleaned up before calling this method. It is safe to dispose()
		 * of the game loader upon entering this method.
		 */
		public func void onLoadWorldFailed()
			pWindow.setGameWorld(null)
		end
	end
	
	
	
	private var Console pConsole
	private var GameWorld pGameWorld
	private var Camera pCamera
	private var Microphone pMicrophone
	private var CameraDirector pCameraDirector
	private var WorldRenderer pWorldRenderer
	private var bool pUpdateGameWorld
	private var bool pUpdateCameraDirector
	private var bool pActivateMicrophone
	private var Panel pPanelBorder
	private var Panel pPanelStack
	
	
	
	/** \brief Create screen sized window using BaseGameApp console. */
	public func new() this(BaseGameApp.getApp().getConsole())
	end
	
	/** \brief Create screen sized window. */
	public func new(Console console) super(0, 0, \
	GraphicSystem.getWindowWidth(), GraphicSystem.getWindowHeight())
		if console == null
			throw EInvalidParam.new()
		end
		
		pUpdateGameWorld = true
		pUpdateCameraDirector = true
		pActivateMicrophone = true
		
		pConsole = console
		
		pCamera = Camera.new()
		pCamera.setFov(80)
		pCamera.setLowestIntensity(1)
		pCamera.setHighestIntensity(20)
		
		pMicrophone = Microphone.new()
		pMicrophone.setLayerMask(LayerMask.newWith(BaseGameApp.WorldLayerBit.audio))
		
		pPanelBorder = Panel.new(BorderLayout.new())
		pPanelStack = Panel.new(StackLayout.new())
		pWorldRenderer = WorldRenderer.new()
		
		setDesignerSelector("WindowGameWorld")
		createContent()
		
		setCanReorder(false)  // prevents window move above overlaying windows
		setWindowState(Window.WindowState.maximized)
		
		startFrameUpdater()
	end
	
	/** \brief Dispose of Widget. */
	public func void dispose()
		setGameWorld(null)
		
		super.dispose()
		
		setCameraDirector(null)
		
		pWorldRenderer = null
		pPanelStack = null
		pPanelBorder = null
		pMicrophone = null
		pCamera = null
		pConsole = null
	end
	
	
	
	/** \brief Console object. */
	public func Console getConsole()
		return pConsole
	end
	
	/** \brief Game world. */
	public func GameWorld getGameWorld()
		return pGameWorld
	end
	
	/**
	 * \brief Set game world or \em null to remove.
	 * 
	 * The old game world is disposed of if present. If disposing causes exceptions the
	 * error is logged and the game world discarded.
	 * 
	 * This is the same as calling setGameWorld(gameWorld, true).
	 * 
	 * Calls onGameWorldChanged() hoock method if the game world changed.
	 */
	public func void setGameWorld(GameWorld gameWorld)
		setGameWorld(gameWorld, true)
	end
	
	/**
	 * \brief Set game world or \em null to remove.
	 * 
	 * If \em dispose is true the old game world is disposed of if present. If disposing
	 * causes exceptions the error is logged and the game world discarded.
	 * 
	 * If \em dispose is false the caller is responsible to dispose of the game world at
	 * the appropriate time. This can be used for games using multiple game worlds they
	 * switch between disposing them at game exit time.
	 * 
	 * Calls onGameWorldChanged() hoock method if the game world changed.
	 */
	public func void setGameWorld(GameWorld gameWorld, bool dispose)
		if gameWorld == pGameWorld
			return
		end
		
		pWorldRenderer.setCamera(null)
		
		if pGameWorld != null
			if AudioSystem.getActiveMicrophone() == pMicrophone
				AudioSystem.setActiveMicrophone(null)
			end
			
			var World world = pGameWorld.getWorld()
			if world.equals(pMicrophone.getParentWorld())
				world.removeMicrophone(pMicrophone)
			end
			if world.equals(pCamera.getParentWorld())
				world.removeCamera(pCamera)
			end
			
			if dispose
				try
					pGameWorld.dispose()
					
				catch Exception e
					pConsole.addError("Exception while disposing GameWorld", e)
				end
			end
		end
		
		pGameWorld = gameWorld
		
		if gameWorld != null
			gameWorld.getWorld().addCamera(pCamera)
			pWorldRenderer.setCamera(pCamera)
			
			gameWorld.getWorld().addMicrophone(pMicrophone)
		end
		
		if pActivateMicrophone
			if gameWorld != null
				AudioSystem.setActiveMicrophone(pMicrophone)
				
			else
				AudioSystem.setActiveMicrophone(null)
			end
		end
		
		onGameWorldChanged()
	end
	
	/** \brief World renderer. */
	public func WorldRenderer getWorldRenderer()
		return pWorldRenderer
	end
	
	/**
	 * \brief Panel with BorderLayout containing world render content.
	 * \version 1.12
	 * 
	 * Allows to add UI widgets at the borders of the window to create the UI layouts typically
	 * used for games where the world renderer is part of a UI interface the player interacts
	 * with (hence not first person shooter type games). Using this panel makes the world
	 * renderer and widgets stacked over it to occupy the empty space.
	 */
	public func Panel getPanelBorder()
		return pPanelBorder
	end
	
	/**
	 * \brief Panel with StackLayout containing world render.
	 * \version 1.12
	 * 
	 * Allows to add stack widgets over the world renderer itself. These widgets have the same
	 * size as the world renderer in contrary to being added to the window itself. This is
	 * useful for adding widgets that should only cover the world renderer like targeting
	 * reticules or damage indicators.
	 */
	public func Panel getPanelStack()
		return pPanelStack
	end
	
	/** \brief Game camera. */
	public func Camera getCamera()
		return pCamera
	end
	
	/** \brief Microphone to hear sound. */
	public func Microphone getMicrophone()
		return pMicrophone
	end
	
	/** \brief Camera directory or \em null. */
	public func CameraDirector getCameraDirector()
		return pCameraDirector
	end
	
	/**
	 * \brief Set camera directory or \em null.
	 * 
	 * Deactivates the old camera director if present and unsets camera and microphone.
	 * Activates the new camera if present and sets camera and microphone.
	 * 
	 * Updates the camera director once if updating camera director is enabled
	 */
	public func void setCameraDirector(CameraDirector director)
		if director == pCameraDirector
			return
		end
		
		if pCameraDirector != null
			pCameraDirector.deactivate()
			pCameraDirector.setCamera(null)
			pCameraDirector.setMicrophone(null)
		end
		
		pCameraDirector = director
		
		if director != null
			director.setCamera(pCamera)
			director.setMicrophone(pMicrophone)
			director.activate()
			
			if pUpdateCameraDirector
				director.update(0)
			end
		end
	end
	
	/** \brief Update game world on frame updates. */
	public func bool getUpdateGameWorld()
		return pUpdateGameWorld
	end
	
	/** \brief Set update game world on frame updates. */
	public func void setUpdateGameWorld(bool update)
		pUpdateGameWorld = update
	end
	
	/** \brief Update camera director on frame updates. */
	public func bool getUpdateCameraDirector()
		return pUpdateCameraDirector
	end
	
	/** \brief Set update camera director on frame updates. */
	public func void setUpdateCameraDirector(bool update)
		pUpdateCameraDirector = update
	end
	
	/** \brief Activate microphone if game world is set. */
	public func bool getActivateMicrophone()
		return pActivateMicrophone
	end
	
	/** \brief Set if microphone is activated if game world is set. */
	public func void setActivateMicrophone(bool activateMicrophone)
		pActivateMicrophone = activateMicrophone
	end
	
	
	
	/**
	 * \brief Project point from 3d world.
	 * \version 1.7
	 */
	public func Point project(DVector position)
		return pWorldRenderer.project(position)
	end
	
	/**
	 * \brief Back project position into 3d world.
	 * \version 1.7
	 */
	public func Vector backProject(Point position)
		return pWorldRenderer.backProject(position)
	end

	
	/**
	 * \brief Back project position into 3d world.
	 * \version 1.7
	 * 
	 * Event can originate from any widget inside the window. The event position is converted
	 * to world renderer coordinate system before calling backProject on world renderer.
	 */
	public func Vector backProject(MouseEvent event)
		return pWorldRenderer.backProject((event.getSource() cast Widget).getWindowPosition()\
			+ event.getPosition() - pWorldRenderer.getWindowPosition())
	end
	
	
	
	/**
	 * \brief Update game world every frame update if present.
	 * 
	 * \param elapsed Elapsed time as reported by Engine.getElapsedTime().
	 */
	public func void onFrameUpdate(float elapsed)
		if pGameWorld == null
			return
		end
		
		if pUpdateGameWorld
			pGameWorld.update(elapsed)
		end
		
		if pCameraDirector != null and pUpdateCameraDirector
			pCameraDirector.update(elapsed)
		end
	end
	
	/**
	 * \brief Game world changed.
	 */
	public func void onGameWorldChanged()
	end
	
	/**
	 * \brief Designer selector changed.
	 * 
	 * Updates world renderer widget designer selector to "WorldRenderer.{selector}".
	 */
	public func void onDesignerSelectorChanged()
		super.onDesignerSelectorChanged()
		
		if pWorldRenderer != null
			pWorldRenderer.setDesignerSelector("WorldRenderer." + getDesignerSelector())
		end
	end
	
	
	
	/**
	 * \brief Create window content.
	 * 
	 * Called during constructor. Sets StackLayout as window layout and adds
	 * getWorldRenderer() as only widget.
	 */
	protected func void createContent()
		runWhileBlockingLayout(block
			setLayout(StackLayout.new())
			pPanelStack.addWidget(pWorldRenderer)
			pPanelBorder.addWidget(pPanelStack, BorderLayout.Area.content)
			addWidget(pPanelBorder)
		end)
	end
end
