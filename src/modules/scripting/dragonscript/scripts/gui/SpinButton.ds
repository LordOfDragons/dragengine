/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Borders
pin Dragengine.Gui.Designers
pin Dragengine.Gui.Events
pin Dragengine.Gui.Layouts
pin Dragengine.Gui.Listeners
pin Dragengine.Scenery
pin Dragengine.Utils


/**
 * Shows two buttons allowing to manipulate a range value.
 * 
 * Supports designing using designer selector "SpinButton". Designer has to implement
 * interface SpinButtonDesigner.
 */
class SpinButton extends Container implements RangeModelListener
	/** Direction button state change listener. */
	class DirectionButtonStateListener extends DefaultStateChangeListener
		/** Spin action. */
		var ActionListener pActionSpin
		
		/** Repeat spin timer */
		var RepeatActionTimer pRepeatSpinTimer
		
		/** Create direction button. */
		func new( ActionListener spinAction )
			pActionSpin = spinAction
		end
		
		/** \brief Widget changed state. */
		func void onStateChanged( StateChangeEvent event )
			if ( event.getSource() cast Button ).getPressed()
				if pRepeatSpinTimer == null
					pRepeatSpinTimer = RepeatActionTimer.new( pActionSpin, event.getSource(), 0 )
					pRepeatSpinTimer.sendEvent()
				end
				
			else
				if pRepeatSpinTimer != null
					pRepeatSpinTimer.giveUp()
					pRepeatSpinTimer = null
				end
			end
		end
		
		/** \brief Dispose of listener. */
		func void dispose()
			if pRepeatSpinTimer != null
				pRepeatSpinTimer.giveUp()
				pRepeatSpinTimer = null
			end
		end
	end
	
	/** Action spin up action. */
	class ActionSpinUp extends DefaultActionListener
		var SpinButton pSpinButton
		func new( SpinButton spinButton )
			pSpinButton = spinButton
		end
		func void onAction( ActionEvent event )
			var RangeModel model = pSpinButton.getModel()
			
			if ( event.getModifiers() & ModifiableEvent.shift ) == ModifiableEvent.shift
				model.setValue( model.getValue() + model.getPageSize() )
				
			else
				model.setValue( model.getValue() + model.getIncrement() )
			end
		end
	end
	
	/** Action spin down action. */
	class ActionSpinDown extends DefaultActionListener
		var SpinButton pSpinButton
		func new( SpinButton spinButton )
			pSpinButton = spinButton
		end
		func void onAction( ActionEvent event )
			var RangeModel model = pSpinButton.getModel()
			
			if ( event.getModifiers() & ModifiableEvent.shift ) == ModifiableEvent.shift
				model.setValue( model.getValue() - model.getPageSize() )
				
			else
				model.setValue( model.getValue() - model.getIncrement() )
			end
		end
	end
	
	
	
	/** Range Model */
	var RangeModel pModel
	
	/** Up direction button. */
	var Widget pButtonUp
	
	/** Down direction button. */
	var Widget pButtonDown
	
	/** \brief Button state listeners to clean up upon dispose. */
	var Array pDisposeButtonStateListeners
	
	
	
	/** Create spin button widget. */
	func new() this( DefaultRangeModel.new() )
	end
	
	/** Create spin button widget. */
	func new( RangeModel model )
		pDisposeButtonStateListeners = Array.new()
		
		setDesignerSelector( "SpinButton" )
		
		addMouseListener( WheelActionMouseListener.new( \
			ActionSpinUp.new( this ), ActionSpinDown.new( this ) ) )
		
		pModel = model
		pModel.addListener( this )
		
		createContent()
		enableDirectionButtons()
	end
	
	/** Dispose of widget. */
	func void dispose()
		if pDisposeButtonStateListeners != null
			pDisposeButtonStateListeners.forEach( block DirectionButtonStateListener each
				each.dispose()
			end )
			pDisposeButtonStateListeners = null
		end
		pButtonUp = null
		pButtonDown = null
		if pModel != null
			pModel.removeListener( this )
			pModel = null
		end
		
		super.dispose()
	end
	
	
	
	/** Range model. */
	func RangeModel getModel()
		return pModel
	end
	
	/** Set range model. */
	func void setModel( RangeModel model )
		if model == null
			throw EInvalidParam.new()
		end
		
		if model == pModel
			return
		end
		
		pModel.removeListener( this )
		pModel = model
		pModel.addListener( this )
		
		enableDirectionButtons()
	end
	
	
	
	/**
	 * Send if the outer range properties like minimum value,
	 * maximum value or page size has changed.
	 */
	func void rangeChanged( RangeModel rangeModel )
		enableDirectionButtons()
	end
	
	/** Send if the value has changed. */
	func void valueChanged( RangeModel rangeModel )
		enableDirectionButtons()
	end
	
	
	
	/** \brief Remove all widgets. */
	func void removeAllWidgets()
		super.removeAllWidgets()
		
		if pDisposeButtonStateListeners != null
			pDisposeButtonStateListeners.forEach( block DirectionButtonStateListener each
				each.dispose()
			end )
			pDisposeButtonStateListeners.removeAll()
		end
	end
	
	
	
	/** Notification that the gui theme changed. */
	func void onGuiThemeChanged()
		createContent()
		enableDirectionButtons()
		
		super.onGuiThemeChanged() // does doLayout
	end
	
	/** \brief Designer changed. */
	func void onDesignerChanged()
		createContent()
	end
	
	
	
	/**
	 * \brief Get designer from gui theme.
	 * 
	 * Modified to ensure a DefaultSpinButtonDesigner is used if
	 * super.getDesignerFromTheme() returns null.
	 */
	protected func WidgetDesigner getDesignerFromTheme()
		var WidgetDesigner designer = super.getDesignerFromTheme()
		if designer == null
			designer = DefaultSpinButtonDesigner.new()
		end
		return designer
	end
	
	
	
	/** Create content widgets. */
	func void createContent()
		if getGuiTheme() == null
			pButtonUp = null
			pButtonDown = null
			removeAllWidgets()
			return
		end
		
		var SpinButtonDesigner designer = getDesigner() cast SpinButtonDesigner
		
		runWhileBlockingLayout( block
			// clear minimum size
			setMinimumSize( null )
			
			// remove all widgets
			pButtonUp = null
			pButtonDown = null
			removeAllWidgets()
			
			// set fixed width
			//setMinimumSize( Point.new( designer.spinButtonSize( this ), 0 ) )
			
			// set layout to box layout
			setLayout( BoxLayout.new( LayoutAxis.y ) )
			
			// create shared wheel action mouse listener
			var MouseListener wheelListener = WheelActionMouseListener.new( \
				ActionSpinUp.new( this ), ActionSpinDown.new( this ) )
			
			// create direction buttons
			pButtonUp = designer.createButtonUp( this )
			pButtonUp.setCanFocus(false)
			pButtonUp.addMouseListener( wheelListener )
			var DirectionButtonStateListener stateListener = \
				DirectionButtonStateListener.new( ActionSpinUp.new( this ) )
			pDisposeButtonStateListeners.add( stateListener )
			pButtonUp.addStateChangeListener( stateListener )
			addWidget( pButtonUp )
			
			pButtonDown = designer.createButtonDown( this )
			pButtonDown.setCanFocus(false)
			pButtonDown.addMouseListener( wheelListener )
			stateListener = DirectionButtonStateListener.new( ActionSpinDown.new( this ) )
			pDisposeButtonStateListeners.add( stateListener )
			pButtonDown.addStateChangeListener( stateListener )
			addWidget( pButtonDown )
		end )
		
		doLayoutIfBlocked()
		
		// set fixed width
		setMinimumSize( Point.new( designer.spinButtonSize( this ), getMinimumSize().getY() ) )
	end
	
	/** Enable direction buttons depending on the model value. */
	func void enableDirectionButtons()
		if pButtonUp != null
			pButtonUp.setEnabled( pModel.getValue() < pModel.getMaximum() )
		end
		if pButtonDown != null
			pButtonDown.setEnabled( pModel.getValue() > pModel.getMinimum() )
		end
	end
end
