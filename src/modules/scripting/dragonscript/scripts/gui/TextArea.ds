/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Borders
pin Dragengine.Gui.Events
pin Dragengine.Scenery
pin Dragengine.Utils


/**
 * Displays an edit field where the user can enter a text with more
 * than one line.
 * 
 * Supports designing using designer selector "TextArea".
 */
class TextArea extends TextWidget implements RangeModelListener
	private var TextLayout pTextLayout
	private var Point pCaret
	private var int pCursorPos
	private var int pMaxWidth
	private var bool pNeedsUpdate
	private var int pRefXPos
	private var bool pRefXPosDirty
	private var Point pSelection
	private var int pOldCursorPos
	private var Point pSelXOffsets
	private var DefaultRangeModel pVertRangeModel
	private var int pRowCount
	
	
	
	/** Creates a new Text Area. */
	public func new() this(DefaultTextModel.new())
	end
	
	/** Creates a new Text Field. */
	public func new(String text) this(DefaultTextModel.new(text))
	end
	
	/** Creates a new Text Field. */
	public func new(TextModel textModel) this(textModel, false)
	end
	
	/** \brief Create text area. */
	public func new(TextModel textModel, bool readOnly) super(textModel, readOnly)
		pCursorPos = 0
		pMaxWidth = 150
		pOldCursorPos = -1
		pRefXPos = 0
		pRefXPosDirty = true
		pNeedsUpdate = true
		pRowCount = 5
		
		setCanFocus(true)
		pVertRangeModel = DefaultRangeModel.new(0, 0, 1, 0, 1)
		pVertRangeModel.addListener(this)
		
		setDesignerSelector("TextArea")
		setCanFocus(true)
		setActionOnEnter(false)
		setAddTabToText(true)
		
		updateCanvasText()
	end
	
	/** \brief Create text area. */
	public func new(TextModel textModel, int rowCount) this(textModel)
		setRowCount(rowCount)
	end
	
	/** \brief Create text area. */
	public func new(TextModel textModel, int rowCount, bool readOnly) this(textModel, readOnly)
		setRowCount(rowCount)
	end
	
	/** Dispose of this widget. */
	public func void dispose()
		pVertRangeModel.removeListener(this)
		pVertRangeModel = null
		super.dispose()
	end
	
	
	
	/**
	 * Retrieves the vertical range model. Viewport widgets can
	 * use this range model to synchronize with their vertical
	 * scrollbar. If this widget has no reasonable vertical
	 * range model it should return null.
	 */
	public func RangeModel getVerticalRangeModel()
		return pVertRangeModel
	end
	
	/**
	 * Retrieves the horizontal range model. Viewport widgets can
	 * use this range model to synchronize with their horizontal
	 * scrollbar. If this widget has no reasonable horizontal
	 * range model it should return null.
	 */
	public func RangeModel getHorizontalRangeModel()
		return null
	end
	
	
	
	/** Retrieves the line the cursor is on. */
	public func int getCursorLine()
		var int i, count = pTextLayout.getLineCount()
		
		for i = 1 to count
			if pCursorPos < pTextLayout.getLine(i).getFirstChar()
				return i - 1
			end
		end
		
		return count - 1
	end
	
	/** Retrieves the line for a specific cursor position. */
	public func int getCursorLineFor(int pos)
		if pos < 0 or pos > getModel().getText().getLength()
			throw EInvalidParam.new()
		end
		
		var int i, count = pTextLayout.getLineCount()
		
		for i = 1 to count
			if pos < pTextLayout.getLine(i).getFirstChar()
				return i - 1
			end
		end
		
		return count - 1
	end
	
	/** Retrieves the current position of the cursor in the text. */
	public func int getCursorPosition()
		return pCursorPos
	end
	
	/** Retrieves the selection if present. */
	public func Point getSelection()
		return pSelection
	end
	
	/** Retrieves the index of the first line visible. */
	public func int getFirstLine()
		return pVertRangeModel.getValue()
	end
	
	/** Retrieve maximal width of text before break occurs. */
	public func int getMaximalWidth()
		return pMaxWidth
	end
	
	/** Retrieves the number of text lines. */
	public func int getLineCount()
		return pTextLayout.getLineCount()
	end
	
	/** Retrieves the number of characters on the current line. */
	public func int getCursorLineCharCount()
		return pTextLayout.getLine(getCursorLine()).getCharCount()
	end
	
	/**
	 * Sets the current cursor position in the text. If the cursor is outside
	 * the visible area the text is shifted to make the cursor visible.
	 */
	public func void setCursorPosition(int pos)
		if pos < 0 or pos > getModel().getText().getLength()
			throw EInvalidParam.new()
		end
		
		pCursorPos = pos
		pCaret = null
		pRefXPosDirty = true
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** Sets the cursor position to the start of the text. */
	public func void setCursorPositionStart()
		setCursorPosition(0)
	end
	
	/** Sets the cursor position to the end of the text. */
	public func void setCursorPositionEnd()
		setCursorPosition(getModel().getText().getLength())
	end
	
	/** Sets the selection or clears it. */
	public func void setSelection(Point selection)
		if selection != null
			if selection.getX() < 0 or selection.getY() > getModel().getText().getLength()
				throw EInvalidParam.new()
			end
			
			if selection.getX() == selection.getY()
				selection = null
			end
		end
		
		pSelection = selection
		pSelXOffsets = null
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** Sets the selection to the entire text. */
	public func void setSelectionAll()
		setSelection(Point.new(0, getModel().getText().getLength()))
	end
	
	/** Sets maximal width of text before break occurs. */
	public func void setMaximalWidth(int width)
		if width < 0
			throw EInvalidParam.new()
		end
		
		pMaxWidth = width
		pTextLayout = null
		pSelXOffsets = null
		pCaret = null
		updateCanvasText()
	end
	
	/** Calculates the size of the content text. */
	public func Point getTextSize()
		return Point.new(pTextLayout.getWidth(), pTextLayout.getHeight())
	end
	
	/** \brief Number display rows. */
	public func int getRowCount()
		return pRowCount
	end
	
	/** \brief Set number display rows. */
	public func void setRowCount(int rowCount)
		if rowCount == pRowCount
			return
		end
		
		if rowCount < 1
			throw EInvalidParam.new()
		end
		
		pRowCount = rowCount
		pTextLayout = null
		updateCanvasText()
	end
	
	
	
	/** Deletes the selected text if present. */
	public func void deleteSelectedText()
		if getReadOnly() or pSelection == null
			return
		end
		
		var String curText = getModel().getText()
		var int textLen = curText.getLength()
		var String newText = ""
		
		if pSelection.getX() > 0
			newText = newText + curText.substring(0, pSelection.getX())
		end
		if textLen - pSelection.getY() > 0
			newText = newText + curText.substring(pSelection.getY())
		end
		
		if getValidator() == null or getValidator().validates(newText)
			pCursorPos = pSelection.getX()
			pSelection = null
			setHasTyped(true)
			getModel().setText(newText)
		end
	end
	
	
	
	/** Ensure that the cursor is visible by scrolling the text if necessary. */
	public func void ensureCursorVisible()
		/*
		var Font font = getFont()
		var int width = getWidth() - getPadding().getWidth()
		var int i, textLen = 0
		var String text
		// check for password
		if pPasswordChar == noPasswordChar
			text = pText
		else
			text = String.new(pPasswordChar cast byte, pText.getLength())
		end
		// check if the cursor is outside the left boundary
		if pCaretPos < pFirstChar
			pFirstChar = pCaretPos
		else
			// check if the cursor is outside the right boundary
			for i = pCaretPos - 1 downto pFirstChar
				textLen += font.getCharAdvance(text.getAt(i))
				if textLen + 2 >= width
					pFirstChar = i + 1
					break
				end
			end
			// check if there is still space to fill up on the right side
			for i = pCaretPos to text.getLength()
				textLen += font.getCharAdvance(text.getAt(i))
				if textLen + 2 >= width
					break
				end
			end
			if textLen + 2 < width
				for i = pFirstChar - 1 downto 0
					textLen += font.getCharAdvance(text.getAt(i))
					if textLen + 2 >= width
						break
					end
					pFirstChar = i
				end
			end
		end
		*/
	end
	
	
	
	/** Notification that the gui theme changed. */
	public func void onGuiThemeChanged()
		super.onGuiThemeChanged()
		
		pTextLayout = null
		pSelXOffsets = null
		pCaret = null
		pRefXPosDirty = true
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Padding changed. */
	public func void onPaddingChanged()
		super.onPaddingChanged()
		
		pTextLayout = null
		pSelXOffsets = null
		pNeedsUpdate = true
		pCaret = null
		updateCanvasText()
	end
	
	/** \brief Size changed. */
	public func void onResize(WidgetEvent event)
		super.onResize(event)
		pTextLayout = null
		pSelXOffsets = null
		pCaret = null
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** Notify about font change. */
	public func void onSetFont()
		pTextLayout = null
		pSelXOffsets = null
		pCaret = null
		pRefXPosDirty = true
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** Foreground color changed. */
	public func void onSetTextColor()
		updateCanvasText()
	end
	
	/** \brief Widget received focus. */
	public func void onFocusReceived(FocusEvent event)
		super.onFocusReceived(event)
		updateCanvasText()
		popupVirtualKeyboard()
	end
	
	/** \brief Widget lost focus. */
	public func void onFocusLost(FocusEvent event)
		super.onFocusLost(event)
		updateCanvasText()
		popdownVirtualKeyboard()
	end
	
	
	
	/** Retrieve the minimal size of widget. */
	public func Point getMinimumSize()
		if isMinimumSizeSet()
			return super.getMinimumSize()
		end
		
		var Font font = getFont()
		if font == null
			return super.getMinimumSize()
		end
		
		return Point.new(pMaxWidth, font.getSize() * pRowCount \
			+ getPadding().getHeight())
	end
	
	
	
	/**
	 * \brief Minimum size of widget using reference widget width and variable height.
	 * \details Default implementation uses getMinimumSize().
	 */
	public func Point getMinimumSizeForWidth(int width)
		if isMinimumSizeSet()
			return super.getMinimumSize()
		end
		
		var Font font = getFont()
		if font == null
			return Point.new()
		end
		
		return Point.new(DEMath.min(width, pMaxWidth), \
			font.getSize() * pRowCount + getPadding().getHeight())
	end
	
	
	
	/** Key pressed event. */
	public func void onKeyPress(KeyEvent event)
		var int line = getCursorLine()
		var int first = pTextLayout.getLine(line).getFirstChar()
		var int count = pTextLayout.getLine(line).getCharCount()
		var bool update = false
		
		select event.getKeyCode()
		case InputEventKey.arrowUp
			// move cursor up
			if line > 0
				var int nextCursorPos = bestCharNear(line - 1, getRefXPos())
				
				// select text
				if (event.getModifiers() & InputEventModifier.shift) == InputEventModifier.shift
					if pSelection == null
						pSelection = Point.new(nextCursorPos, pCursorPos)
						
					elif pSelection.getY() == pCursorPos
						pSelection = Point.new(pSelection.getX(), nextCursorPos)
						
					elif pSelection.getX() == pCursorPos
						pSelection = Point.new(nextCursorPos, pSelection.getY())
						
					else
						pSelection = Point.new(nextCursorPos, pCursorPos)
					end
					
					if pSelection.getX() == pSelection.getY()
						pSelection = null
						
					elif pSelection.getX() > pSelection.getY()
						pSelection = Point.new(pSelection.getY(), pSelection.getX())
					end
					
				else
					pSelection = null
				end
				
				// move cursor left
				pCursorPos = nextCursorPos
				update = true
			end
			
		case InputEventKey.arrowDown
			// move cursor down
			if line < getLineCount() - 1
				var int nextCursorPos = bestCharNear(line + 1, getRefXPos())
				
				// select text
				if (event.getModifiers() & InputEventModifier.shift) == InputEventModifier.shift
					if pSelection == null
						pSelection = Point.new(pCursorPos, nextCursorPos)
						
					elif pSelection.getY() == pCursorPos
						pSelection = Point.new(pSelection.getX(), nextCursorPos)
						
					elif pSelection.getX() == pCursorPos
						pSelection = Point.new(nextCursorPos, pSelection.getY())
						
					else
						pSelection = Point.new(pCursorPos, nextCursorPos)
					end
					
					if pSelection.getX() == pSelection.getY()
						pSelection = null
						
					elif pSelection.getX() > pSelection.getY()
						pSelection = Point.new(pSelection.getY(), pSelection.getX())
					end
					
				else
					pSelection = null
				end
				
				// move cursor left
				pCursorPos = nextCursorPos
				update = true
			end
			
		case InputEventKey.arrowLeft
			if pCursorPos > 0
				// select text
				if (event.getModifiers() & InputEventModifier.shift) == InputEventModifier.shift
					if pSelection == null
						pSelection = Point.new(pCursorPos - 1, pCursorPos)
						
					elif pSelection.getY() == pCursorPos
						pSelection = Point.new(pSelection.getX(), pCursorPos - 1)
						if pSelection.getX() == pSelection.getY()
							pSelection = null
						end
						
					elif pSelection.getX() == pCursorPos
						pSelection = Point.new(pCursorPos - 1, pSelection.getY())
						
					else
						pSelection = Point.new(pCursorPos - 1, pCursorPos)
					end
					
				else
					pSelection = null
				end
				
				// move cursor left
				pCursorPos--
				pRefXPosDirty = true
				update = true
			end
			
		case InputEventKey.arrowRight
			if pCursorPos < getModel().getText().getLength()
				// select text
				if (event.getModifiers() & InputEventModifier.shift) == InputEventModifier.shift
					if pSelection == null
						pSelection = Point.new(pCursorPos, pCursorPos + 1)
						
					elif pSelection.getY() == pCursorPos
						pSelection = Point.new(pSelection.getX(), pCursorPos + 1)
						
					elif pSelection.getX() == pCursorPos
						pSelection = Point.new(pCursorPos + 1, pSelection.getY())
						if pSelection.getX() == pSelection.getY()
							pSelection = null
						end
						
					else
						pSelection = Point.new(pCursorPos, pCursorPos + 1)
					end
					
				else
					pSelection = null
				end
				
				// move cursor right
				pCursorPos++
				pRefXPosDirty = true
				update = true
			end
			
		case InputEventKey.home
			// move to the beginning of the line
			if pCursorPos != first
				pCursorPos = first
				pRefXPosDirty = true
				pSelection = null
				update = true
			end
			
		case InputEventKey.last
			// move to the end of the line
			if pCursorPos != first + count
				pCursorPos = first + count
				pRefXPosDirty = true
				pSelection = null
				update = true
			end
			
		//case InputEventKey.enter
			// we intercept enter to avoid launching a default button. later on a property can
			// be used to allow this if required
			
			// PROBLEM. super class call is required for KEY_RETURN to be processed as onKeyType()
			//          when default button is working we need a real solution for  most
			//          probably adding a parameter to TextWidget to state if KEY_RETURN has to
			//          be swallowed or not
			
		else
			super.onKeyPress(event)
		end
		
		// update if needed
		if update
			pCaret = null
			pSelXOffsets = null
			ensureCursorVisible()
			updateCanvasText()
		end
	end
	
	/** Key released event. */
//	public func void onKeyRelease(KeyEvent event)
//	end
	
	
	
	/** Notification that a mouse button has been pressed. */
	public func void onButtonPress(MouseEvent event)
		super.onButtonPress(event)
		
		var int scrollOffsetY = pVertRangeModel.getValue() * getFont().getSize()
		
		if event.getButton() == InputEventMouseButton.left
			var Point position = event.getPosition()
			var int realX = position.getX() - getPadding().getLeft()
			var int realY = position.getY() - getPadding().getTop() + scrollOffsetY
			
			captureMouse()
			pCursorPos = bestCharNear(bestLineNear(realY), realX)
			pOldCursorPos = pCursorPos
			pCaret = null
			pSelection = null
			pSelXOffsets = null
			pRefXPosDirty = true
			updateCanvasText()
		end
	end
	
	/** Notification that a mouse button has been released. */
	public func void onButtonRelease(MouseEvent event)
		super.onButtonRelease(event)
		
		if pOldCursorPos > -1
			pOldCursorPos = -1
			releaseMouse()
		end
	end
	
	/** Notification that the mouse has moved. */
	public func void onMouseMove(MouseEvent event)
		super.onMouseMove(event)
		
		var int scrollOffsetY = pVertRangeModel.getValue() * getFont().getSize()
		
		if pOldCursorPos != -1
			var Point position = event.getPosition()
			var int realX = position.getX() - getPadding().getLeft()
			var int realY = position.getY() - getPadding().getTop() + scrollOffsetY
			
			pCursorPos = bestCharNear(bestLineNear(realY), realX)
			
			if pCursorPos == pOldCursorPos
				pSelection = null
			elif pCursorPos < pOldCursorPos
				pSelection = Point.new(pCursorPos, pOldCursorPos)
			else
				pSelection = Point.new(pOldCursorPos, pCursorPos)
			end
			
			pSelXOffsets = null
			pCaret = null
			pRefXPosDirty = true
			updateCanvasText()
		end
	end
	
	
	
	/**
	 * Retrieves the index of the best character on line
	 * in respect to the reference x position.
	 */
	protected func int bestCharNear(int line, int refXPos)
		var int first = pTextLayout.getLine(line).getFirstChar()
		var int count = pTextLayout.getLine(line).getCharCount()
		var float floatRefXPos = refXPos cast float
		var Font font = getFont()
		var String curText
		var float x = 0.0
		var int i
		
		curText = getModel().getText()
		
		if count > 0
			x = font.getCharAdvance(curText.getAt(first))
			for i = 1 to count
				if floatRefXPos < x
					return first + i - 1
				end
				x += font.getCharAdvance(curText.getAt(first + i))
			end
		end
		
		return first + count
	end
	
	/** Finds best line in reference to a given y position. */
	protected func int bestLineNear(int refYPos)
		var int i, count = pTextLayout.getLineCount()
		
		for i = 1 to count
			if refYPos < pTextLayout.getLine(i).getY()
				return i - 1
			end
		end
		
		return count - 1
	end
	
	/** Calculates the offset to cursor. */
	protected func Point getOffsetToCursor()
		var int line = getCursorLine()
		var int first = pTextLayout.getLine(line).getFirstChar()
		var Font font = getFont()
		var String curText
		var float x = 0.0
		var int i
		
		curText = getModel().getText()
		
		for i = first to pCursorPos
			x += font.getCharAdvance(curText.getAt(i))
		end
		
		return Point.new(x cast int, pTextLayout.getLine(line).getY())
	end
	
	/** Retrieves the reference x position. */
	protected func int getRefXPos()
		if pRefXPosDirty
			pRefXPos = getCaret().getX()
			pRefXPosDirty = false
		end
		
		return pRefXPos
	end
	
	/** Retrieves the caret position. */
	protected func Point getCaret()
		if pCaret == null
			pCaret = getOffsetToCursor()
		end
		return pCaret
	end
	
	/** Retrieves the selection x offsets. */
	protected func Point getSelectionXOffsets()
		if pSelXOffsets == null and pSelection != null
			var int startLine = getCursorLineFor(pSelection.getX())
			var int endLine = getCursorLineFor(pSelection.getY())
			var Font font = getFont()
			var String curText
			var int first
			var int i, pos
			var float xs = 0.0
			var float xe = 0.0
			
			// start offset
			curText = getModel().getText()
			first = pTextLayout.getLine(startLine).getFirstChar()
			pos = pSelection.getX()
			for i = first to pos
				xs += font.getCharAdvance(curText.getAt(i))
			end
			
			// end offset
			first = pTextLayout.getLine(endLine).getFirstChar()
			pos = pSelection.getY()
			for i = first to pos
				xe += font.getCharAdvance(curText.getAt(i))
			end
			
			// store offsets
			pSelXOffsets = Point.new(xs cast int, xe cast int)
		end
		
		return pSelXOffsets
	end
	
	/** Update range models. */
	protected func void updateRangeModels()
		var int height = getHeight() - getPadding().getHeight()
		var int windowLines = DEMath.max(height / getFont().getSize(), 1)
		var int maxLines = DEMath.max(getLineCount() - windowLines, 0)
		
		pVertRangeModel.setAll(0, maxLines, windowLines, getFirstLine(), 1)
	end
	
	
	
	/** Checks that the cursor is inside the text boundaries and adjust it if necessary. */
	protected func void checkBoundaries()
		var int textLen = getModel().getText().getLength()
		
		// check selection positions
		if pSelection != null
			var int selStart = DEMath.clamp(pSelection.getX(), 0, textLen)
			var int selEnd = DEMath.clamp(pSelection.getY(), 0, textLen)
			
			if selEnd > selStart
				pSelection = Point.new(selStart, selEnd)
				
			else
				pSelection = null
			end
		end
		pSelXOffsets = null
		
		// check cursorposition
		pCursorPos = DEMath.clamp(pCursorPos, 0, textLen)
		pCaret = null
		pRefXPosDirty = true
		
		// we need update next round
		pNeedsUpdate = true
	end
	
	
	
	/** Update canvas. */
	private func void updateCanvasText()
		var Font font = getFont()
		if font == null
			getCanvasContent().removeAllCanvas()
			return
		end
		
		updateTextLayout()
		
		var Color color = getTextColor()
		if color == null
			getCanvasContent().removeAllCanvas()
			return
		end
		
		pTextLayout.setFont(font)
		pTextLayout.setColor(color)
		pCaret = null
		
		var Point caret = getCaret()
		var int charHeight = font.getSize()
		var int scrollOffsetY = pVertRangeModel.getValue() * charHeight
		var int width = getWidth() - 1 - getPadding().getWidth()
		var int height = getHeight() - 1 - getPadding().getHeight()
		var int i
		var int selFrom = -1, selTo = -1, soff, eoff
		var int realHeight = charHeight + 3
		var Point selXOffsets
		
		// check for update
		if pNeedsUpdate
			ensureCursorVisible()
			pNeedsUpdate = false
		end
		
		// add text lines as canvas including selection rectangles
		var CanvasView canvas = getCanvasContent()
		canvas.removeAllCanvas()
		
		var int lineCount = pTextLayout.getLineCount()
		var int x = getPadding().getLeft()
		var int y = getPadding().getTop() - scrollOffsetY
		
		if pSelection != null
			selXOffsets = getSelectionXOffsets()
			selFrom = pSelection.getX()
			selTo = pSelection.getY()
		end
		
		for i = 0 to lineCount
			var TextLayoutLine textLine = pTextLayout.getLine(i)
			
			if selFrom != -1
				var int firstChar = textLine.getFirstChar()
				var int charCount = textLine.getCharCount()
				
				// add selection background rectangle if required
				if selFrom <= firstChar + charCount and selTo >= firstChar
					if selFrom < firstChar
						soff = 0
						
					else
						soff = selXOffsets.getX()
					end
					
					if selTo > firstChar + charCount
						eoff = textLine.getWidth()
						
					else
						eoff = selXOffsets.getY()
					end
					
					// add canvas
					var CanvasPaint canvasSelect = CanvasPaint.new()
					canvasSelect.setShapeType(CanvasPaintShape.rectangle)
					canvasSelect.setFillColor(Color.lightGray)
					canvasSelect.setThickness(0.0)
					canvasSelect.setPosition(Point.new(x + soff, y + textLine.getY()))
					canvasSelect.setSize(Point.new(eoff - soff, textLine.getHeight()))
					canvasSelect.setOrder(canvas.getCanvasCount() cast float)
					canvas.addCanvas(canvasSelect)
				end
			end
			
			// add text line canvas
			textLine.addToCanvas(pTextLayout, canvas, x, y)
		end
		
		// draw cursor
		if getHasFocus()
			x = caret.getX()
			y = caret.getY() - scrollOffsetY
			
			if x >= 0 and x <= width
				var CanvasPaint canvasCaret = CanvasPaint.new()
				canvasCaret.setShapeType(CanvasPaintShape.lines)
				canvasCaret.setFillColor(Color.transparent)
				canvasCaret.setLineColor(Color.black)
				canvasCaret.setPosition(Point.new(x + getPadding().getLeft(), y + getPadding().getTop()))
				canvasCaret.setSize(Point.new(1, charHeight))
				canvasCaret.setOrder(canvas.getCanvasCount() cast float)
				
				canvasCaret.addPoint(Point.new(0, 0))
				canvasCaret.addPoint(Point.new(0, charHeight + 1))
				
				canvas.addCanvas(canvasCaret)
			end
		end
	end
	
	/** Updates the text layout for the label. */
	protected func void updateTextLayout()
		// WARNING! right now the model text is not UTF8 anymore if characters are typed
		//          actually the entire widget has to be modified to properly handle utf8
		//          by updating pCursorPos with unicode character width (1-4) instead of
		//          ascii character wide (1). to handle this for the time being the text
		//          is considered ASCII-8 and being converted into UTF8 for the layout
		// Too many problems. >127 characters disabled altogether until the widget is fully reworked
		/*
		var UnicodeString utext = UnicodeString.new()
		var String text = getModel().getText()
		var int i, len = text.getLength()
		for i = 0 to len
			utext = utext + text.getAt(i)
		end
		pTextLayout = TextLayout.new(utext.toUTF8(), getFont())
		*/
		pTextLayout = TextLayout.new(getModel().getText(), getFont())
		pTextLayout.setMaximalWidth(DEMath.max(\
			getWidth() - getPadding().getWidth(), 0))
		pTextLayout.setAlignment(TextLayout.Align.left)
		pTextLayout.setAtLeastOneLine(true)
		
		pTextLayout.layoutText()
		
		updateRangeModels()
	end
	
	
	
	/** Key typed event. */
	public func void onKeyType(KeyEvent event)
		var String curText, newText = ""
		var int textLen
		
		select event.getKeyCode()
		case InputEventKey.backspace
			// delete character left of cursor
			if pSelection == null
				if pCursorPos > 0
					curText = getModel().getText()
					textLen = curText.getLength()
					if pCursorPos - 1 > 0
						newText = newText + curText.substring(0, pCursorPos - 1)
					end
					if textLen - pCursorPos > 0
						newText = newText + curText.substring(pCursorPos)
					end
					if getValidator() == null or getValidator().validates(newText)
						pCursorPos--
						setHasTyped(true)
						getModel().setText(newText)
					end
				end
				
			else
				deleteSelectedText()
			end
			
		case InputEventKey.delete
			// delete character to the right of the cursor
			if pSelection == null
				curText = getModel().getText()
				textLen = curText.getLength()
				
				if pCursorPos < textLen
					if pCursorPos > 0
						newText = newText + curText.substring(0, pCursorPos)
					end
					if textLen - pCursorPos > 1
						newText = newText + curText.substring(pCursorPos + 1)
					end
					if getValidator() == null or getValidator().validates(newText)
						setHasTyped(true)
						getModel().setText(newText)
					end
				end
				
			else
				deleteSelectedText()
			end
			
		case InputEventKey.enter
			insertText("\n")
			
		else
			// TEMPORARY HACK UNTIL WIDGET CAN HANDLE UTF8
			if event.getKeyChar() > 127
				break
			end
			
			// otherwise add character to string
			if getFont().getCharAdvance(event.getKeyChar()) > 0
				insertText((event.getKeyChar() cast byte).toString())
			end
		end
	end
	
	/** \brief Text model changed. */
	public func void onModelChanged()
		updateCanvasText()
	end
	
	/**
	 * Send if the text string has changed.
	 * Implementation of TextModle interface.
	 */
	public func void textChanged(TextModel textModel)
		checkBoundaries()
		updateCanvasText()
	end
	
	/**
	 * \brief Read only state changed.
	 * \vrsion 1.7
	 */
// 	public func void onReadOnlyChanged()
// 		updateCanvasText()
// 	end
	
	
	
	/**
	 * Send if the outer range properties like minimum value, maximum value
	 * or page size has changed.
	 */
	public func void rangeChanged(RangeModel rangeModel)
	end
	
	/** Send if the value has changed. */
	public func void valueChanged(RangeModel rangeModel)
		updateCanvasText()
	end
	
	
	/**
	 * \brief Insert text at cursor deleting selected text if present.
	 * \version 1.11
	 */
	public func void insertText(String text)
		if text == null
			throw ENullPointer.new("text")
		end
		
		deleteSelectedText()
		
		var String curText = getModel().getText()
		var int textLen = curText.getLength()
		var String newText = ""
		
		if pCursorPos > 0
			newText = newText + curText.substring(0, pCursorPos)
		end
		
		newText = newText + text
		
		if textLen - pCursorPos > 0
			newText = newText + curText.substring(pCursorPos)
		end
		
		if getValidator() == null or getValidator().validates(newText)
			pCursorPos += text.getLength()
			setHasTyped(true)
			getModel().setText(newText)
		end
	end
	
	/**
	 * \brief Copy to clipboard requested.
	 * \version 1.11
	 */
	public func void onClipboardCopy()
		var Clipboard clipboard = getClipboard()
		if clipboard == null or pSelection == null or pSelection.getX() == pSelection.getY()
			return
		end
		
		clipboard.setClipWith(getModel().getText().substring(pSelection.getX(), pSelection.getY()))
	end
	
	/**
	 * \brief Cut to clipboard requested.
	 * \version 1.11
	 */
	public func void onClipboardCut()
		var Clipboard clipboard = getClipboard()
		if clipboard == null or pSelection == null or pSelection.getX() == pSelection.getY()
			return
		end
		
		onClipboardCopy()
		deleteSelectedText()
	end
	
	/**
	 * \brief Paste from clipboard requested.
	 * \version 1.11
	 */
	public func void onClipboardPaste()
		var Clipboard clipboard = getClipboard()
		if clipboard == null or clipboard.isEmpty()
			return
		end
		
		var ClipboardClip clip = clipboard.getClip()
		if clip.getCount() == 0
			return
		end
		
		if clip.findCastable(block String data
			insertText(data)
			return true
		end) != null
			return
		end
		
		insertText(clip.getAt(0).toString())
	end
end
