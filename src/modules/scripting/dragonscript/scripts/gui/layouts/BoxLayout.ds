/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland PlÃ¼ss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Gui.Layouts

pin Dragengine.Gui.Borders


/**
 * \brief Arrange widgets in box formation along X or Y axis enlarging them evenly.
 * 
 * Instances of this layout can be shared by multiple widgets.
 */
class BoxLayout implements Layout
	private var LayoutAxis pAxis
	private var int pGap
	
	
	
	/**
	 * \brief Create layout with 0 gap.
	 */
	public func new( LayoutAxis axis )
		this.setAxis( axis )
		this.pGap = 0
	end
	
	/**
	 * \brief Create layout.
	 * \param gap Size of gap between child widgets. Can be negative to overlap widgets.
	 * \throws EInvalidParam axis is not LayoutAxis.x, LayoutAxis.y, LayoutAxis.inverseX or LayoutAxis.inverseY.
	 */
	public func new( LayoutAxis axis, int gap )
		this.setAxis( axis )
		this.setGap( gap )
	end
	
	
	
	/** \brief Gap between child widgets. */
	public func int getGap()
		return this.pGap
	end
	
	/**
	 * \brief Set gap between child widgets.
	 * \details Can be negative to overlap widgets.
	 */
	public func void setGap( int gap )
		this.pGap = gap
	end
	
	/** \brief Axis to arrange widgets along. */
	public func LayoutAxis getAxis()
		return this.pAxis
	end
	
	/** \brief Set axis to arrange along. */
	public func void setAxis( LayoutAxis axis )
		this.pAxis = axis
	end
	
	
	
	/**
	 * \brief Add widget to layout using settings.
	 * \param widget Widget to add to layout.
	 * \param settings Not used.
	 */
	public func void addWidget( Widget widget, Object settings )
	end
	
	/** \brief Remove widget from layout. */
	public func void removeWidget( Widget widget )
	end
	
	
	
	/** \brief Layout widgets in container. */
	public func void doLayout( Container container )
		var int count = container.getWidgetCount()
		
		// determine first the minimum size needed. this is the real minimum size not a
		// potentially artifial minimal size from container.getMinimumSize()
		var int width = container.getContainerWidth()
		var int height = container.getContainerHeight()
		var Point minSize = this.getMinimumSizeFor( container, width, height )
		
		// now determine how much additional space we have got
		// at our disposal to size child widgets beyond minimum
		var bool negate = ( this.pAxis == LayoutAxis.inverseX or this.pAxis == LayoutAxis.inverseY )
		var int cx = container.getPadding().getLeft()
		var int cy = container.getPadding().getTop()
		var int w, effSize, sizeGain
		var Point childSize
		var Widget child
		
		var BorderSize borderSize
		var int borderHeight
		var int borderWidth
		var int borderLeft
		var int borderTop
		
		select this.pAxis
		case LayoutAxis.x, LayoutAxis.inverseX
			var int availSpace = DEMath.max( container.getWidth() - minSize.getX(), 0 )
			if negate
				cx += width
			end
			
			for w = 0 to count
				child = container.getWidget( w )
				if not child.getVisible()
					continue
				end
				
				childSize = child.getMinimumSizeForHeight( height )
				
				if child.getBorder() == null
					borderLeft = 0
					borderTop = 0
					borderWidth = 0
					borderHeight = 0
					
				else
					borderSize = child.getBorder().getBorderSize()
					borderLeft = borderSize.getLeft()
					borderTop = borderSize.getTop()
					borderWidth = borderSize.getWidth()
					borderHeight = borderSize.getHeight()
				end
				sizeGain = availSpace / ( count - w )
				child.setSize( Point.new( childSize.getX() + sizeGain, height - borderHeight ) )
				availSpace -= sizeGain
				
				if negate
					cx -= childSize.getX() + sizeGain + borderWidth + this.pGap
					child.setPosition( Point.new( cx + borderLeft + this.pGap, cy + borderTop ) )
					
				else
					child.setPosition( Point.new( cx + borderLeft, cy + borderTop ) )
					cx += childSize.getX() + sizeGain + borderWidth + this.pGap
				end
			end
			
		else
			var int availSpace = DEMath.max( container.getHeight() - minSize.getY(), 0 )
			if negate
				cy += height
			end
			
			for w = 0 to count
				child = container.getWidget( w )
				if not child.getVisible()
					continue
				end
				
				childSize = child.getMinimumSizeForWidth( width )
				
				if child.getBorder() == null
					borderLeft = 0
					borderTop = 0
					borderHeight = 0
					borderWidth = 0
					
				else
					borderSize = child.getBorder().getBorderSize()
					borderLeft = borderSize.getLeft()
					borderTop = borderSize.getTop()
					borderWidth = borderSize.getWidth()
					borderHeight = borderSize.getHeight()
				end
				sizeGain = availSpace / ( count - w )
				child.setSize( Point.new( width - borderWidth, childSize.getY() + sizeGain ) )
				availSpace -= sizeGain
				
				if negate
					cy -= childSize.getY() + sizeGain + borderHeight + this.pGap
					child.setPosition( Point.new( cx + borderLeft, cy + borderTop + this.pGap ) )
					
				else
					child.setPosition( Point.new( cx + borderLeft, cy + borderTop ) )
					cy += childSize.getY() + sizeGain + borderHeight + this.pGap
				end
			end
		end
	end
	
	
	
	/** \brief Minimal size required for layout in container. */
	public func Point getMinimumSize( Container container )
		return this.getMinimumSizeFor( container, \
			container.getContainerWidth(), container.getContainerHeight() )
	end
	
	/** \brief Minimum size of layout using reference width and variable height. */
	public func Point getMinimumSizeForWidth( Container container, int width )
		return this.getMinimumSizeFor( container, \
			DEMath.max( 0, width - container.getPadding().getWidth() ), container.getContainerHeight() )
	end
	
	/** \brief Minimum size of layout using reference widget height and variable width. */
	public func Point getMinimumSizeForHeight( Container container, int height )
		return this.getMinimumSizeFor( container, \
			container.getContainerWidth(), DEMath.max( 0, height - container.getPadding().getHeight() ) )
	end
	
	
	
	/**
	 * \brief Minimum size of layout using reference and variable size.
	 * \details If LayoutAxis.x is used height is the reference size. If LayoutAxis.y is used
	 *          widthis the reference size.
	 */
	protected func Point getMinimumSizeFor( Container container, int width, int height )
		var int count = container.getWidgetCount()
		var bool usePadding = false
		var int w, cx = 0, cy = 0
		var Point childSize
		var Widget child
		
		select this.pAxis
		case LayoutAxis.x, LayoutAxis.inverseX
			if count > 0
				for w = 0 to count
					child = container.getWidget( w )
					if not child.getVisible()
						continue
					end
					
					childSize = child.getMinimumSizeWithBorderForHeight( height )
					cx += childSize.getX() + this.pGap
					if childSize.getY() > cy
						cy = childSize.getY()
					end
					usePadding = true
				end
				cx -= this.pGap // because we added one gap too much
			end
			
		else
			if count > 0
				for w = 0 to count
					child = container.getWidget( w )
					if not child.getVisible()
						continue
					end
					
					childSize = child.getMinimumSizeWithBorderForWidth( width )
					cy += childSize.getY() + this.pGap
					if childSize.getX() > cx
						cx = childSize.getX()
					end
					usePadding = true
				end
				cy -= this.pGap // because we added one gap too much
			end
		end
		
		var Point size = Point.new().largest( cx, cy )
		if usePadding
			size = size + container.getPadding().getSize()
		end
		return size
	end
end
