/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Borders
pin Dragengine.Gui.Events
pin Dragengine.Utils
pin Dragengine.Scenery


/**
 * \brief Text Field Widget.
 * 
 * Displays an edit field where the user can enter a short one line text.
 * 
 * Supports designing using designer selector "TextField".
 * 
 * \par Version 1.8
 * 
 * Supports adding ActionListener instances. If InputEventKey.enter is pressed or focus is
 * lost after typing in the widget action listeners are called.
 */
class TextField extends TextWidget
	/** \brief Use no password character constant */
	public fixed var int noPasswordChar = 0
	
	private var UTF8Navigator pCursorPos
	private var UTF8Navigator pFirstChar
	private var int pDispCharCount
	private var int pPasswordChar
	private var bool pNeedsUpdate
	
	
	
	/** \brief Create Text Field. */
	public func new() this(DefaultTextModel.new())
	end
	
	/** \brief Create Text Field. */
	public func new(String text) this(DefaultTextModel.new(text))
	end
	
	/** \brief Create Text Field. */
	public func new(TextModel model) this(model, false)
	end
	
	/** \brief Create Text Field. */
	public func new(TextModel model, bool readOnly) super(model, readOnly)
		pCursorPos = UTF8Navigator.new(model.getText())
		pFirstChar = UTF8Navigator.new(pCursorPos)
		pDispCharCount = 10
		pPasswordChar = noPasswordChar
		pNeedsUpdate = true
		
		setDesignerSelector("TextField")
		setCanFocus(true)
		setActionOnEnter(true)
		setAddTabToText(false)
		
		updateCanvasText()
	end
	
	/** \brief Create text field. */
	public func new(TextModel model, int displayCharCount) this(model)
		setDisplayCharCount(displayCharCount)
	end
	
	/** \brief Create text field. */
	public func new(TextModel model, int displayCharCount, bool readOnly) this(model, readOnly)
		setDisplayCharCount(displayCharCount)
	end
	
	
	
	/** \brief Current position of the cursor in bytes. */
	public func int getCursorPosition()
		return pCursorPos.getPosition()
	end
	
	/**
	 * \brief Set current cursor position in bytes.
	 * 
	 * If the cursor is outside the visible area the text is shifted to make the cursor visible
	 */
	public func void setCursorPosition(int position)
		if position < 0 or position > getText().getLength()
			throw EInvalidParam.new()
		end
		
		var int p = pCursorPos.getPosition()
		pCursorPos.setPosition(position)
		
		if pCursorPos.getPosition() == p
			return
		end
		
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Index in bytes of the first visible character. */
	public func int getFirstCharacter()
		return pFirstChar.getPosition()
	end
	
	/** \brief Count of characters the edit field has to be able to display. */
	public func int getDisplayCharCount()
		return pDispCharCount
	end
	
	/** \brief Set count of characters the edit field has to be able to display. */
	public func void setDisplayCharCount(int count)
		if count == pDispCharCount
			return
		end
		
		if count < 1
			throw EInvalidParam.new()
		end
		
		pDispCharCount = count
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Password character to obfuscate passwords. */
	public func int getPasswordChar()
		return pPasswordChar
	end
	
	/**
	 * \brief Set password character to obfuscate passwords.
	 * 
	 * use noPasswordChar to disable obfuscation of passwords.
	 */
	public func void setPasswordChar(int passwordChar)
		if passwordChar == pPasswordChar
			return
		end
		
		pPasswordChar = passwordChar
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	
	
	/** \brief Ensure cursor is visible by scrolling the text if necessary. */
	public func void ensureCursorVisible()
		var Font font = getFont()
		var int width = getWidth() - getPadding().getWidth()
		var float limit = (width - 2) cast float
		var float textLen = 0
		var String text
		var int i
		
		// check for password
		if pPasswordChar == noPasswordChar
			text = getText()
			
		else
			text = String.new(pPasswordChar cast byte, getText().getLength())
		end
		
		// check if the cursor is outside the left boundary
		if pCursorPos.getPosition() < pFirstChar.getPosition()
			pFirstChar.setFrom(pCursorPos)
			updateCanvasText()
			return
		end
		
		// check if the cursor is outside the right boundary
		var UTF8Navigator nav = UTF8Navigator.new(pCursorPos)
		while nav.getPosition() > pFirstChar.getPosition()
			nav.backward()
			textLen += font.getCharAdvance(nav.decodeCharacter())
			if textLen >= limit
				nav.forward()
				pFirstChar.setFrom(nav)
				updateCanvasText()
				break
			end
		end
		
		// check if there is still space to fill up on the right side
		nav = UTF8Navigator.new(pCursorPos)
		while not nav.isAtEnd()
			textLen += font.getCharAdvance(nav.decodeCharacter())
			if textLen >= limit
				break
			end
			nav.forward()
		end
		
		if textLen < limit
			var bool requiresUpdate
			
			while not pFirstChar.isAtStart()
				pFirstChar.backward()
				textLen += font.getCharAdvance(pFirstChar.decodeCharacter())
				if textLen >= limit
					pFirstChar.forward()
					break
				end
				requiresUpdate = true
			end
			
			if requiresUpdate
				updateCanvasText()
			end
		end
	end
	
	
	
	/** \brief Size changed. */
	public func void onResize(WidgetEvent event)
		super.onResize(event)
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Widget font changed. */
	public func void onSetFont()
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Foreground color changed. */
	public func void onSetTextColor()
		updateCanvasText()
	end
	
	/** \brief Widget received focus. */
	public func void onFocusReceived(FocusEvent event)
		super.onFocusReceived(event)
		updateCanvasText()
		popupVirtualKeyboard()
	end
	
	/** \brief Widget lost focus. */
	public func void onFocusLost(FocusEvent event)
		super.onFocusLost(event)
		updateCanvasText()
		popdownVirtualKeyboard()
	end
	
	
	
	/** \brief Minimal size of widget. */
	public func Point getMinimumSize()
		var Font font = getFont()
		if font == null
			return Point.new()
		end
		
		return Point.new((DEMath.ceil(font.getMaxWidth() * \
			(pDispCharCount cast float)) cast int) + getPadding().getWidth(), \
			font.getSize() + getPadding().getHeight())
	end
	
	
	
	/** \brief Key pressed event. */
	public func void onKeyPress(KeyEvent event)
		select event.getKeyCode()
		case InputEventKey.arrowLeft
			// move cursor left
			if not pCursorPos.isAtStart()
				pCursorPos.backward()
				pNeedsUpdate = true
				updateCanvasText()
			end
			
		case InputEventKey.arrowRight
			// move cursor right
			if not pCursorPos.isAtEnd()
				pCursorPos.forward()
				pNeedsUpdate = true
				updateCanvasText()
			end
			
		case InputEventKey.home
			// move to the beginning of the line
			pCursorPos.setPositionBegin()
			pNeedsUpdate = true
			updateCanvasText()
			
		case InputEventKey.last
			// move to the end of the line
			pCursorPos.setPositionEnd()
			pNeedsUpdate = true
			updateCanvasText()
			
		else
			super.onKeyPress(event)
		end
	end
	
	
	
	/**
	 * \brief Check cursor is inside the text boundaries and adjust it if necessary.
	 * \deprecated Using UTF8Navigator this call is not required anymore and is empty now.
	 */
	protected func void checkCursor()
	end
	
	
	
	/**
	 * \brief Key typed event.
	 " 
	 " Convenience method called if onKeyPress is called with an event containing a printable key.
	 */
	public func void onKeyType(KeyEvent event)
		var String curText, newText = ""
		
		select event.getKeyCode()
		case InputEventKey.backspace
			// delete character to the left of the cursor
			if not pCursorPos.isAtStart()
				curText = getText()
				
				var UTF8Navigator nav = pCursorPos - 1
				
				if not nav.isAtStart()
					newText = newText + curText.substring(0, nav.getPosition())
				end
				if not pCursorPos.isAtEnd()
					newText = newText + curText.substring(pCursorPos.getPosition())
				end
				
// 				if getValidator() == null or getValidator().validates(newText)
					pCursorPos = nav // for delete doing this before setText() is fine
					setHasTyped(true)
					setText(newText)
					updateCanvasText()
// 				end
			end
			
		case InputEventKey.delete
			// delete character to the right of the cursor
			if not pCursorPos.isAtEnd()
				curText = getText()
				
				var UTF8Navigator nav = pCursorPos + 1
				
				if not pCursorPos.isAtStart()
					newText = newText + curText.substring(0, pCursorPos.getPosition())
				end
				if not nav.isAtEnd()
					newText = newText + curText.substring(nav.getPosition())
				end
				
// 				if getValidator() == null or getValidator().validates(newText)
					setHasTyped(true)
					setText(newText)
// 				end
			end
			
		case InputEventKey.enter, InputEventKey.tab
			// ignore new-line, tab since this is a single line text field
			
		else
			var int character = event.getKeyChar()
			if character == 0
				break  // no printable character
			end
			
			if not getFont().hasGlyph(character) or getFont().getCharAdvance(character) <= 0.5
				break
			end
			
			curText = getText()
			Engine.log("type " + pCursorPos.getPosition())
			if not pCursorPos.isAtStart()
				newText = curText.substring(0, pCursorPos.getPosition())
			end
			
			newText = newText + UnicodeString.new(character).toUTF8()
			
			if not pCursorPos.isAtEnd()
				newText = newText + curText.substring(pCursorPos.getPosition())
			end
			
			if getValidator() == null or getValidator().validates(newText)
				setHasTyped(true)
				setText(newText)
				pCursorPos.forward() // has to come after setText()
				updateCanvasText()
			end
		end
	end
	
	/** \brief Padding changed. */
	public func void onPaddingChanged()
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Text model changed. */
	public func void onModelChanged()
		updateCanvasText()
	end
	
	/** \brief Model text changed. */
	public func void textChanged(TextModel textModel)
		var UTF8Navigator base = UTF8Navigator.new(textModel.getText())
		pCursorPos = base + pCursorPos.countCharacters()
		pFirstChar = base + pFirstChar.countCharacters()
		updateCanvasText()
	end
	
	/**
	 * \brief Read only state changed.
	 * \vrsion 1.7
	 */
	public func void onReadOnlyChanged()
		updateCanvasText()
	end
	
	
	
	/** \brief Update canvas text. */
	private func void updateCanvasText()
		var Font font = getFont()
		var Color color = getTextColor()
		if font == null or color == null
			getCanvasContent().removeAllCanvas()
			return
		end
		
		var CanvasView canvas = getCanvasContent()
		canvas.removeAllCanvas()
		
		var int width = getWidth() - 1 - getPadding().getWidth()
		var int height = getHeight() - 1 - getPadding().getHeight()
		var int charHeight = font.getSize()
		var int realHeight = charHeight //+ 3
		var String text
		
		// check for update
		if pNeedsUpdate
			pNeedsUpdate = false
			ensureCursorVisible()
		end
		
		// password check
		if pPasswordChar == noPasswordChar
			text = getText()
			
		else
			text = String.new(pPasswordChar cast byte, getText().getLength())
		end
		
		// center vertically
		var int x = 0
		var int y = (height - realHeight) / 2
		
		// text starting at given position
		if not text.empty()
			var String subString = text.substring(pFirstChar.getPosition())
			
			var CanvasText textCanvas = CanvasText.new()
			textCanvas.setFont(font)
			textCanvas.setColor(color)
			textCanvas.setText(subString)
			textCanvas.setPosition(Point.new(x + getPadding().getLeft(), y + getPadding().getTop()))
			textCanvas.setSize(font.getTextSize(subString))
			
			textCanvas.setOrder(canvas.getCanvasCount() cast float)
			canvas.addCanvas(textCanvas)
		end
		
		// caret
		if getHasFocus()
			var int cx = x + (measureAdvance(pFirstChar.getPosition(), pCursorPos.getPosition(), font) cast int)
			if cx >= 0 and cx <= width
				var CanvasPaint canvasCaret = CanvasPaint.new()
				canvasCaret.setShapeType(CanvasPaintShape.lines)
				canvasCaret.setFillColor(Color.transparent)
				canvasCaret.setLineColor(color /*Color.black*/)
				canvasCaret.setPosition(Point.new(cx + getPadding().getLeft(), y + getPadding().getTop()))
				canvasCaret.setSize(Point.new(1, charHeight))
				canvasCaret.setOrder(canvas.getCanvasCount() cast float)
				
				canvasCaret.addPoint(Point.new(0, 0))
				canvasCaret.addPoint(Point.new(0, charHeight + 1))
				
				canvas.addCanvas(canvasCaret)
			end
		end
	end
end
