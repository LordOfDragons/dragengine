/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Borders
pin Dragengine.Gui.Events
pin Dragengine.Utils
pin Dragengine.Scenery


/**
 * \brief Text Field Widget.
 * 
 * Displays an edit field where the user can enter a short one line text.
 * 
 * Supports designing using designer selector "TextField".
 */
class TextField extends TextWidget
	/** \brief Use no password character constant */
	public fixed var int noPasswordChar = 0
	
	private var int pCursorPos
	private var int pFirstChar
	private var int pDispCharCount
	private var int pPasswordChar
	private var bool pNeedsUpdate
	
	
	
	/** \brief Create Text Field. */
	public func new() this(DefaultTextModel.new())
	end
	
	/** \brief Create Text Field. */
	public func new(String text) this(DefaultTextModel.new(text))
	end
	
	/** \brief Create Text Field. */
	public func new(TextModel model) this(model, false)
	end
	
	/** \brief Create Text Field. */
	public func new(TextModel model, bool readOnly) super(model, readOnly)
		pCursorPos = 0
		pFirstChar = 0
		pDispCharCount = 10
		pPasswordChar = noPasswordChar
		pNeedsUpdate = true
		
		setDesignerSelector("TextField")
		setCanFocus(true)
		
		updateCanvasText()
	end
	
	/** \brief Create text field. */
	public func new(TextModel model, int displayCharCount) this(model)
		setDisplayCharCount(displayCharCount)
	end
	
	/** \brief Create text field. */
	public func new(TextModel model, int displayCharCount, bool readOnly) this(model, readOnly)
		setDisplayCharCount(displayCharCount)
	end
	
	
	
	/** \brief Current position of the cursor. */
	public func int getCursorPosition()
		return pCursorPos
	end
	
	/**
	 * \brief Set current cursor position.
	 * 
	 * If the cursor is outside the visible area the text is shifted to make the cursor visible
	 */
	public func void setCursorPosition(int position)
		if position < 0 or position > getModel().getText().getLength()
			throw EInvalidParam.new()
		end
		
		if position == pCursorPos
			return
		end
		
		pCursorPos = position
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Index of the first character visible. */
	public func int getFirstCharacter()
		return pFirstChar
	end
	
	/** \brief Count of characters the edit field has to be able to display. */
	public func int getDisplayCharCount()
		return pDispCharCount
	end
	
	/** \brief Set count of characters the edit field has to be able to display. */
	public func void setDisplayCharCount(int count)
		if count < 1
			throw EInvalidParam.new()
		end
		
		if count == pDispCharCount
			return
		end
		
		pDispCharCount = count
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Password character to obfuscate passwords. */
	public func int getPasswordChar()
		return pPasswordChar
	end
	
	/**
	 * \brief Set password character to obfuscate passwords.
	 * 
	 * use noPasswordChar to disable obfuscation of passwords.
	 */
	public func void setPasswordChar(int passwordChar)
		if passwordChar == pPasswordChar
			return
		end
		
		pPasswordChar = passwordChar
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	
	
	/** \brief Ensure cursor is visible by scrolling the text if necessary. */
	public func void ensureCursorVisible()
		var Font font = getFont()
		var int width = getWidth() - getPadding().getWidth()
		var float limit = (width - 2) cast float
		var float textLen = 0.0
		var String text
		var int i
		
		// check for password
		if pPasswordChar == noPasswordChar
			text = getModel().getText()
		else
			text = String.new(pPasswordChar cast byte, getModel().getText().getLength())
		end
		
		// check if the cursor is outside the left boundary
		if pCursorPos < pFirstChar
			pFirstChar = pCursorPos
			updateCanvasText()
		else
			// check if the cursor is outside the right boundary
			for i = pCursorPos - 1 downto pFirstChar
				textLen += font.getCharAdvance(text.getAt(i))
				if textLen >= limit
					pFirstChar = i + 1
					updateCanvasText()
					break
				end
			end
			
			// check if there is still space to fill up on the right side
			for i = pCursorPos to text.getLength()
				textLen += font.getCharAdvance(text.getAt(i))
				if textLen >= limit
					break
				end
			end
			
			if textLen < limit
				for i = pFirstChar - 1 downto 0
					textLen += font.getCharAdvance(text.getAt(i))
					if textLen >= limit
						break
					end
					pFirstChar = i
					updateCanvasText()
				end
			end
		end
	end
	
	
	
	/** \brief Size changed. */
	public func void onResize(WidgetEvent event)
		super.onResize(event)
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Widget font changed. */
	public func void onSetFont()
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Foreground color changed. */
	public func void onSetTextColor()
		updateCanvasText()
	end
	
	/** \brief Widget received focus. */
	public func void onFocusReceived(FocusEvent event)
		super.onFocusReceived(event)
		updateCanvasText()
		popupVirtualKeyboard()
	end
	
	/** \brief Widget lost focus. */
	public func void onFocusLost(FocusEvent event)
		super.onFocusLost(event)
		updateCanvasText()
		popdownVirtualKeyboard()
	end
	
	
	
	/** \brief Minimal size of widget. */
	public func Point getMinimumSize()
		var Font font = getFont()
		if font == null
			return Point.new()
		end
		
		return Point.new((DEMath.ceil(font.getMaxWidth() * \
			(pDispCharCount cast float)) cast int) + getPadding().getWidth(), \
			font.getSize() + getPadding().getHeight())
	end
	
	
	
	/** \brief Key pressed event. */
	public func void onKeyPress(KeyEvent event)
		select event.getKeyCode()
		case InputEventKey.arrowLeft
			// move cursor left
			if pCursorPos > 0
				pCursorPos--
				pNeedsUpdate = true
				updateCanvasText()
			end
			
		case InputEventKey.arrowRight
			// move cursor right
			if pCursorPos < getModel().getText().getLength()
				pCursorPos++
				pNeedsUpdate = true
				updateCanvasText()
			end
			
		case InputEventKey.home
			// move to the beginning of the line
			pCursorPos = 0
			pNeedsUpdate = true
			updateCanvasText()
			
		case InputEventKey.last
			// move to the end of the line
			pCursorPos = getModel().getText().getLength()
			pNeedsUpdate = true
			updateCanvasText()
			
		else
			super.onKeyPress(event)
		end
	end
	
	
	
	/** \brief Check cursor is inside the text boundaries and adjust it if necessary. */
	protected func void checkCursor()
		var String text = getModel().getText()
		var int textLen = text.getLength()
		
		pCursorPos = DEMath.clamp(pCursorPos, 0, textLen)
		pFirstChar = DEMath.clamp(pFirstChar, 0, textLen)
		
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	
	
	/**
	 * \brief Key typed event.
	 " 
	 " Convenience method called if onKeyPress is called with an event containing a printable key.
	 */
	public func void onKeyType(KeyEvent event)
		var String curText, newText = ""
		var Font font = getFont()
		var int textLen
		
		select event.getKeyCode()
		case InputEventKey.backspace
			// delete character to the left of the cursor
			if pCursorPos > 0
				curText = getModel().getText()
				textLen = curText.getLength()
				if pCursorPos - 1 > 0
					newText = newText + curText.substring(0, pCursorPos - 1)
				end
				if textLen - pCursorPos > 0
					newText = newText + curText.substring(pCursorPos)
				end
// 				if getValidator() == null or getValidator().validates(newText)
					pCursorPos--
					getModel().setText(newText)
					updateCanvasText()
// 				end
			end
		
		case InputEventKey.delete
			// delete character to the right of the cursor
			curText = getModel().getText()
			textLen = curText.getLength()
			
			if pCursorPos < textLen
				if pCursorPos > 0
					newText = newText + curText.substring(0, pCursorPos)
				end
				if textLen - pCursorPos > 1
					newText = newText + curText.substring(pCursorPos + 1)
				end
// 				if getValidator() == null or getValidator().validates(newText)
					getModel().setText(newText)
// 				end
			end
			
		case InputEventKey.enter, InputEventKey.tab
			// ignore new-line, tab since this is a single line text field
			
		else
			// TEMPORARY HACK UNTIL WIDGET CAN HANDLE UTF8
			if event.getKeyChar() > 127
				break
			end
			
			if event.getKeyChar() == 0
				break  // no printable character
			end
			
			// add character to the right of the cursor
			// 
			// WARNING
			// 
			// this fails if keyChar is larger than 127, for example non-latin characters.
			// the only safe solution is to convert TextModel from String to UnicodeString
			// 
			if font.getCharAdvance(event.getKeyChar()) <= 0.5
				break
			end
			
			curText = getModel().getText()
			textLen = curText.getLength()
			if pCursorPos > 0
				newText = newText + curText.substring(0, pCursorPos)
			end
			newText = newText + event.getKeyChar() cast byte
			if textLen - pCursorPos > 0
				newText = newText + curText.substring(pCursorPos)
			end
			if getValidator() == null or getValidator().validates(newText)
				pCursorPos++
				getModel().setText(newText)
				updateCanvasText()
			end
		end
	end
	
	/** \brief Padding changed. */
	public func void onPaddingChanged()
		pNeedsUpdate = true
		updateCanvasText()
	end
	
	/** \brief Text model changed. */
	public func void onModelChanged()
		updateCanvasText()
	end
	
	/** \brief Model text changed. */
	public func void textChanged(TextModel textModel)
		checkCursor()
		updateCanvasText()
	end
	
	/**
	 * \brief Read only state changed.
	 * \vrsion 1.7
	 */
	public func void onReadOnlyChanged()
		updateCanvasText()
	end
	
	
	
	/** \brief Update canvas text. */
	private func void updateCanvasText()
		var Font font = getFont()
		var Color color = getTextColor()
		if font == null or color == null
			getCanvasContent().removeAllCanvas()
			return
		end
		
		var CanvasView canvas = getCanvasContent()
		canvas.removeAllCanvas()
		
		var int width = getWidth() - 1 - getPadding().getWidth()
		var int height = getHeight() - 1 - getPadding().getHeight()
		var int charHeight = font.getSize()
		var int realHeight = charHeight //+ 3
		var String text
		
		// check for update
		if pNeedsUpdate
			ensureCursorVisible()
			pNeedsUpdate = false
		end
		
		// password check
		if pPasswordChar == noPasswordChar
			text = getModel().getText()
			
		else
			text = String.new(pPasswordChar cast byte, getModel().getText().getLength())
		end
		
		// center vertically
		var int x = 0
		var int y = (height - realHeight) / 2
		
		// text starting at given position
		if not text.empty()
			var String subString = text.substring(pFirstChar)
			
			// WARNING! right now the model text is not UTF8 anymore if characters are typed
			//          actually the entire widget has to be modified to properly handle utf8
			//          by updating pCursorPos with unicode character width (1-4) instead of
			//          ascii character wide (1). to handle this for the time being the text
			//          is considered ASCII-8 and being converted into UTF8 for the layout
			// Too many problems. >127 characters disabled altogether until the widget is fully reworked
			/*
			var UnicodeString usstring = UnicodeString.new()
			var int i, len = subString.getLength()
			for i = 0 to len
				usstring = usstring + subString.getAt(i)
			end
			subString = usstring.toUTF8()
			*/
			// END WARNING
			
			var CanvasText textCanvas = CanvasText.new()
			textCanvas.setFont(font)
			textCanvas.setColor(color)
			textCanvas.setText(subString)
			textCanvas.setPosition(Point.new(x + getPadding().getLeft(), y + getPadding().getTop()))
			textCanvas.setSize(font.getTextSize(subString))
			
			textCanvas.setOrder(canvas.getCanvasCount() cast float)
			canvas.addCanvas(textCanvas)
		end
		
		// caret
		if getHasFocus()
			var float fcx = x cast float
			var int i
			
			for i = pFirstChar to pCursorPos
				fcx += font.getCharAdvance(text.getAt(i))
			end
			
			var int cx = fcx cast int
			
			if cx >= 0 and cx <= width
				var CanvasPaint canvasCaret = CanvasPaint.new()
				canvasCaret.setShapeType(CanvasPaintShape.lines)
				canvasCaret.setFillColor(Color.transparent)
				canvasCaret.setLineColor(color /*Color.black*/)
				canvasCaret.setPosition(Point.new(cx + getPadding().getLeft(), y + getPadding().getTop()))
				canvasCaret.setSize(Point.new(1, charHeight))
				canvasCaret.setOrder(canvas.getCanvasCount() cast float)
				
				canvasCaret.addPoint(Point.new(0, 0))
				canvasCaret.addPoint(Point.new(0, charHeight + 1))
				
				canvas.addCanvas(canvasCaret)
			end
		end
	end
end
