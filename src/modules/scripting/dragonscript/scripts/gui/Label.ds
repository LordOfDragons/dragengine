/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.Gui

pin Dragengine.Gui.Events
pin Dragengine.Scenery
pin Dragengine.Utils


/**
 * \brief Render a short aligned text.
 */
class Label extends Widget implements TextModelListener
	/** \brief Align text left side. */
	public fixed var int left = 0
	
	/** \brief Align text right side. */
	public fixed var int right = 1
	
	/** \brief Align text center. */
	public fixed var int center = 2
	
	/** \brief Align text at top side. */
	public fixed var int top = 0
	
	/** \brief Align text at bottom side. */
	public fixed var int bottom = 4
	
	/** \brief Align text middled. */
	public fixed var int middle = 8
	
	/** \brief Align text top-left. */
	public fixed var int topLeft = top | left
	
	/** \brief Align text middle-center. */
	public fixed var int topCenter = top | center
	
	/** \brief Align text top-right. */
	public fixed var int topRight = top | right
	
	/** \brief Align text middle-left. */
	public fixed var int middleLeft = middle | left
	
	/** \brief Align text middle-center. */
	public fixed var int middleCenter = middle | center
	
	/** \brief Align text middle-right. */
	public fixed var int middleRight = middle | right
	
	/** \brief Align text bottom-left. */
	public fixed var int bottomLeft = bottom | left
	
	/** \brief Align text middle-center. */
	public fixed var int bottomCenter = bottom | center
	
	/** \brief Align text bottom-right. */
	public fixed var int bottomRight = bottom | right
	
	/** \brief Default alignment middle-center. */
	public fixed var int defaultAlignment = middleCenter
	
	
	
	/** \brief Text Layout. */
	private var TextLayout pTextLayout
	
	/** \brief Text Model. */
	private var TextModel pModel
	
	/** \brief Text alignment. */
	private var int pAlignment
	
	/** \brief Maximal width of text before break occurs. */
	private var int pMaxWidth
	
	/** \brief Minimum Size of the text with max width applied. */
	private var Point pMinTextSize
	
	/** \brief Word wrap if line is too long. */
	private var bool pWordWrap
	
	/** \brief Cached minimum size for getMinimumSizeForWidth or \em null to calculate next time. */
	private var Point pMinSizeForWidthSize
	
	/** \brief Width used for cached minimum size for getMinimumSizeForWidth if set. */
	private var int pMinSizeForWidthWidth
	
	
	
	/** \brief Create label. */
	public func new(String text) this(DefaultTextModel.new(text), defaultAlignment)
	end
	
	public func new(String text, int alignment) this(DefaultTextModel.new(text), alignment)
	end
	
	public func new(TextModel model) this(model, defaultAlignment)
	end
	
	public func new(TextModel model, int alignment)
		if model == null
			throw EInvalidParam.new()
		end
		if (alignment & right == right and alignment & center == center) \
		or (alignment & bottom == bottom and alignment & middle == middle)
			throw EInvalidParam.new()
		end
		
		pModel = model
		pModel.addListener(this)
		pAlignment = alignment
		pMaxWidth = 0
		pWordWrap = false
		pMinSizeForWidthWidth = 0
		setDesignerSelector("Label")
		
		//updateCanvasText() // there is no font yet so this is a waste of time
	end
	
	public func new(String text, String designerSelector) this(text)
		setDesignerSelector(designerSelector)
	end
	
	public func new(TextModel model, String designerSelector) this(model)
		setDesignerSelector(designerSelector)
	end
	
	/** \brief Dispose of widget. */
	public func void dispose()
		pModel.removeListener(this)
		pModel = null
		
		super.dispose()
	end
	
	
	
	/** \brief Text model. */
	public func TextModel getModel()
		return pModel
	end
	
	/** \brief Set text model. */
	public func void setModel(TextModel model)
		if model == null
			throw EInvalidParam.new()
		end
		
		if model == pModel
			return
		end
		
		pModel.removeListener(this)
		pModel = model
		model.addListener(this)
		
		updateCanvasText()
		layoutParent()
	end
	
	/** \brief Text. */
	public func String getText()
		return pModel.getText()
	end
	
	/** \brief Set text. */
	public func void setText(String text)
		pModel.setText(text)
	end
	
	/** \brief Text alignment. */
	public func int getAlignment()
		return pAlignment
	end
	
	/**
	 * \brief Set text alignment.
	 * \param alignment One of left, right, center combined with one of top, bottom, middle.
	 */
	public func void setAlignment(int alignment)
		if (alignment & right == right and alignment & center == center) \
		or (alignment & bottom == bottom and alignment & middle == middle)
			throw EInvalidParam.new()
		end
		
		if alignment == pAlignment
			return
		end
		
		pAlignment = alignment
		updateCanvasText()
		layoutParent()
	end
	
	/** \brief Maximal width of text before break occurs. */
	public func int getMaximalWidth()
		return pMaxWidth
	end
	
	/** \brief Set maximal width of text before break occurs. */
	public func void setMaximalWidth(int width)
		if width < 0
			throw EInvalidParam.new()
		end
		
		if width == pMaxWidth
			return
		end
		
		pMaxWidth = width
		updateCanvasText()
		layoutParent()
	end
	
	/** \brief Word wrap if line is too long. */
	public func bool getWordWrap()
		return pWordWrap
	end
	
	/** \brief Set word wrap if line is too long. */
	public func void setWordWrap(bool wordWrap)
		if wordWrap == pWordWrap
			return
		end
		
		pWordWrap = wordWrap
		
		updateCanvasText()
		layoutParent()
	end
	
	
	
	/** \brief Size of text. */
	public func Point getTextSize()
		var BorderSize padding = getPadding()
		return Point.new(\
			pTextLayout.getWidth() + padding.getWidth(), \
			pTextLayout.getHeight() + padding.getHeight())
	end
	
	
	
	/** \brief Minimal size of widget. */
	public func Point getMinimumSize()
		if isMinimumSizeSet()
			return super.getMinimumSize()
		end
		return minTextSize()
	end
	
	
	
	/**
	 * \brief Minimum size of widget using reference widget width and variable height.
	 * \details Default implementation uses getMinimumSize().
	 */
	public func Point getMinimumSizeForWidth(int width)
		if isMinimumSizeSet()
			return super.getMinimumSize()
		end
		
		if pMinSizeForWidthSize != null and width == pMinSizeForWidthWidth
			return pMinSizeForWidthSize
		end
		
		var Font font = getFont()
		if font == null
			pMinSizeForWidthSize = null
			return Point.new()
		end
		
		// NOTE a possible optimization is the following. if getMinimumSize().getX()
		//      is less then width then using getMinimumSize() is good enough since
		//      the size never can be larger. uses the optimized minimum version as
		//      long as the width is not smaller potentially forcing different height.
		var TextLayout textLayout = TextLayout.new(pModel.getText(), font)
		var BorderSize padding = getPadding()
		var int maxWidth = pMaxWidth
		
		if pWordWrap
			maxWidth = width - padding.getWidth()
			if pMaxWidth > 0
				maxWidth = DEMath.min(maxWidth, pMaxWidth)
			end
		end
		textLayout.setMaximalWidth(DEMath.max(maxWidth, 0))
		
		textLayout.layoutText()
		
		pMinSizeForWidthSize = Point.new(\
			textLayout.getWidth() + padding.getWidth(), \
			textLayout.getHeight() + padding.getHeight())
		pMinSizeForWidthWidth = width
		
		return pMinSizeForWidthSize
	end
	
	
	
	/** \brief Font changed. */
	public func void onSetFont()
		updateCanvasText()
		layoutParent()
	end
	
	/** \brief Foreground color changed. */
	public func void onSetTextColor()
		updateCanvasText()
	end
	
	/** \brief Size changed. */
	public func void onResize(WidgetEvent event)
		super.onResize(event)
		updateCanvasText()
	end
	
	/** \brief Gui theme changed. */
	public func void onGuiThemeChanged()
		super.onGuiThemeChanged()
		
		updateCanvasText()
		layoutParent()
	end
	
	/**
	 * \brief State changed.
	 * \details Sends event to listeners.
	 */
	public func void onStateChanged(StateChangeEvent event)
		super.onStateChanged(event)
		updateCanvasText()
	end
	
	
	
	/** \brief Text size for the given text width. */
	private func Point minTextSize()
		if pMinTextSize != null
			return pMinTextSize
		end
		
		if pTextLayout == null
			if getFont() == null
				return Point.new()
			end
			updateTextLayout()
		end
		
		var TextLayout textLayout = TextLayout.new(pTextLayout, pMaxWidth)
		textLayout.layoutText()
		
		var BorderSize padding = getPadding()
		pMinTextSize = Point.new(\
			textLayout.getWidth() + padding.getWidth(), \
			textLayout.getHeight() + padding.getHeight())
		
		return pMinTextSize
	end
	
	
	
	/** \brief Update canvas. */
	private func void updateCanvasText()
		if getFont() == null
			getCanvasContent().removeAllCanvas()
			return
		end
		
		updateTextLayout()
		
		var BorderSize padding = getPadding()
		var int width = getWidth() - 1 - padding.getWidth()
		var int height = getHeight() - 1 - padding.getHeight()
		var int x = 0
		var int y = 0
		
		if getTextColor() != null
			pTextLayout.setColor(getTextColor())
		end
		
		if pAlignment & right == right
			x = width - pTextLayout.getWidth()
			
		elif pAlignment & center == center
			x = (width - pTextLayout.getWidth()) / 2
		end
		
		if pAlignment & bottom == bottom
			y = height - pTextLayout.getHeight()
			
		elif pAlignment & middle == middle
			y = (height - pTextLayout.getHeight()) / 2
		end
		
		var CanvasView canvas = getCanvasContent()
		canvas.removeAllCanvas()
		pTextLayout.addToCanvas(canvas, padding.getLeft() + x, padding.getTop() + y)
	end
	
	/** \brief Update text layout. */
	private func void updateTextLayout()
		pTextLayout = TextLayout.new(pModel.getText(), getFont())
		
		if pWordWrap
			pTextLayout.setMaximalWidth(DEMath.max(\
				getWidth() - getPadding().getWidth(), 0))
		end
		
		pTextLayout.setAlignment(TextLayout.Align.center)
		
		if pAlignment & right == right
			pTextLayout.setAlignment(TextLayout.Align.right)
			
		elif pAlignment & center == center
			pTextLayout.setAlignment(TextLayout.Align.center)
			
		else
			pTextLayout.setAlignment(TextLayout.Align.left)
		end
		
		pTextLayout.layoutText()
		
		pMinTextSize = null
		pMinSizeForWidthSize = null
	end
	
	
	
	/** \brief Text changed. */
	public func void textChanged(TextModel textModel)
		updateCanvasText()
		layoutParent()
	end
end
