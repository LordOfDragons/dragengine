/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Dragengine.Gui

pin Dragengine.Gui.Borders
pin Dragengine.Gui.Events
pin Dragengine.Gui.Layouts
pin Dragengine.Gui.Listeners
pin Dragengine.Scenery
pin Dragengine.Utils


/**
 * \brief Drop down list displaying the currently selected element.
 * 
 * Supports designing using designer selector "ComboBox". The drop-down list box supports
 * desining using designer selector "ListBox.ComboBox".
 */
class ComboBox extends Container implements ListModelListener
	/** \deprecated Editor focus lost listener. */
	class EditorFocusLost extends DefaultFocusListener
		private var ComboBox pComboBox
		
		public func new(ComboBox comboBox)
			pComboBox = comboBox
		end
		
		public func void onFocusReceived(FocusEvent event)
			pComboBox.onFocusReceived(event)
		end
		
		public func void onFocusLost(FocusEvent event)
			pComboBox.onFocusLost(event)
		end
	end
	
	/** \brief Editor value changed listener. */
	class EditorValueChanged extends DefaultActionListener
		private var ComboBox pComboBox
		
		public func new(ComboBox comboBox)
			pComboBox = comboBox
		end
		
		public func void onAction(ActionEvent event)
			pComboBox.setSelectedFromEditorValue()
			pComboBox.updateSelectedWidget()
		end
	end
	
	/** \brief Roll up mouse listener. */
	class RollUpMouseListener extends DefaultMouseListener
		private var ComboBox pComboBox
		private var bool pPressed
		
		public func new(ComboBox comboBox)
			pComboBox = comboBox
			pPressed = false
		end
		
		public func void onButtonPress(MouseEvent event)
			if event.getButton() == InputEventMouseButton.left
				pPressed = true
			end
		end
		
		public func void onButtonRelease(MouseEvent event)
			if event.getButton() == InputEventMouseButton.left and pPressed
				pComboBox.rollUp()
			end
		end
	end
	
	/** \deprecated Popup widget listener. */
	class PopupWidgetListener extends DefaultWidgetListener
		private var ComboBox pComboBox
		
		public func new(ComboBox comboBox)
			pComboBox = comboBox
		end
		
		public func void onWidgetHidden(WidgetEvent event)
			pComboBox.rollUp()
		end
	end
	
	/**
	 * \brief Popup window.
	 * \version 1.17
	 */
	class ComboPopup extends WindowPopup
		private var ComboBox pComboBox
		private var ListBox pListBox
		
		public func new(ComboBox comboBox)
			pComboBox = comboBox
			setCloseOnPopDown(false)
		end
		
		public func void dispose()
			if pListBox != null
				// disposing of pListBox removes listeners but only if model has been created
				// by pListBox. hence we need to remove combox from listener here but only if
				// model still exists. this catches the situation of the listbox being disposed
				// early. this should actually not be possible but better safe than sorry
				var ListModel model = pListBox.getModel()
				if model != null
					model.removeListener(pComboBox)
				end
				pListBox = null
			end
			
			super.dispose()
			
			pComboBox = null
		end
		
		public func void setListBox(ListBox listBox)
			pListBox = listBox
		end
		
		public func bool requiresPopdown(MouseEvent event)
			if not super.requiresPopdown(event)
				return false
			end
			if pComboBox.getEditor() == null
				return true
			end
			
			var Widget source = event.getSource() cast Widget
			var Point desktopPosition = source.getDesktopPosition() + event.getPosition()
			var Point comboBoxPosition = desktopPosition - pComboBox.getDesktopPosition()
			if not pComboBox.isPointInside(comboBoxPosition)
				return true
			end
			
			var Widget dropDownButton = pComboBox.getButtonDropDownWidget()
			if dropDownButton == null
				return true
			end
			
			return dropDownButton.isPointInside(comboBoxPosition - dropDownButton.getPosition())
		end
		
		public func void popdown()
			super.popdown()
			pComboBox.rollUp()
			pComboBox.onStateChanged(StateChangeEvent.new(this, StateChangeEvent.idStateChanged))
		end
		
		public func void sendEvent(Event event)
			if event.getSource() != this
				return
			end
			
			var int id = event.getIdentifier()
			var Desktop desktop = getDesktop()
			var Point desktopPosition
			
			if MouseEvent.isMouseEvent(id)
				desktopPosition = getDesktopPosition() + (event cast MouseEvent).getPosition()
				
			else
				desktopPosition = desktop.getMouseLocation()
			end
			
			var Widget target = desktop.widgetAcceptingInputAt(desktopPosition)
			if target == null or not target.hasParent(pComboBox)
				super.sendEvent(event)
				return
			end
			
			if MouseEvent.isMouseEvent(id)
				var MouseEvent mouseEvent = event cast MouseEvent
				var Point mousePosition
				
				if id == MouseEvent.idMouseWheeled
					mousePosition = mouseEvent.getPosition()
					
				else
					mousePosition = desktopPosition - target.getDesktopPosition()
				end
				
				target.sendEvent(MouseEvent.new(target, id, mouseEvent.getButton(),\
					mouseEvent.getModifiers(), mousePosition, mouseEvent.getSystem(),\
					mouseEvent.getDevice()))
				
			elif KeyEvent.isKeyEvent(id)
				var KeyEvent keyEvent = event cast KeyEvent
				target.sendEvent(KeyEvent.new(target, id, keyEvent.getKeyCode(), \
					keyEvent.getModifiers(), keyEvent.getKeyChar(), \
					keyEvent.getSystem(), keyEvent.getDevice() , keyEvent.getButtonCode()))
				
			elif GamepadEvent.isGamepadEvent(id)
				var GamepadEvent gevent = event cast GamepadEvent
				target.sendEvent(GamepadEvent.new(target, id, gevent.getSystem(),\
					gevent.getDevice(), gevent.getCode(), gevent.getModifiers(), gevent.getAxisValue()))
				
			else
				target.sendEvent(event)
			end
		end
	end
	
	
	
	private var ComboPopup pDropDown
	private var ListBox pListBox
	private var Widget pWidgetButtonDropDown
	private var Container pWidgetButtonDropDownContainer
	private var Panel pPanelSelectedElement
	private var Widget pSelectedElement
	private var Panel pSpacer
	private var ComboBoxEditor pEditor
	private var EditorFocusLost pEditorFocusLost
	private var EditorValueChanged pEditorValueChanged
	private var Point pDefaultElementSize
	private var bool pSelFromEditorOnDropDown
	private var bool pDropDownRequiresSelFromEditor
// 	private var bool pFirstDropDown
	
	
	
	/** \brief Create combo box widget. */
	public func new() this(DefaultListModel.new(), DefaultListElementRenderer.new())
	end
	
	/** \brief Create combo box widget. */
	public func new(ListModel model) this(model, DefaultListElementRenderer.new())
	end
	
	/** \brief Create combo box widget. */
	public func new(ListModel model, ListElementRenderer renderer)
		setCanFocus(true) // this is not working correctly. needs fixing
		
		pSelFromEditorOnDropDown = true
// 		pFirstDropDown = true
		
		pDefaultElementSize = Point.new(1, 1)
		
		pEditorFocusLost = EditorFocusLost.new(this)
		pEditorValueChanged = EditorValueChanged.new(this)
		
		pListBox = ListBox.new(model, renderer)
		pListBox.setNumberDisplayLines(8)
		pListBox.setBorder(BevelBorder.new())
		pListBox.addMouseListener(RollUpMouseListener.new(this))
		pListBox.setDesignerSelector(pListBox.getDesignerSelector() + ".ComboBox")
		
		pDropDown = ComboPopup.new(this)
		pDropDown.addWidget(ScrollPanel.new(pListBox))
		pDropDown.setListBox(pListBox)
		
		pSpacer = Panel.new()
		pSpacer.setMinimumSize(Point.new(50, 0))
		pSpacer.setProtectMinimumSize(true)
		pDropDown.addWidget(pSpacer, BorderLayout.Area.bottom)
		
		setDesignerSelector("ComboBox")
		setLayout(BorderLayout.new())
		
		pPanelSelectedElement = Panel.new(StackLayout.new())
		addWidget(pPanelSelectedElement, BorderLayout.Area.content)
		
		updateSelectedWidget()
		
		model.addListener(this)
	end
	
	/** \brief Create combo box widget. */
	public func new(ListModel model, ComboBoxEditor editor) this(model, DefaultListElementRenderer.new())
		setEditor(editor)
	end
	
	/** \brief Create combo box widget. */
	public func new(ListModel model, ListElementRenderer renderer, ComboBoxEditor editor) this(model, renderer)
		setEditor(editor)
	end
	
	/** \brief Dispose of widget. */
	public func void dispose()
		if pEditor != null
			if pEditorFocusLost != null
				pEditor.getWidget().removeFocusListener(pEditorFocusLost)
			end
			if pEditorValueChanged != null
				pEditor.removeActionListener(pEditorValueChanged)
			end
		end
		pEditor = null
		pEditorFocusLost = null
		pEditorValueChanged = null
		
		pSpacer = null
		pSelectedElement = null
		pPanelSelectedElement = null
		pWidgetButtonDropDown = null
		pWidgetButtonDropDownContainer = null
		
		if pDropDown != null
			pDropDown.close()
			pDropDown = null
		end
		
		pListBox = null
		
		super.dispose()
	end
	
	
	
	/** \brief List model. */
	public func ListModel getModel()
		return pListBox.getModel()
	end
	
	/** \brief Set list model. */
	public func void setModel(ListModel model)
		if model == null
			throw ENullPointer.new("model")
		end
		
		pListBox.getModel().removeListener(this)
		pListBox.setModel(model)
		model.addListener(this)
	end
	
	/** \brief List element renderer. */
	public func ListElementRenderer getElementRenderer()
		return pListBox.getElementRenderer()
	end
	
	/** \brief Set list element renderer. */
	public func void setElementRenderer(ListElementRenderer renderer)
		if renderer == pListBox.getElementRenderer()
			return
		end
		
		if pSelectedElement != null
			pSelectedElement.safeDispose()
			pSelectedElement = null
		end
		
		pListBox.setElementRenderer(renderer)
		
		updateDefaultElementSize()
	end
	
	/** \brief Number of lines to display in the drop down list box. */
	public func int getNumberDisplayLines()
		return pListBox.getNumberDisplayLines()
	end
	
	/** \brief Set number of lines to display in the drop down list box. */
	public func void setNumberDisplayLines(int lines)
		pListBox.setNumberDisplayLines(lines)
	end
	
	/** \brief Combo box editor if editable or \em null if not editable. */
	public func ComboBoxEditor getEditor()
		return pEditor
	end
	
	/** \brief Set combo box editor if editable or \em null if not editable. */
	public func void setEditor(ComboBoxEditor editor)
		if editor == pEditor
			return
		end
		
		if pEditor != null
			pPanelSelectedElement.removeWidget(pEditor.getWidget())
			pEditor.getWidget().removeFocusListener(pEditorFocusLost)
			pEditor.removeActionListener(pEditorValueChanged)
		end
		
		pEditor = editor
		
		if editor != null
			var Widget widget = editor.getWidget()
			pPanelSelectedElement.addWidget(widget)
			editor.addActionListener(pEditorValueChanged)
			widget.addFocusListener(pEditorFocusLost)
			widget.setVisible(false)
		end
		
		setEditorValueFromSelection()
		updateSelectedWidget()
		// does implicitely updateSelectedVisibility()
		
		updateDefaultElementSize()
		if pSelectedElement != null
			pSelectedElement.setMinimumSize(getDefaultElementSize())
		end
	end
	
	
	
	/** \brief Index of the selected item or -1 if none is selected. */
	public func int getSelectedElement()
		return pListBox.getSelectedElement()
	end
	
	/** \brief Set index of the selected item or -1 if none is selected. */
	public func void setSelectedElement(int index)
		pListBox.setSelectedElement(index)
	end
	
	
	
	/** \brief Drop down list visible. */
	public func bool droppedDown()
		return pDropDown.getVisible()
	end
	
	/** \brief Drop down the list box if not already dropped down. */
	public func void dropDown()
		if pDropDown.getVisible()
			return
		end
		
		var Desktop desktop = pDropDown.getDesktop()
		
		if desktop == null
			desktop = getDesktop()
			if desktop == null
				return
			end
			desktop.addWindow(pDropDown)
		end
		
// 		pFirstDropDown = false
		
		pDropDown.popupInside(\
			getDesktopPosition() + Point.new(0, getHeight()), \
			RectArea.new(Point.new(), desktop.getSize()))
		pListBox.makeSelectedElementVisible()
		
		onStateChanged(StateChangeEvent.new(this, StateChangeEvent.idStateChanged))
		
		if pDropDownRequiresSelFromEditor
			pDropDownRequiresSelFromEditor = false
			setSelectedFromEditorValue() // has to be done once drop down is visible
		end
		
		if pEditor != null
			if not pEditor.getWidget().getVisible()
				pEditor.startEditing()
			end
			
		else
			grabFocus()
		end
	end
	
	/** \brief Roll up the list box if dropped down. */
	public func void rollUp()
		if not pDropDown.getVisible()
			return
		end
		
		pDropDown.popdown()
	end
	
	/** \brief Toggle between dropped down and rolled up state. */
	public func void toggleDropDown()
		if pDropDown.getVisible()
			rollUp()
			
		else
			dropDown()
		end
	end
	
	/** \brief Start editing if an editor is set. */
	public func void startEditing()
		if pEditor == null
			return
		end
		
		if pSelectedElement != null
			pSelectedElement.setVisible(false)
		end
		
		pEditor.getWidget().setVisible(true)
		pEditor.startEditing()
	end
	
	/**
	 * \brief Set selected from editor value on drop down.
	 * \version 1.7
	 * 
	 * If true delays sets selected from editor value until drop down. If false sets selected
	 * from editor immediately. This can be slow down UI if the list has many elements.
	 * 
	 * Default value is true.
	 */
	public func bool getSelectFromEditorOnDropDown()
		return pSelFromEditorOnDropDown
	end
	
	/**
	 * \brief Set selected from editor value on drop down.
	 * \version 1.7
	 * 
	 * If true delays sets selected from editor value until drop down. If false sets selected
	 * from editor immediately. This can be slow down UI if the list has many elements.
	 * 
	 * Default value is true.
	 */
	public func void setSelectFromEditorOnDropDown(bool selectedFromEditorOnDropDown)
		pSelFromEditorOnDropDown = selectedFromEditorOnDropDown
		pDropDownRequiresSelFromEditor = true
	end
	
	/**
	 * \brief Select from editor value is required during next drop down.
	 * \version 1.7
	 */
	protected func bool getDropDownRequiresSelectFromEditor()
		return pDropDownRequiresSelFromEditor
	end
	
	/**
	 * \brief Set select from editor value is required during next drop down.
	 * \version 1.7
	 */
	protected func void setDropDownRequiresSelectFromEditor(bool requiresSelectFromEditor)
		pDropDownRequiresSelFromEditor = requiresSelectFromEditor
	end
	
	
	
	/**
	 * \brief Grab focus if possible.
	 * 
	 * If an editor is set grabs focus of edit widget instead.
	 */
	public func void grabFocus()
		if pEditor != null
			if pEditor.getWidget().getVisible()
				pEditor.getWidget().grabFocus()
				
			else
				startEditing()
			end
			
		else
			super.grabFocus()
		end
	end
	
	
	
	/**
	 * \brief Drop down button widget or \em null if not set.
	 * \details For use by button designers.
	 */
	public func Widget getButtonDropDownWidget()
		return pWidgetButtonDropDown
	end
	
	/**
	 * \brief Set drop down button widget or \em null if not set.
	 * \details For use by button designers.
	 */
	public func void setDropDownButtonWidget(Widget widget)
		if widget == pWidgetButtonDropDown
			return
		end
		
		if pWidgetButtonDropDown != null
			pWidgetButtonDropDown.safeDispose()
		end
		
		pWidgetButtonDropDown = widget
		
		if widget castable Container
			pWidgetButtonDropDownContainer = widget cast Container
			
		else
			pWidgetButtonDropDownContainer = null
		end
		
		if widget != null
			addWidget(widget, BorderLayout.Area.right)
		end
	end
	
	
	
	/** \brief Size changed. */
	public func void onResize(WidgetEvent event)
		super.onResize(event)
		pSpacer.setMinimumSize(Point.new(getWidth(), 0))
	end
	
	/** \brief Mouse button pressed. */
	public func void onButtonPress(MouseEvent event)
		var Widget source = event.getSource() cast Widget
		
		if source == this
			grabFocus()
		end
		
		if event.getButton() == InputEventMouseButton.left
			if pEditor != null
				if pEditor.getWidget().getVisible()
					if source == pWidgetButtonDropDown\
					or (pWidgetButtonDropDownContainer != null and source.hasParent(pWidgetButtonDropDownContainer))
						toggleDropDown()
						
// 					elif pFirstDropDown
					else
						dropDown()
					end
					
				else
					dropDown()
					startEditing()
				end
				
			else
				toggleDropDown()
				startEditing()
			end
		end
		
		sendEventToListeners(event, true)
// 		super.onButtonPress(event)
	end
	
	/** Mouse wheeled. */
	public func void onMouseWheel(MouseEvent event)
		var int y = event.getPosition().getY()
		if y == 0
			return
		end
		
		var int selection = pListBox.getSelectedElement()
		var int count = pListBox.getModel().getCount()
		var int newSelection = selection
		
		if selection == -1 and count > 0
			newSelection = 0
			
		else
			newSelection = DEMath.clamp(selection - y, 0, count - 1)
		end
		
		if newSelection != selection
			pListBox.setSelectedElement(newSelection)
		end
		
		super.onMouseWheel(event)
	end
	
	/** \brief Key pressed. */
	public func void onKeyPress(KeyEvent event)
		super.onKeyPress(event)
		
		select event.getKeyCode()
		case InputEventKey.arrowDown
			onArrowDown()
			
		case InputEventKey.arrowUp
			onArrowUp()
			
		case InputEventKey.pageUp
			onPageUp()
			
		case InputEventKey.pageDown
			onPageDown()
			
		case InputEventKey.space
			if pEditor == null
				toggleDropDown()
			end
			
		case InputEventKey.enter
			rollUp()
		end
	end
	
	/** \brief Widget received focus. */
	public func void onFocusReceived(FocusEvent event)
		super.onFocusReceived(event)
		
// 		pFirstDropDown = true
		updateSelectedWidget()
		startEditing()
	end
	
	/** \brief Widget lost focus. */
	public func void onFocusLost(FocusEvent event)
		super.onFocusLost(event)
		
		updateSelectedWidget()
		rollUp()
// 		pFirstDropDown = false
	end
	
	/**
	 * \brief Request to release mouse capture.
	 * 
	 * Capture mouse to popup window if visible. Required if editor widget captures mouse.
	 */
	public func bool requestReleaseMouse(Widget widget)
		if not super.requestReleaseMouse(widget)
			return false
		end
		
		if pDropDown.getVisible()
			pDropDown.captureMouse()
		end
		
		return true
	end
	
	/**
	 * \brief Gui theme changed.
	 * \details Called if setGuiTheme is used or parent changed.
	 * \warning You have to super-call this method since it is used a bit differently than the other callback methods.
	 */
	public func void onGuiThemeChanged()
		super.onGuiThemeChanged()
		pDropDown.setGuiTheme(getGuiTheme())
		
		updateDefaultElementSize()
		if pSelectedElement != null
			pSelectedElement.setMinimumSize(getDefaultElementSize())
		end
	end
	
	
	
	/** \brief Elements have been added. */
	public func void elementsAdded(ListModel listModel, int fromIndex, int toIndex)
		setSelectedFromEditorValue()
	end
	
	/** \brief Elements have been removed. */
	public func void elementsRemoved(ListModel listModel, int fromIndex, int toIndex)
	end
	
	/** \brief Content of the model changed. */
	public func void contentChanged(ListModel listModel, int fromIndex, int toIndex)
		var int selection = listModel.getSelected()
		if selection >= fromIndex and selection <= toIndex
			selectionChanged(listModel)
			
		else
			setSelectedFromEditorValue()
		end
	end
	
	/** \brief Selection in the list box changed. */
	public func void selectionChanged(ListModel listModel)
		setEditorValueFromSelection()
		updateSelectedWidget()
		
		if pEditor != null and pEditor.getWidget().getVisible()
			pEditor.startEditing()
		end
	end
	
	
	
	/** \brief Update selected widget. */
	public func void updateSelectedWidget()
		var Object selection
		
		var int selectionIndex = pListBox.getSelectedElement()
		if selectionIndex != -1
			selection = pListBox.getModel().getAt(selectionIndex)
		end
		
		var ListElementRenderer renderer = pListBox.getElementRenderer()
		
		runWhileBlockingLayout(block
			if pSelectedElement == null
				pSelectedElement = renderer.createRenderer(pListBox)
				pSelectedElement.setMinimumSize(getDefaultElementSize())
				pSelectedElement.setProtectMinimumSize(true)
				pPanelSelectedElement.addWidget(pSelectedElement)
			end
			
			if pEditor != null
				renderer.updateRenderer(pListBox, pSelectedElement, \
					pEditor.getEditorValue(), false, getHasFocus())
				
			else
				renderer.updateRenderer(pListBox, pSelectedElement, \
					selection, false, getHasFocus())
			end
			
			if pSelectedElement != null
				pSelectedElement.setDesignerSelector(pSelectedElement.getDesignerSelector() + ".ComboBoxSelected")
			end
			
			updateSelectedVisibility()
		end)
		doLayoutIfBlocked()
	end
	
	/** \brief Set editor value from selection if anything is selected. */
	public func void setEditorValueFromSelection()
		if pEditor == null
			return
		end
		
		var int selection = pListBox.getSelectedElement()
		if selection != -1
			pEditor.setEditorValue(pListBox.getModel().getAt(selection))
		end
	end
	
	/** \brief Set selection from editor value. */
	public func void setSelectedFromEditorValue()
		if pEditor == null
			return
		end
		
		if pSelFromEditorOnDropDown and not pDropDown.getVisible()
			pDropDownRequiresSelFromEditor = true
			return
		end
		
		pListBox.setSelectedElement(pListBox.getModel().indexOf(pEditor.getEditorValue()))
	end
	
	/** \brief Update visibility of editor and selected element renderer. */
	public func void updateSelectedVisibility()
		if pEditor == null
			if pSelectedElement != null
				pSelectedElement.setVisible(true)
			end
			return
		end
		
		var bool hasFocus = false
		
		var Desktop desktop = getDesktop()
		if desktop != null
			var Widget focusWidget = desktop.getFocusWidget()
			if focusWidget != null
				hasFocus = focusWidget.hasParent(this) or focusWidget.hasParent(pDropDown)
			end
		end
		
		if hasFocus
			if pSelectedElement != null
				pSelectedElement.setVisible(false)
			end
			pEditor.getWidget().setVisible(true)
			
		else
			if pSelectedElement != null
				pSelectedElement.setVisible(true)
			end
			pEditor.getWidget().setVisible(false)
		end
	end
	
	/** \brief Get default element size. */
	public func Point getDefaultElementSize()
		return pDefaultElementSize
	end
	
	/** \brief Update default element size. */
	public func void updateDefaultElementSize()
		pDefaultElementSize = Point.new(1, 1)
		if getGuiTheme() != null
			pDefaultElementSize = pDefaultElementSize.largest(Point.new(\
				pListBox.getElementWidth(), pListBox.getElementHeight()))
		end
		if pEditor != null
			pDefaultElementSize = pDefaultElementSize.largest(pEditor.getWidget().getMinimumSize())
		end
	end
	
	/**
	 * \brief Selected element widget or null.
	 * \version 1.7
	 */
	public func Widget getWidgetSelectedElement()
		return pSelectedElement
	end
	
	/**
	 * \brief Arrow down pressed.
	 * \version 1.17
	 */
	public func void onArrowDown()
		var int selection = pListBox.getSelectedElement()
		var int count = pListBox.getModel().getCount()
		var int newSelection = selection
		
		if selection == -1 and count > 0
			newSelection = 0
			
		else
			newSelection = DEMath.min(selection + 1, count - 1)
		end
		
		if newSelection != selection
			pListBox.setSelectedElement(newSelection)
		end
		
		dropDown()
	end
	
	/**
	 * \brief Arrow up pressed.
	 * \version 1.17
	 */
	public func void onArrowUp()
		var int selection = pListBox.getSelectedElement()
		var int count = pListBox.getModel().getCount()
		var int newSelection = selection
		
		if selection == -1 and count > 0
			newSelection = 0
			
		else
			newSelection = DEMath.max(selection - 1, 0)
		end
		
		if newSelection != selection
			pListBox.setSelectedElement(newSelection)
		end
		
		dropDown()
	end
	
	/**
	 * \brief Page up pressed.
	 * \version 1.17
	 */
	public func void onPageUp()
		var int selection = pListBox.getSelectedElement()
		var int count = pListBox.getModel().getCount()
		var int newSelection = selection
		var int rowCount
		
		if pListBox.getVisible()
			rowCount = pListBox.getpVisibleRowCount() - 2
			
		else
			rowCount = 10
		end
		
		if selection == -1 and count > 0
			newSelection = 0
			
		else
			newSelection = DEMath.max(selection - rowCount, 0)
		end
		
		if newSelection != selection
			pListBox.setSelectedElement(newSelection)
		end
		
		dropDown()
	end
	
	/**
	 * \brief Page down pressed.
	 * \version 1.17
	 */
	public func void onPageDown()
		var int selection = pListBox.getSelectedElement()
		var int count = pListBox.getModel().getCount()
		var int newSelection = selection
		var int rowCount
		
		if pListBox.getVisible()
			rowCount = pListBox.getpVisibleRowCount() - 2
			
		else
			rowCount = 10
		end
		
		if selection == -1 and count > 0
			newSelection = 0
			
		else
			newSelection = DEMath.min(selection + rowCount, count - 1)
		end
		
		if newSelection != selection
			pListBox.setSelectedElement(newSelection)
		end
		
		dropDown()
	end
end
