/*
 * MIT License
 *
 * Copyright (C) 2025, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

namespace Dragengine.Gui
pin Dragengine.Scenery


/**
 * \brief Find closest widget to focus for directional navigation.
 * \version 1.29
 */
class ClosestDirectionFocusFinder
	protected var Vector2 pAngleDir, pAngleRotDir
	protected var Array pIgnoreWidgets
	protected var float pHitDistance, pNearestForwardDistance, pNearestSideDistance
	protected var Widget pBestHitWidget, pBestNearestWidget
	protected var float pBestHitDistance, pBestNearestForwardDistance, pBestNearestSideDistance
	
	
	/**
	 * \brief Create finder for search direction.
	 * \param angle Counter clock wise angle in degrees in the range from -180 to 180.
	 *              0 angle is straight up.
	 */
	func new(float angle)
		pAngleDir = Vector2.new(-DEMath.sin(angle), -DEMath.cos(angle))
		pAngleRotDir = Vector2.new(pAngleDir.getY(), -pAngleDir.getX())
		pIgnoreWidgets = Array.new()
		pBestHitDistance = pBestNearestForwardDistance = pBestNearestSideDistance = 10000
	end
	
	
	/** \brief Add widget to ignore list. */
	func void addIgnoreWidget(Widget widget)
		if widget == null
			throw ENullPointer.new("widget")
		end
		
		pIgnoreWidgets.add(widget)
	end
	
	/** \brief Add widget or first focusable parent if widget is not focusable. */
	func void addIgnoreWidgetFocusable(Widget widget)
		if widget == null
			throw ENullPointer.new("widget")
		end
		
		while widget != null and not widget.getCanFocusDirectional()
			widget = widget.getParent()
		end
		
		if widget != null
			pIgnoreWidgets.add(widget)
		end
	end
	
	/** \brief Ignore widget is present. */
	func bool hasIgnoreWidget(Widget widget)
		return pIgnoreWidgets.has(widget)
	end
	
	
	/**
	 * \brief Process widget.
	 * \param widget Widget to process.
	 * \param position Position of widget relative to origin.
	 * \param size Size of widget.
	 */
	func void processWidget(Widget widget, Point position, Point size)
		if widget == null
			throw ENullPointer.new("widget")
		end
		if pIgnoreWidgets.has(widget)
			return
		end
		
		var Vector2 c1 = Vector2.new(position)
		var Vector2 c3 = c1 + Vector2.new(size)
		var Vector2 c2 = Vector2.new(c3.getX(), c1.getY())
		var Vector2 c4 = Vector2.new(c1.getX(), c3.getY())
		
		pHitDistance = pNearestForwardDistance = pNearestSideDistance = 10000
		
		processCorner(c1, c2)
		processCorner(c2, c3)
		processCorner(c3, c4)
		processCorner(c4, c1)
		
		if pNearestSideDistance == 0 if pHitDistance > 0.5 else pNearestForwardDistance > 0.5
			BaseGameApp.getApp().getConsole().addMessage("  CHECK: " + Array.newWith(widget, widget.getDesktopBoundary(), pHitDistance, pNearestForwardDistance, pNearestSideDistance, true))
			challengeBest(widget)
			
		else
			BaseGameApp.getApp().getConsole().addMessage("  CHECK: " + Array.newWith(widget, widget.getDesktopBoundary(), pHitDistance, pNearestForwardDistance, pNearestSideDistance, false))
		end
	end
	
	
	/** \brief Best hit widget or null. */
	func Widget getBestHitWidget()
		return pBestHitWidget
	end
	
	/** \brief Best hit distance in pixels. */
	func float getBestHitDistance()
		return pBestHitDistance
	end
	
	
	/** \brief Best nearest widget or null. */
	func Widget getBestNearestWidget()
		return pBestNearestWidget
	end
	
	/** \brief Best nearest forward distance in pixels. */
	func float getBestNearestForwardDistance()
		return pBestNearestForwardDistance
	end
	
	/** \brief Best nearest side distance in pixels. */
	func float getBestNearestSideDistance()
		return pBestNearestSideDistance
	end
	
	
	/** \brief Best widget to use. */
	func Widget getBestWidget()
		BaseGameApp.getApp().getConsole().addMessage("  BEST: " + Array.newWith(\
			pBestHitWidget, pBestHitWidget != null if pBestHitWidget.getDesktopBoundary() else null, pBestHitDistance,\
			pBestNearestWidget, pBestNearestWidget != null if pBestNearestWidget.getDesktopBoundary() else null, pBestNearestSideDistance))
		
		if pBestHitWidget != null and pBestNearestWidget != null
			if pBestHitDistance < pBestNearestForwardDistance + 5.5
				return pBestHitWidget
				
			else
				return pBestNearestWidget
			end
			
		elif pBestHitWidget != null
			return pBestHitWidget
			
		else
			return pBestNearestWidget
		end
	end
	
	
	/** \brief Process corner. */
	protected func void processCorner(Vector2 a, Vector2 b)
		var float t1 = pAngleRotDir * a
		var float t2 = pAngleRotDir * b
		
		if (t1 < -0.25 and t2 > 0.25) or (t2 < -0.25 and t1 > 0.25)
			pHitDistance = DEMath.min(pHitDistance, pAngleDir * a.mix(b, -t1 / (t2 - t1)))
			pNearestForwardDistance = pNearestSideDistance = 0
			
		elif pNearestSideDistance != 0
			if t1 < pNearestSideDistance - 1.5
				pNearestForwardDistance = pAngleDir * a
				pNearestSideDistance = t1
				
			elif t1 < pNearestSideDistance + 1.5
				pNearestForwardDistance = DEMath.min(pNearestForwardDistance, pAngleDir * a)
			end
			
			if t2 < pNearestSideDistance - 1.5
				pNearestForwardDistance = pAngleDir * b
				pNearestSideDistance = t2
				
			elif t2 < pNearestSideDistance + 1.5
				pNearestForwardDistance = DEMath.min(pNearestForwardDistance, pAngleDir * b)
			end
		end
	end
	
	/** \brief Compare processed widget against best widget and keep the winner. */
	protected func void challengeBest(Widget widget)
		if pNearestSideDistance == 0
			if pHitDistance < pBestHitDistance
				pBestHitWidget = widget
				pBestHitDistance = pHitDistance
			end
			
		elif DEMath.fabs(pNearestForwardDistance - pBestNearestForwardDistance) < 4.5
			if pNearestSideDistance < pBestNearestSideDistance
				pBestNearestWidget = widget
				pBestNearestForwardDistance = pNearestForwardDistance
				pBestNearestSideDistance = pNearestSideDistance
			end
			
		else
			if pNearestForwardDistance < pBestNearestForwardDistance
				pBestNearestWidget = widget
				pBestNearestForwardDistance = pNearestForwardDistance
				pBestNearestSideDistance = pNearestSideDistance
			end
		end
		
		BaseGameApp.getApp().getConsole().addMessage("  CHALLENGE: " + Array.newWith(\
			pBestHitWidget, pBestHitWidget != null if pBestHitWidget.getDesktopBoundary() else null, pBestHitDistance,\
			pBestNearestWidget, pBestNearestWidget != null if pBestNearestWidget.getDesktopBoundary() else null, pBestNearestSideDistance))
	end
end
