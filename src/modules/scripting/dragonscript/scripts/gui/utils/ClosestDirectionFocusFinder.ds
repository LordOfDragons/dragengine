/*
 * MIT License
 *
 * Copyright (C) 2025, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

namespace Dragengine.Gui
pin Dragengine.Scenery


/**
 * \brief Find closest widget to focus for directional navigation.
 * \version 1.29
 */
class ClosestDirectionFocusFinder
	protected var Point pForwardDir, pSideDir
	protected var Array pIgnoreWidgets
	protected var int pHitDistance, pNearestForwardDistance, pNearestSideDistance
	protected var Widget pBestHitWidget, pBestNearestWidget
	protected var int pBestHitDistance, pBestNearestForwardDistance, pBestNearestSideDistance
	
	
	/**
	 * \brief Create finder for search direction.
	 * \param direction Direction as \ref InputEventKey#arrowLeft, \ref InputEventKey#arrowRight,
	 *                  \ref InputEventKey#arrowUp or \ref InputEventKey#arrowDown.
	 */
	func new(int direction)
		select direction
		case InputEventKey.arrowUp:
			pForwardDir = Point.new(0, -1)
			pSideDir = Point.new(1, 0)
			
		case InputEventKey.arrowDown:
			pForwardDir = Point.new(0, 1)
			pSideDir = Point.new(1, 0)
			
		case InputEventKey.arrowLeft:
			pForwardDir = Point.new(-1, 0)
			pSideDir = Point.new(0, 1)
			
		case InputEventKey.arrowRight:
			pForwardDir = Point.new(1, 0)
			pSideDir = Point.new(0, 1)
			
		else
			throw EInvalidParam.new("direction")
		end
		
		pIgnoreWidgets = Array.new()
		reset()
	end
	
	
	/** \brief Add widget to ignore list. */
	func void addIgnoreWidget(Widget widget)
		if widget == null
			throw ENullPointer.new("widget")
		end
		
		pIgnoreWidgets.add(widget)
	end
	
	/** \brief Add widget or first focusable parent if widget is not focusable. */
	func void addIgnoreWidgetFocusable(Widget widget)
		if widget == null
			throw ENullPointer.new("widget")
		end
		
		while widget != null and not widget.getCanFocusDirectional()
			widget = widget.getParent()
		end
		
		if widget != null
			pIgnoreWidgets.add(widget)
		end
	end
	
	/** \brief Ignore widget is present. */
	func bool hasIgnoreWidget(Widget widget)
		return pIgnoreWidgets.has(widget)
	end
	
	
	/** \brief Reset finder. */
	func void reset()
		pBestHitWidget = null
		pBestNearestWidget = null
		pBestHitDistance = pBestNearestForwardDistance = pBestNearestSideDistance = 10000
	end
	
	/**
	 * \brief Process widget.
	 * \param widget Widget to process.
	 * \param position Position of widget relative to origin.
	 * \param size Size of widget.
	 */
	func void processWidget(Widget widget, Point position, Point size)
		if widget == null
			throw ENullPointer.new("widget")
		end
		if pIgnoreWidgets.has(widget)
			return
		end
		
		var Point c1 = position
		var Point c3 = c1 + size
		var Point c2 = Point.new(c3.getX(), c1.getY())
		var Point c4 = Point.new(c1.getX(), c3.getY())
		
		pHitDistance = pNearestForwardDistance = pNearestSideDistance = 10000
		
		processCorner(c1, c2)
		processCorner(c2, c3)
		processCorner(c3, c4)
		processCorner(c4, c1)
		
		if pNearestSideDistance == 0 if pHitDistance > 0 else pNearestForwardDistance > 0
			BaseGameApp.getApp().getConsole().addMessage("  CHECK: " + Array.newWith(widget, widget.getDesktopBoundary(), pHitDistance, pNearestForwardDistance, pNearestSideDistance, true))
			challengeBest(widget)
			
		else
			BaseGameApp.getApp().getConsole().addMessage("  CHECK: " + Array.newWith(widget, widget.getDesktopBoundary(), pHitDistance, pNearestForwardDistance, pNearestSideDistance, false))
		end
	end
	
	
	/** \brief Best hit widget or null. */
	func Widget getBestHitWidget()
		return pBestHitWidget
	end
	
	/** \brief Best hit distance in pixels. */
	func int getBestHitDistance()
		return pBestHitDistance
	end
	
	
	/** \brief Best nearest widget or null. */
	func Widget getBestNearestWidget()
		return pBestNearestWidget
	end
	
	/** \brief Best nearest forward distance in pixels. */
	func int getBestNearestForwardDistance()
		return pBestNearestForwardDistance
	end
	
	/** \brief Best nearest side distance in pixels. */
	func int getBestNearestSideDistance()
		return pBestNearestSideDistance
	end
	
	
	/** \brief Best widget to use. */
	func Widget getBestWidget()
		BaseGameApp.getApp().getConsole().addMessage("  BEST: " + Array.newWith(\
			pBestHitWidget, pBestHitWidget != null if pBestHitWidget.getDesktopBoundary() else null, pBestHitDistance,\
			pBestNearestWidget, pBestNearestWidget != null if pBestNearestWidget.getDesktopBoundary() else null, pBestNearestSideDistance))
		
		if pBestHitWidget != null and pBestNearestWidget != null
			/*
			if pBestHitDistance < pBestNearestForwardDistance + 5
				return pBestHitWidget
				
			else
				return pBestNearestWidget
			end
			*/
			return pBestHitWidget
			
		elif pBestHitWidget != null
			return pBestHitWidget
			
		else
			return pBestNearestWidget
		end
	end
	
	
	/** \brief Process corner. */
	protected func void processCorner(Point a, Point b)
		var int t1 = pSideDir * a
		var int t2 = pSideDir * b
		
		if (t1 < 0 and t2 > 0) or (t2 < 0 and t1 > 0)
			var Point p = a + (b - a) * -t1 / (t2 - t1)
			pHitDistance = DEMath.min(pHitDistance, pForwardDir * p)
			pNearestForwardDistance = pNearestSideDistance = 0
			
		elif pNearestSideDistance != 0
			if t1 < pNearestSideDistance - 1
				pNearestForwardDistance = pForwardDir * a
				pNearestSideDistance = t1
				
			elif t1 < pNearestSideDistance + 1
				pNearestForwardDistance = DEMath.min(pNearestForwardDistance, pForwardDir * a)
			end
			
			if t2 < pNearestSideDistance - 1
				pNearestForwardDistance = pForwardDir * b
				pNearestSideDistance = t2
				
			elif t2 < pNearestSideDistance + 1
				pNearestForwardDistance = DEMath.min(pNearestForwardDistance, pForwardDir * b)
			end
		end
	end
	
	/** \brief Compare processed widget against best widget and keep the winner. */
	protected func void challengeBest(Widget widget)
		if pNearestSideDistance == 0
			if pHitDistance < pBestHitDistance
				pBestHitWidget = widget
				pBestHitDistance = pHitDistance
			end
			
		elif DEMath.fabs(pNearestForwardDistance - pBestNearestForwardDistance) < 5
			if pNearestSideDistance < pBestNearestSideDistance
				pBestNearestWidget = widget
				pBestNearestForwardDistance = pNearestForwardDistance
				pBestNearestSideDistance = pNearestSideDistance
			end
			
		else
			if pNearestForwardDistance < pBestNearestForwardDistance
				pBestNearestWidget = widget
				pBestNearestForwardDistance = pNearestForwardDistance
				pBestNearestSideDistance = pNearestSideDistance
			end
		end
		
		BaseGameApp.getApp().getConsole().addMessage("  CHALLENGE: " + Array.newWith(\
			pBestHitWidget, pBestHitWidget != null if pBestHitWidget.getDesktopBoundary() else null, pBestHitDistance,\
			pBestNearestWidget, pBestNearestWidget != null if pBestNearestWidget.getDesktopBoundary() else null, pBestNearestSideDistance))
	end
end
