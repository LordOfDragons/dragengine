/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland PlÃ¼ss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Dragengine.SpeechAnimations

pin Dragengine.Gui
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.LoadSave


/**
 * Speech animation Playback.
 */
class SpeechAnimationPlayback
	class Phoneme
		private var int pController
		private var float pDuration
		
		public func new(int controller, float duration)
			pController = controller
			pDuration = duration
		end
		
		public func int getController()
			return pController
		end
		public func float getDuration()
			return pDuration
		end
	end
	
	
	
	private var SpeechAnimation pSpeechAnimation
	private var AnimatorInstance pAnimatorInstance
	private var Array pPhonemes
	private var float pDuration
	private var int pPosition
	private var float pElapsed
	private var bool pSpeaking
	private var Array pControllers
	private var bool pRequiresApply
	
	
	
	/** Creates a new speech animation playback. */
	public func new()
		pAnimatorInstance = AnimatorInstance.new()
		pPhonemes = Array.new()
		pDuration = 0
		pPosition = 0
		pElapsed = 0
		pSpeaking = false
		pControllers = Array.new()
		pRequiresApply = false
	end
	
	
	
	/** Retrieves the animator instance. */
	public func AnimatorInstance getAnimatorInstance()
		return pAnimatorInstance
	end
	
	/** Retrieves the speech animation or null if not assigned. */
	public func SpeechAnimation getSpeechAnimation()
		return pSpeechAnimation
	end
	
	/** Sets the speech animation or null if not assigned. */
	public func void setSpeechAnimation(SpeechAnimation speechAnimation)
		pControllers.removeAll()
		pAnimatorInstance.setAnimator(null)
		pSpeechAnimation = speechAnimation
		
		if speechAnimation == null
			return
		end
		
		pAnimatorInstance.setAnimator(speechAnimation.getAnimator())
		
		var int i, count = pAnimatorInstance.getControllerCount()
		for i = 0 to count
			pControllers.add(pAnimatorInstance.getControllerAt(i))
		end
	end
	
	/** Retrieves the duration of the speaking. */
	public func float getDuration()
		return pDuration
	end
	
	/** Retrieves the elapsed time. */
	public func float getElapsed()
		return pElapsed
	end
	
	/** Determines if the playback is still running. */
	public func bool getSpeaking()
		return pSpeaking
	end
	
	
	
	/** Remove all phonemes. */
	public func void removeAllPhonemes()
		pPhonemes.removeAll()
		pDuration = 0
		pPosition = -1
		pElapsed = 0
		pSpeaking = false
	end
	
	/** Adds a speak phoneme. */
	public func void addPhoneme(SpeechAnimationPhoneme phoneme, float duration)
		if phoneme == null
			pPhonemes.add(Phoneme.new(-1, duration))
			
		else
			pPhonemes.add(Phoneme.new(phoneme.getController(), duration))
		end
		
		pDuration += duration
		pPosition = -1
		pElapsed = 0
		pSpeaking = true
	end
	
	
	
	/**
	 * \brief Updates the speech animation.
	 * 
	 * This updates the playback and updates animator instances if required. This does not
	 * apply the animation yet to allow proper use of state capturing.
	 */
	public func void update(float elapsed)
		if not pSpeaking
			return
		end
		
		var int controllerCount = pAnimatorInstance.getControllerCount()
		var int phonemeCount = pPhonemes.getCount()
		var float wordGapDuration = 0.1
		var float windUpDuration = 0.1
		var float pauseDuration = 0.1
		var float blendFactor = 1
		var int controller1 = -1
		var int controller2 = -1
		var Phoneme phoneme1, phoneme2
		var float phonemeDuration
		var int i
		
		// determine which phoneme to display and the blending
		pElapsed += elapsed
		
		while true
			phoneme1 = null
			phoneme2 = null
			
			if pPosition >= 0 and pPosition < phonemeCount
				phoneme1 = pPhonemes.getAt(pPosition) cast Phoneme
			end
			
			if pPosition + 1 < phonemeCount
				phoneme2 = pPhonemes.getAt(pPosition + 1) cast Phoneme
			end
			
			if pPosition == -1
				phonemeDuration = windUpDuration
				
			elif pPosition == phonemeCount
				phonemeDuration = wordGapDuration
				
			elif phoneme1 != null
				phonemeDuration = phoneme1.getDuration()
				
			else
				phonemeDuration = pauseDuration
			end
			
			if pElapsed < phonemeDuration
				blendFactor = 1.0 - DEMath.smoothStep(pElapsed, 0.0, phonemeDuration)
				
				if phoneme1 != null
					controller1 = phoneme1.getController()
				end
				if phoneme2 != null
					controller2 = phoneme2.getController()
				end
				
				if controller1 == controller2
					controller2 = -1
					blendFactor = 1
				end
				
				break
			end
			
			if pPosition < phonemeCount
				pPosition++
				
			else
				pSpeaking = false
				controller1 = -1
				controller2 = -1
				break
			end
			
			pElapsed -= phonemeDuration
		end
		
		// update the controllers
		if controller1 != -1 and controller2 != -1
			pAnimatorInstance.setBlendFactor(1)
			
		elif controller1 != -1
			pAnimatorInstance.setBlendFactor(blendFactor)
			blendFactor = 1
			
		elif controller2 != -1
			pAnimatorInstance.setBlendFactor(1.0 - blendFactor)
			blendFactor = 1
			
		else
			pAnimatorInstance.setBlendFactor(0)
		end
		
		pControllers.forEach(block int index, AnimatorController each
			if index == controller1
				each.setValue(blendFactor)
				
			elif index == controller2
				each.setValue(1.0 - blendFactor)
				
			else
				each.setValue(0)
			end
		end)
		
		pRequiresApply = true
	end
	
	/**
	 * \brief Apply animation.
	 * 
	 * Called after update() to apply animation. Can do nothing if no change has been done.
	 */
	public func void applyAnimation()
		if not pRequiresApply
			return
		end
		
		pRequiresApply = false
		pAnimatorInstance.apply()
	end
	
	
	
	/** Reads the element from a file. */
	public func void readFromFile(PersistencyEnvironment env, FileReader reader)
		select reader.readByte() // version
		case 0
			var int controller
			var float duration
			
			pSpeaking = env.readBool(reader)
			
			var int i, count = reader.readUShort()
			pPhonemes.removeAll()
			for i = 0 to count
				controller = reader.readUShort() - 1
				duration = reader.readFloat()
				pPhonemes.add(Phoneme.new(controller, duration))
			end
			
			pDuration = reader.readFloat()
			pPosition = reader.readShort()
			pElapsed = reader.readFloat()
			
		else
			throw EInvalidParam.new("unsupported version")
		end
	end
	
	/** Writes the element to a file. */
	public func void writeToFile(PersistencyEnvironment env, FileWriter writer)
		writer.writeByte(0) // version
		
		env.writeBool(writer, pSpeaking)
		
		writer.writeUShort(pPhonemes.getCount())
		pPhonemes.forEach(block Phoneme each
			writer.writeUShort(each.getController() + 1)
			writer.writeFloat(each.getDuration())
		end)
		
		writer.writeFloat(pDuration)
		writer.writeShort(pPosition)
		writer.writeFloat(pElapsed)
	end
end
