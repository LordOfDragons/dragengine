/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


namespace Dragengine.Gui.MainMenus.Interactive

pin Dragengine.LoadSave
pin Dragengine.Preloading
pin Dragengine.Utils
pin Dragengine.Scenery
pin Dragengine.TriggerSystem


/**
 * \brief Behavior element behavior adding interactive main menu hot spot support.
 */
class IMMBehaviorHotSpot extends DefaultECBehavior
	/** \brief Behavior instance. */
	class Instance extends DefaultECBehaviorInstance
		var IMMBehaviorHotSpot pECBehavior
		var ECBehaviorTwoStateAnimated.Instance pAnimated
		var String pAction, pCameraSpot
		var float pTransitionTime
		var String pDisplayText, pDisplayTextTranslate
		var float pDelayActivate, pDelayDeactivate, pRemainingDelay
		var bool pHotSpotActive
		var TSNamedTriggerTarget pTargetHotSpotActive, pTargetHotSpotActivated
		var TSNamedTriggerTarget pTargetHotSpotDeactivated, pTargetHotSpotHover
		var TSNamedTriggerTarget pTargetHotSpotEntered, pTargetHotSpotLeft
		var Vector pCenterPosition
		var String pCenterPositionBone
		
		
		
		/** \brief Create element. */
		func new(IMMBehaviorHotSpot ecbehavior, BehaviorElement element) super(element)
			pECBehavior = ecbehavior
			pRemainingDelay = 0
			pHotSpotActive = false
			
			pAnimated = ecbehavior.getAnimated().instance(getElement())
		end
		
		/** \brief Dispose of composeable instance. */
		func void dispose()
			pTargetHotSpotActive = null
			pTargetHotSpotActivated = null
			pTargetHotSpotDeactivated = null
			pTargetHotSpotHover = null
			pTargetHotSpotEntered = null
			pTargetHotSpotLeft = null
			pAnimated = null
			super.dispose()
		end
		
		
		
		/** \brief Initialize element from stub. */
		func void init(StubElement stub)
			var CodecPropertyString codec = getElement().getClass().getCodecPropertyString()
			
			pAction = pECBehavior.getAction().getValue(stub)
			pCameraSpot = pECBehavior.getCameraSpot().getValue(stub)
			pTransitionTime = pECBehavior.getTransitionTime().getValue(stub)
			pDelayActivate = pECBehavior.getDelayActivate().getValue(stub)
			pDelayDeactivate = pECBehavior.getDelayDeactivate().getValue(stub)
			pDisplayText = pECBehavior.getDisplayText().getValue(stub)
			pDisplayTextTranslate = pECBehavior.getDisplayTextTranslate().getValueOrNull(stub)
			pCenterPosition = pECBehavior.getCenterPosition().getVector(stub, codec)
			pCenterPositionBone = pECBehavior.getCenterPositionBone().getValueOrEmpty(stub)
			
			pTargetHotSpotActive = TSNamedTriggerTarget.new(\
				pECBehavior.getTargetHotSpotActive().getValue(stub))
			pTargetHotSpotActivated = TSNamedTriggerTarget.new(\
				pECBehavior.getTargetHotSpotActivated().getValue(stub))
			pTargetHotSpotDeactivated = TSNamedTriggerTarget.new(\
				pECBehavior.getTargetHotSpotDeactivated().getValue(stub))
			pTargetHotSpotHover = TSNamedTriggerTarget.new(\
				pECBehavior.getTargetHotSpotHover().getValue(stub))
			pTargetHotSpotEntered = TSNamedTriggerTarget.new(\
				pECBehavior.getTargetHotSpotEntered().getValue(stub))
			pTargetHotSpotLeft = TSNamedTriggerTarget.new(\
				pECBehavior.getTargetHotSpotLeft().getValue(stub))
		end
		
		
		
		/** \brief Element class behavior. */
		func IMMBehaviorHotSpot getECBehavior()
			return pECBehavior
		end
		
		
		
		/** \brief Action to carry out. */
		func String getAction()
			return pAction
		end
		
		/** \brief Set action to carry out. */
		protected func void setAction(String action)
			pAction = action
		end
		
		/** \brief Camera spot to activate when hot-spot is activated. */
		func String getCameraSpot()
			return pCameraSpot
		end
		
		/** \brief Set camera spot to activate when hot-spot is activated. */
		protected func void setCameraSpot(String cameraSpot)
			pCameraSpot = cameraSpot
		end
		
		/** \brief Transition time. */
		func float getTransitionTime()
			return pTransitionTime
		end
		
		/** \brief Set transition time. */
		protected func void setTransitionTime(float time)
			pTransitionTime = DEMath.max(time, 0.0)
		end
		
		/** \brief Display text. */
		func String getDisplayText()
			return pDisplayText
		end
		
		/** \brief Set display text. */
		protected func void setDisplayText(String text)
			pDisplayText = text
		end
		
		/**
		 * \brief Translated display text or null.
		 * \version 1.16
		 */
		func String getDisplayTextTranslate()
			return pDisplayTextTranslate
		end
		
		/**
		 * \brief Set translated display text or null.
		 * \version 1.16
		 */
		protected func void setDisplayTextTranslate(String text)
			pDisplayTextTranslate = text
		end
		
		/** \brief Delay for activating IMMProp after hotspot has been activated. */
		func float getDelayActivate()
			return pDelayActivate
		end
		
		/** \brief Set delay for activating IMMProp after hotspot has been activated. */
		protected func void setDelayActivate(float delay)
			pDelayActivate = DEMath.max(delay, 0.0)
		end
		
		/** \brief Delay for deactivating IMMProp after hotspot has been deactivated. */
		func float getDelayDeactivate()
			return pDelayDeactivate
		end
		
		/** \brief Set delay for deactivating IMMProp after hotspot has been deactivated. */
		protected func void setDelayDeactivate(float delay)
			pDelayDeactivate = DEMath.max(delay, 0.0)
		end
		
		/** \brief Remaing prop (de)activate prop delay. */
		func float getRemainingDelay()
			return pRemainingDelay
		end
		
		/** \brief Set remaing prop (de)activate prop delay. */
		protected func void setRemainingDelay(float time)
			pRemainingDelay = time
		end
		
		/** \brief Hot-spot is active. */
		func bool getHotSpotActive()
			return pHotSpotActive
		end
		
		
		
		/** \brief Trigger target to reflect activated state. */
		func TSNamedTriggerTarget getTargetHotSpotActivated()
			return pTargetHotSpotActive
		end
		
		/** \brief Trigger target to notify activating. */
		func TSNamedTriggerTarget getTargetHotSpotActivating()
			return pTargetHotSpotActivated
		end
		
		/** \brief Trigger target to notify deactivating. */
		func TSNamedTriggerTarget getTargetHotSpotDeactivating()
			return pTargetHotSpotDeactivated
		end
		
		/** \brief Trigger target to reflect hovering state. */
		func TSNamedTriggerTarget getTargetHotSpotHover()
			return pTargetHotSpotHover
		end
		
		/** \brief Trigger target to notify entering. */
		func TSNamedTriggerTarget getTargetHotSpotEntered()
			return pTargetHotSpotEntered
		end
		
		/** \brief Trigger target to notify leaving. */
		func TSNamedTriggerTarget getTargetHotSpotLeft()
			return pTargetHotSpotLeft
		end
		
		
		
		/**
		 * \brief Center position for directional navigation.
		 * \version 1.29
		 */
		func DVector getCenterPosition()
			var Vector center = pCenterPosition
			if not pCenterPositionBone.empty()
				var Component component = pAnimated.getComponent().getComponent()
				if component != null
					var int index = component.indexOfBoneNamed(pCenterPositionBone)
					if index != -1
						center = component.boneGetMatrix(index).getPosition()
					end
				end
			end
			return getElement().getElementMatrix() * DVector.new(center)
		end
		
		/**
		 * \brief Hot-spot has been activated.
		 * 
		 * Hot-spot has to start activate transition (possibly delayed).
		 */
		func void onHotSpotActivated()
			pRemainingDelay = pDelayActivate
			pHotSpotActive = true
			setRequiresThink(true)
			
			pTargetHotSpotActive.fire()
			pTargetHotSpotActivated.pulse()
		end
		
		/**
		 * \brief Hot-spot has been deactivated.
		 * 
		 * Hot-spot has to stop running the action and start deactivate transition (possibly delayed).
		 */
		func void onHotSpotDeactivated()
			pRemainingDelay = pDelayDeactivate
			pHotSpotActive = false
			setRequiresThink(true)
			
			pTargetHotSpotActive.reset()
			pTargetHotSpotDeactivated.pulse()
		end
		
		
		
		/** \brief Reset initial state immediately. */
		func void reset()
			pRemainingDelay = 0
			pHotSpotActive = false
			setRequiresThink(false)
			pTargetHotSpotActive.reset()
			pAnimated.setDeactivated()
		end
		
		/** \brief Set activated now. */
		func void setActivated()
			pRemainingDelay = 0
			pHotSpotActive = true
			setRequiresThink(false)
			pTargetHotSpotActive.fire()
			pAnimated.setActivated()
		end
		
		
		
		/**
		 * \brief Mouse pointer is hovering over Hot-spot.
		 * 
		 * Hot-spot has to start hover actions if present.
		 */
		func void onHotSpotHoverEnter()
			var IMMTextDisplay textDisplay = pECBehavior.getTextDisplay()
			if textDisplay != null
				var String text = pDisplayText
				if pDisplayTextTranslate != null
					text = "@" + pDisplayTextTranslate
				end
				textDisplay.setText(text)
			end
			
			pTargetHotSpotHover.fire()
			pTargetHotSpotEntered.pulse()
		end
		
		/**
		 * \brief Mouse pointer is no more hovering over Hot-spot.
		 * 
		 * Hot-spot has to stop hover actions if present.
		 */
		func void onHotSpotHoverExit()
			if pECBehavior.getTextDisplay() != null
				pECBehavior.getTextDisplay().clearText()
			end
			
			pTargetHotSpotHover.reset()
			pTargetHotSpotLeft.pulse()
		end
		
		
		
		/** \brief Add to game world. */
		func void addToGameWorld()
			var TSTriggerTable triggerTable = pECBehavior.getTriggerTable()
			pTargetHotSpotActive.acquireTarget(triggerTable)
			pTargetHotSpotActivated.acquireTarget(triggerTable)
			pTargetHotSpotDeactivated.acquireTarget(triggerTable)
			pTargetHotSpotHover.acquireTarget(triggerTable)
			pTargetHotSpotEntered.acquireTarget(triggerTable)
			pTargetHotSpotLeft.acquireTarget(triggerTable)
		end
		
		/** \brief Remove from game world. */
		func void removeFromGameWorld()
			pTargetHotSpotActive.dropTarget()
			pTargetHotSpotActivated.dropTarget()
			pTargetHotSpotDeactivated.dropTarget()
			pTargetHotSpotHover.dropTarget()
			pTargetHotSpotEntered.dropTarget()
			pTargetHotSpotLeft.dropTarget()
		end
		
		
		
		/** \brief Think about what the element is going to do in this frame. */
		func void think(float elapsed)
			if pHotSpotActive
				if not pAnimated.isDeactivated()
					return
				end
				
				pRemainingDelay -= elapsed
				if pRemainingDelay > 0
					return
				end
				
				setRequiresThink(false)
				pAnimated.activate()
				
			else
				if not pAnimated.isActivated()
					return
				end
				
				pRemainingDelay -= elapsed
				if pRemainingDelay > 0
					return
				end
				
				setRequiresThink(false)
				pAnimated.deactivate()
			end
		end
	end
	
	
	
	var ECBehaviorTwoStateAnimated pAnimated
	var ECPString pAction, pCameraSpot
	var ECPFloat pTransitionTime
	var ECPString pDisplayText, pDisplayTextTranslate
	var ECPFloat pDelayActivate, pDelayDeactivate
	var ECPString pTargetHotSpotActive, pTargetHotSpotActivated
	var ECPString pTargetHotSpotDeactivated, pTargetHotSpotHover
	var ECPString pTargetHotSpotEntered, pTargetHotSpotLeft
	var TSTriggerTable pTriggerTable
	var IMMTextDisplay pTextDisplay
	var ECPVector pCenterPosition
	var ECPString pCenterPositionBone
	
	
	
	/** \brief Create behavior element class. */
	func new(BehaviorElementClass eclass, ECBehaviorTwoStateAnimated animated) \
	this(eclass, animated, eclass.sharedFactoryHelper.defaultLoaders(), null)
	end
	
	/** \brief Create behavior element class. */
	func new(BehaviorElementClass eclass, ECBehaviorTwoStateAnimated animated, \
	Loaders loaders, TSTriggerTable triggerTable) \
	this(eclass, animated, loaders, triggerTable, "hotspot.")
	end
	
	func new(BehaviorElementClass eclass, ECBehaviorTwoStateAnimated animated, \
	Loaders loaders, TSTriggerTable triggerTable, String prefix) super(eclass)
		if animated == null
			throw ENullPointer.new("animated")
		end
		
		pAnimated = animated
		pTriggerTable = triggerTable
		
		eclass.addProperty(pAction = ECPString.new(prefix + "action", ""))
		eclass.addProperty(pCameraSpot = ECPString.new(prefix + "cameraSpot", ""))
		eclass.addProperty(pTransitionTime = ECPFloat.new(prefix + "transitionTime", 1.5, 0))
		eclass.addProperty(pDisplayText = ECPString.new(prefix + "displayText", ""))
		eclass.addProperty(pDisplayTextTranslate = ECPString.new(prefix + "displayTextTranslate", null))
		eclass.addProperty(pDelayActivate = ECPFloat.new(prefix + "delayActivate", 0, 0))
		eclass.addProperty(pDelayDeactivate = ECPFloat.new(prefix + "delayDeactivate", 0, 0))
		eclass.addProperty(pTargetHotSpotActive = ECPString.new(prefix + "targetHotSpotActive", ""))
		eclass.addProperty(pTargetHotSpotActivated = ECPString.new(prefix + "targetHotSpotActivated", ""))
		eclass.addProperty(pTargetHotSpotDeactivated = ECPString.new(prefix + "targetHotSpotDeactivated", ""))
		eclass.addProperty(pTargetHotSpotHover = ECPString.new(prefix + "targetHotSpotHover", ""))
		eclass.addProperty(pTargetHotSpotEntered = ECPString.new(prefix + "targetHotSpotEntered", ""))
		eclass.addProperty(pTargetHotSpotLeft = ECPString.new(prefix + "targetHotSpotLeft", ""))
		eclass.addProperty(pCenterPosition = ECPVector.new(prefix + "centerPosition", Vector.new()))
		eclass.addProperty(pCenterPositionBone = ECPString.new(prefix + "centerPositionBone", ""))
		
		eclass.addBehavior(this)
	end
	
	/** \brief Dispose of behavior. */
	func void dispose()
		pAnimated = null
		super.dispose()
	end
	
	
	
	func ECBehaviorTwoStateAnimated getAnimated()
		return pAnimated
	end
	
	func ECPString getAction()
		return pAction
	end
	
	func ECPString getCameraSpot()
		return pCameraSpot
	end
	
	func ECPFloat getTransitionTime()
		return pTransitionTime
	end
	
	func ECPString getDisplayText()
		return pDisplayText
	end
	
	/**
	 * \brief Translated display text.
	 * \version 1.16
	 */
	func ECPString getDisplayTextTranslate()
		return pDisplayTextTranslate
	end
	
	func ECPFloat getDelayActivate()
		return pDelayActivate
	end
	
	func ECPFloat getDelayDeactivate()
		return pDelayDeactivate
	end
	
	func ECPString getTargetHotSpotActive()
		return pTargetHotSpotActive
	end
	
	func ECPString getTargetHotSpotActivated()
		return pTargetHotSpotActivated
	end
	
	func ECPString getTargetHotSpotDeactivated()
		return pTargetHotSpotDeactivated
	end
	
	func ECPString getTargetHotSpotHover()
		return pTargetHotSpotHover
	end
	
	func ECPString getTargetHotSpotEntered()
		return pTargetHotSpotEntered
	end
	
	func ECPString getTargetHotSpotLeft()
		return pTargetHotSpotLeft
	end
	
	/** \brief Trigger table or \em null if not used. */
	func TSTriggerTable getTriggerTable()
		return pTriggerTable
	end
	
	/** \brief Set trigger table or \em null if not used. */
	func void setTriggerTable(TSTriggerTable triggerTable)
		pTriggerTable = triggerTable
	end
	
	/** \brief Text display or \em null if not used. */
	func IMMTextDisplay getTextDisplay()
		return pTextDisplay
	end
	
	/** \brief Set text display or \em null if not used. */
	func void setTextDisplay(IMMTextDisplay textDisplay)
		pTextDisplay = textDisplay
	end
	
	/**
	 * \brief Center position for directional navigation.
	 * \version 1.29
	 */
	func ECPVector getCenterPosition()
		return pCenterPosition
	end
	
	/**
	 * \brief Bone to use for center position for directional navigation or null to estimate.
	 * \version 1.29
	 */
	func ECPString getCenterPositionBone()
		return pCenterPositionBone
	end
	
	
	/** \brief Get instance in element from owner element class. */
	func Instance instance(BehaviorElement element)
		return element.getInstanceAt(getInstanceIndex()) cast Instance
	end
	
	
	
	/**
	 * \brief Get behavior in element class or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElementClass contains a behavior
	 * of type ECBehaviorComponent.
	 */
	static func IMMBehaviorHotSpot getBehaviorIn(BehaviorElementClass eclass)
		return eclass.findBehavior(block IMMBehaviorHotSpot each
			return true
		end) cast IMMBehaviorHotSpot
	end
	
	/**
	 * \brief Get instance in element or \em null if absent.
	 * 
	 * Use this method to check if a particular BehaviorElement contains a behavior instance
	 * of type IMMBehaviorHotSpot.Instance . If more than one instance is present returns
	 * the first instance.
	 */
	static func Instance getInstanceIn(BehaviorElement element)
		return element.findInstance(block Instance each
			return true
		end) cast Instance
	end
	
	
	
	/** \brief Create element class behavior instance. */
	func ECBehaviorInstance createInstance(BehaviorElement element)
		return Instance.new(this, element)
	end
end
