/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland PlÃ¼ss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.ConversationSystem

pin Dragengine.Gui
pin Dragengine.Scenery
pin Dragengine.Utils
pin Dragengine.LoadSave


/**
 * \brief Conversation face pose playback.
 */
class ConversationFacePosePlayback
	/** \brief Face pose controller. */
	class FacePoseController
		private var int pController
		private var String pControllerName
		private var float pInfluence
		
		/**
		 * \brief Create face pose controller.
		 * \deprecated Use new(String,float)
		 */
		public func new(int controller, float influence)
			pController = controller
			pInfluence = influence
		end
		
		/**
		 * \brief Create face pose controller.
		 * \version 1.16
		 */
		public func new(String controller, float influence)
			pController = -1
			pControllerName = controller
			pInfluence = influence
		end
		
		/**
		 * \brief Controller.
		 * \deprecated Use getControllerName().
		 */
		public func int getController()
			return pController
		end
		
		/**
		 * \brief Controller name.
		 * \version 1.16
		 */
		public func String getControllerName()
			return pControllerName
		end
		
		/** \brief Influence. */
		public func float getInfluence()
			return pInfluence
		end
		
		/** \brief Read from file. */
		static public func FacePoseController readFromFile(FileReader reader)
			select reader.readByte() // version
			case 0 // deprecated
				var int controller = reader.readUShort() - 1
				var float influence = reader.readFloat()
				return FacePoseController.new(controller, influence)
				
			case 1
				var String controller = reader.readString8()
				var float influence = reader.readFloat()
				return FacePoseController.new(controller, influence)
				
			else
				throw EInvalidParam.new("unsupported version")
			end
		end
		
		/** \brief Write to file. */
		public func void writeToFile(FileWriter writer)
			if pControllerName != null
				writer.writeByte(1) // version
				writer.writeString8(pControllerName)
				
			else // deprecated
				writer.writeByte(0) // version
				writer.writeUShort(pController + 1)
			end
			
			writer.writeFloat(pInfluence)
		end
	end
	
	/** \brief Face pose. */
	class FacePose
		/** \brief Array of FacePoseController. */
		private var Array pControllers
		
		/** \brief Strip. */
		private var ConversationStrip pStrip
		
		/** \brief Create face pose. */
		public func new(Array controllers, ConversationStrip strip)
			pControllers = controllers
			pStrip = strip
		end
		
		/** \brief Array of FacePoseController. */
		public func Array getControllers()
			return pControllers
		end
		
		/** \brief Strip. */
		public func ConversationStrip getStrip()
			return pStrip
		end
		
		/** \brief Read from file. */
		static public func FacePose readFromFile(FileReader reader)
			select reader.readByte() // version
			case 0
				var Array controllers = readControllersFromFile(reader)
				var ConversationStrip strip = ConversationStrip.readFromFile(reader)
				return FacePose.new(controllers, strip)
				
			else
				throw EInvalidParam.new("unsupported version")
			end
		end
		
		/** \brief Read controllers from file. */
		static public func Array readControllersFromFile(FileReader reader)
			var Array controllers = Array.new()
			var int i, count = reader.readUShort()
			for i = 0 to count
				controllers.add(FacePoseController.readFromFile(reader))
			end
			return controllers
		end
		
		/** \brief Write to file. */
		public func void writeToFile(FileWriter writer)
			writer.writeByte(0) // version
			
			writeControllersToFile(writer, pControllers)
			pStrip.writeToFile(writer)
		end
		
		/** \brief Write controllers to file. */
		static public func void writeControllersToFile(FileWriter writer, Array controllers)
			writer.writeUShort(controllers.getCount())
			controllers.forEach(block FacePoseController each
				each.writeToFile(writer)
			end)
		end
	end
	
	
	
	private var Animator pAnimator
	private var AnimatorInstance pAnimatorInstance
	private var Array pPoses
	private var int pPosition
	private var float pElapsed
	private var Array pLastPose
	private var Array pCurPose
	private var bool pRunning
	private var bool pRequiresApply
	
	private var float pBlinkIntervalMin
	private var float pBlinkIntervalMax
	private var float pBlinkNext
	private var float pBlinkElapsed
	
	
	
	/** \brief Create face pose playback. */
	public func new()
		pAnimatorInstance = AnimatorInstance.new()
		pPoses = Array.new()
		pPosition = 0
		pElapsed = 0.0
		pRunning = false
		pRequiresApply = false
		
		pBlinkIntervalMin = 2.0
		pBlinkIntervalMax = 6.0
		pBlinkNext = 2.0 + 4.0 * DEMath.random()
		pBlinkElapsed = 0.0
	end
	
	
	
	/** \brief Animator. */
	public func Animator getAnimator()
		return pAnimator
	end
	
	/** \brief Set animator. */
	public func void setAnimator(Animator animator)
		pAnimatorInstance.setAnimator(animator)
		pAnimator = animator
	end
	
	/** \brief Animator instance. */
	public func AnimatorInstance getAnimatorInstance()
		return pAnimatorInstance
	end
	
	/** \brief Elapsed time. */
	public func float getElapsed()
		return pElapsed
	end
	
	
	
	/** \brief Remove all face poses. */
	public func void removeAllPoses()
		pPoses.removeAll()
		pPosition = 0
		pElapsed = 0.0
		pRunning = false
	end
	
	/**
	 * \brief Add face pose.
	 * \param controllers Array of FacePoseController.
	 * \param strip Strip to play.
	 */
	public func void addPose(Array controllers, ConversationStrip strip)
		pPoses.add(FacePose.new(controllers, strip))
		pPosition = 0
		pElapsed = 0.0
		pRunning = true
	end
	
	
	
	/**
	 * \brief Update playback.
	 * 
	 * This updates the playback and updates animator instances if required. This does not
	 * apply the animation yet to allow proper use of state capturing.
	 */
 	public func void update(float elapsed)
		var float blendFactor1 = 0
		var float blendFactor2 = 1
		
		pRequiresApply = false
		
		if pRunning and pPoses.getCount() > 0
			var int poseCount = pPoses.getCount()
			
			pElapsed += elapsed
			
			while pPosition < poseCount
				var FacePose pbpose = pPoses.getAt(pPosition) cast FacePose
				var ConversationStrip strip = pbpose.getStrip()
				var Array pcontrollers = pbpose.getControllers()
				var float duration = strip.getDuration()
				var float pause = strip.getPause()
				var float length = pause + duration
				
				if pElapsed < length
					if pcontrollers != pCurPose
						pLastPose = pCurPose
						pCurPose = pcontrollers
					end
					
					blendFactor2 = DEMath.smoothStep(pElapsed, pause, length)
					blendFactor1 = 1.0 - blendFactor2
					break
					
				else
					pLastPose = pCurPose
					pCurPose = pcontrollers
					
					pElapsed -= length
					pPosition++
				end
			end
			
			if pPosition >= poseCount
				pRunning = false
			end
		end
		
		if pAnimator == null
			return
		end
		
		// set the controller values. for this first all controllers are set to zero. then
		// the controller values of the last face pose (if existing) multiplied by the
		// first blend factor are set. then the controller values of the current face pose
		// (if existing) multiplied by the second blend factor are added. this way a proper
		// blending can be achieved no matter which combination of face poses (as well as
		// the lack thereof) is in effect
		var int controllerCount = pAnimatorInstance.getControllerCount()
		var int i
		
		for i = 0 to controllerCount
			pAnimatorInstance.getControllerAt(i).setValue(0)
		end
		
		if pLastPose != null
			pLastPose.forEach(block FacePoseController each
				if each.getControllerName() != null
					var AnimatorController controller = pAnimatorInstance.getControllerNamed(each.getControllerName())
					if controller != null
						controller.setValue(each.getInfluence() * blendFactor1)
					end
					
				else // deprecated
					var int controller = each.getController()
					if controller >= 0 and controller < controllerCount
						pAnimatorInstance.getControllerAt(controller).setValue(each.getInfluence() * blendFactor1)
					end
				end
			end)
		end
		
		if pCurPose != null
			pCurPose.forEach(block FacePoseController each
				if each.getControllerName() != null
					var AnimatorController controller = pAnimatorInstance.getControllerNamed(each.getControllerName())
					if controller != null
						controller.increment(each.getInfluence() * blendFactor2)
					end
					
				else // deprecated
					var int controller = each.getController()
					if controller >= 0 and controller < controllerCount
						pAnimatorInstance.getControllerAt(controller).increment(each.getInfluence() * blendFactor2)
					end
				end
			end)
		end
		
		// blinking
		pBlinkNext -= elapsed
		pBlinkElapsed += elapsed
		
		if pBlinkNext <= 0
			pBlinkNext = DEMath.random(pBlinkIntervalMin, pBlinkIntervalMax)
			pBlinkElapsed = 0
		end
		
		if controllerCount > 0
			pAnimatorInstance.getControllerAt(controllerCount - 1).setValue(pBlinkElapsed)
		end
		
		pRequiresApply = true
	end
	
	/**
	 * \brief Apply animation.
	 * 
	 * Called after update() to apply animation. Can do nothing if no change has been done.
	 */
	public func void applyAnimation()
		if pRequiresApply
			pAnimatorInstance.apply()
		end
	end
	
	
	
	/**
	 * \brief Read from file.
	 * 
	 * Animator and AnimatorInstance are not stored. They have to be set by the ConversationActor.
	 */
	public func void readFromFile(PersistencyEnvironment env, FileReader reader)
		select reader.readByte() // version
		case 0
			var PersistencyFlags flags = PersistencyFlags.new(3, reader)
			pRunning = flags.getAt(0)
			
			var int i, count = reader.readUShort()
			pPoses.removeAll()
			for i = 0 to count
				pPoses.add(FacePose.readFromFile(reader))
			end
			
			pPosition = reader.readUShort()
			pElapsed = reader.readFloat()
			
			if flags.getAt(1)
				pLastPose = FacePose.readControllersFromFile(reader)
			end
			if flags.getAt(2)
				pCurPose = FacePose.readControllersFromFile(reader)
			end
			
			pBlinkIntervalMin = reader.readFloat()
			pBlinkIntervalMax = reader.readFloat()
			pBlinkNext = reader.readFloat()
			pBlinkElapsed = reader.readFloat()
			
		else
			throw EInvalidParam.new("unsupported version")
		end
	end
	
	/**
	 * \brief Writes to file.
	 * 
	 * Animator and AnimatorInstance are not stored. They have to be set by the ConversationActor.
	 */
	public func void writeToFile(PersistencyEnvironment env, FileWriter writer)
		writer.writeByte(0) // version
		
		var PersistencyFlags flags = PersistencyFlags.new(3)
		flags.setAt(0, pRunning)
		flags.setAt(1, pLastPose != null)
		flags.setAt(2, pCurPose != null)
		flags.writeToFile(writer)
		
		writer.writeUShort(pPoses.getCount())
		pPoses.forEach(block FacePose each
			each.writeToFile(writer)
		end)
		
		writer.writeUShort(pPosition)
		writer.writeFloat(pElapsed)
		
		if pLastPose != null
			FacePose.writeControllersToFile(writer, pLastPose)
		end
		if pCurPose != null
			FacePose.writeControllersToFile(writer, pCurPose)
		end
		
		writer.writeFloat(pBlinkIntervalMin)
		writer.writeFloat(pBlinkIntervalMax)
		writer.writeFloat(pBlinkNext)
		writer.writeFloat(pBlinkElapsed)
	end
end
