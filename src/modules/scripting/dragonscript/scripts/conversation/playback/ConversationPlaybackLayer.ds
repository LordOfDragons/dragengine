/* 
 * Drag[en]gine DragonScript Script Module
 *
 * Copyright (C) 2020, Roland Pl√ºss (roland@rptd.ch)
 * 
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation; either 
 * version 2 of the License, or (at your option) any later 
 * version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */


namespace Dragengine.ConversationSystem

pin Dragengine.LoadSave


/**
 * \brief Layer in a conversation playback.
 * 
 */
class ConversationPlaybackLayer
	var ConversationActionIterator pActionIterator
	var ConversationAction pNextAction
	var ConversationCondition pLoopCondition
	var float pLoopEvalConditionInterval
	var bool pLooping
	var bool pTopicTopLevel
	
	
	
	/**
	 * \brief Create a new layer.
	 * 
	 * Sets the next action to the first iterator action and advances the iterator.
	 */
	func new(ConversationActionIterator iterator) this(iterator, true)
	end
	
	/**
	 * \brief Create a new layer.
	 * 
	 * \param iterator Action iterator to use.
	 * \param advance If \em true sets the next action to the first iterator action and
	 *                advances the iterator. If \em false the iterator is not advanced
	 *                and the next action is set to \em null.
	 */
	func new(ConversationActionIterator iterator, bool advance)
		if iterator == null
			throw EInvalidParam.new()
		end
		
		pActionIterator = iterator
		pLoopEvalConditionInterval = 0.2
		pLooping = false
		pTopicTopLevel = false
		
		if advance
			pNextAction = iterator.getNext()
		end
	end
	
	
	
	/** \brief Loop condition or \em null if always true. */
	func ConversationCondition getLoopCondition()
		return pLoopCondition
	end
	
	/** \brief Set loop condition or \em null if always true. */
	func void setLoopCondition(ConversationCondition condition)
		pLoopCondition = condition
	end
	
	/** \brief Interval to wait before testing the condition again to improve performance. */
	func float getLoopEvalConditionInterval()
		return pLoopEvalConditionInterval
	end
	
	/** \brief Set interval to wait before testing the condition again to improve performance. */
	func void setLoopEvalConditionInterval(float interval)
		pLoopEvalConditionInterval = DEMath.max(interval, 0.0)
	end
	
	/** \brief Actions are looping. */
	func bool getLooping()
		return pLooping
	end
	
	/** \brief Set actions are looping. */
	func void setLooping(bool looping)
		pLooping = looping
	end
	
	/** \brief Belongs to top level of a topic. */
	func bool getTopicTopLevel()
		return pTopicTopLevel
	end
	
	/** \brief Set if layer belongs to top level of a topic. */
	func void setTopicTopLevel(bool topicTopLevel)
		pTopicTopLevel = topicTopLevel
	end
	
	
	
	/** \brief Advance to the next action if possible. */
	func void advance()
		pNextAction = pActionIterator.getNext()
		
		if pNextAction == null and pLooping
			forwardFirst()
		end
	end
	
	/** \brief Next action or \em null if at the end of the current list. */
	func ConversationAction getNextAction()
		return pNextAction
	end
	
	/** \brief Not at end of list. */
	func bool hasNextAction()
		return pNextAction != null
	end
	
	/** \brief Forward to first action. */
	func void forwardFirst()
		pActionIterator.first()
		pNextAction = pActionIterator.getNext()
	end
	
	/** \brief Forward to last action. */
	func void forwardLast()
		pActionIterator.last()
		pNextAction = pActionIterator.getNext()
	end
	
	/** \brief Forward to end. */
	func void forwardEnd()
		pActionIterator.onePastLast()
		pNextAction = null
	end
	
	/** \brief Cancel looping. */
	func void cancelLooping()
		pLooping = false
		pLoopCondition = null
		pActionIterator.onePastLast()
		pNextAction = null
	end
	
	
	
	/** \brief Read layer from file. */
	public static func ConversationPlaybackLayer readFromFile(PersistencyEnvironment env, FileReader reader)
		select reader.readByte() // version
		case 0
			var ConversationActionIterator iterator = ConversationActionIterator.readFromFile(env, reader)
			iterator.previous() // we have to go back by one since constructor calls advance()
			var ConversationPlaybackLayer layer = ConversationPlaybackLayer.new(iterator)
			
			var PersistencyFlags flags = PersistencyFlags.new(2, reader)
			layer.pLooping = flags.getAt(0)
			layer.pTopicTopLevel = flags.getAt(1)
			
			layer.pLoopCondition = env.readObjectOrNull(reader) cast ConversationCondition
			layer.pLoopEvalConditionInterval = reader.readFloat()
			
			return layer
			
		else
			throw EInvalidParam.new("unsupported version")
		end
	end
	
	/** \brief Write layer to file. */
	func void writeToFile(PersistencyEnvironment env, FileWriter writer)
		writer.writeByte(0) // version
		
		pActionIterator.writeToFile(env, writer)
		
		var PersistencyFlags flags = PersistencyFlags.new(2)
		flags.setAt(0, pLooping)
		flags.setAt(1, pTopicTopLevel)
		flags.writeToFile(writer)
		
		env.writeObjectOrNull(writer, pLoopCondition)
		writer.writeFloat(pLoopEvalConditionInterval)
	end
end
