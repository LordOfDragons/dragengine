/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

namespace Dragengine.ConversationSystem

pin Dragengine.Gui
pin Dragengine.LoadSave
pin Dragengine.Scenery
pin Dragengine.TriggerSystem
pin Dragengine.Utils


/**
 * \brief Play back conversation.
 */
abstract class ConversationPlayback implements Persistable
	private var Conversation pConversation
	private var ConversationTopicGroup pTopicGroup
	private var ConversationTopic pTopic
	private var Array pActors
	private var Array pCoordSystems
	private var ConversationCameraDirector pCameraDirector
	private var Dictionary pVariables
	private var Array pLayers
	private var bool pActionWaiting
	private var float pActionTime
	private var bool pRunning
	private var bool pPaused
	private var bool pEnableFastForwardSpeaking
	private var ConversationPlaybackSubTitle pSubTitle
	private var ConversationPlaybackPlayerChoice pPlayerChoice
	private var TranslationManager pTranslationManager
	private var Array pListeners
	
	
	
	/** \brief Create conversation playback. */
	public func new(Conversation conversation)
		if conversation == null
			throw EInvalidParam.new()
		end
		
		pConversation = conversation
		pActors = Array.new()
		pCoordSystems = Array.new()
		pVariables = Dictionary.new()
		pLayers = Array.new()
		pActionTime = 0.0
		pActionWaiting = false
		pRunning = false
		pPaused = false
		pEnableFastForwardSpeaking = false
		pListeners = Array.new()
		
		var BaseGameApp app = BaseGameApp.getApp()
		if app != null
			pTranslationManager = app.getTranslationManager()
		end
	end
	
	/** \brief Dispose of conversation playback. */
	public func void dispose()
		setRunning(false)
		removeAllLayers()
		removeAllVariables()
		removeAllCoordSystems()
		removeAllActors()
		pListeners = null
		pPlayerChoice = null
		pSubTitle = null
		pCameraDirector = null
		pTopic = null
		pTopicGroup = null
		pConversation = null
	end
	
	
	
	/**
	 * \brief Read from file.
	 * 
	 * This call loads only data not accessing subclass implemented methods.
	 * To finish loading call readDelayedFromFile().
	 * 
	 * The typical factory call would look like this:
	 * 
	 * \code{.ds}
	 * public func Persistable readObjectFromFile(PersistencyEnvironment env, FileReader reader)
	 *    var MyConversationPlayback playback = MyConversationPlayback.new(env, reader)
	 *    playback.readDelayedFromFile(env, reader)
	 *    return playback
	 * end
	 * \endcode
	 * 
	 * These objects are not persisted. Subclass is responsible to set them.
	 * - CameraDirector
	 * - SubTitle
	 * - pPlayerChoice
	 * 
	 * Subclass is usually not required to store additional data except initializing
	 * the above mentioned.
	 */
	public func new(PersistencyEnvironment env, FileReader reader)
		pActors = Array.new()
		pCoordSystems = Array.new()
		pListeners = Array.new()
		
		var BaseGameApp app = BaseGameApp.getApp()
		if app != null
			pTranslationManager = app.getTranslationManager()
		end
		
		select reader.readByte() // version
		case 0
			var int i, count
			var String path
			var StringID id
			
			path = env.readString16OrNullIfEmpty(reader)
			if path != null
				var LoadConversation loadConversation = env.getVariable(\
					PersistencyEnvironment.varLoadConversation) cast LoadConversation
				pConversation = loadConversation.loadFromFile(path)
			end
			
			id = env.readStringIDOrNullIfEmpty(reader)
			if id != null
				pTopicGroup = pConversation.getTopicGroupWithID(id)
			end
			
			id = env.readStringIDOrNullIfEmpty(reader)
			if id != null
				pTopic = pTopicGroup.getTopicWithID(id)
			end
			
			var String variableName
			var int variableValue
			count = reader.readUShort()
			pVariables = Dictionary.new()
			for i = 0 to count
				variableName = reader.readString8()
				variableValue = reader.readInt()
				pVariables.setAt(variableName, variableValue)
			end
			
			count = reader.readUShort()
			pLayers = Array.new()
			for i = 0 to count
				pLayers.add(ConversationPlaybackLayer.readFromFile(env, reader))
			end
			
			var PersistencyFlags flags = PersistencyFlags.new(4, reader)
			pActionWaiting = flags.getAt(0)
			pRunning = flags.getAt(1)
			pPaused = flags.getAt(2)
			pEnableFastForwardSpeaking = flags.getAt(3)
			
			pActionTime = reader.readFloat()
			
		else
			throw EInvalidParam.new("unsupported version")
		end
	end
	
	/**
	 * \brief Read data from file accessing subclass implemented methods.
	 * 
	 * Call after subclass is properly constructed. Subclass usually does not
	 * require to overwrite this method.
	 */
	public func void readDelayedFromFile(PersistencyEnvironment env, FileReader reader)
		select reader.readByte() // version
		case 0
			var ConversationActor actor
			var int i, count = reader.readUShort()
			for i = 0 to count
				actor = loadConversationActor(StringID.new(reader.readString8()))
				addActor(actor, actor.getAliasID())
			end
			
			var ConversationCoordSystem coordSystem
			count = reader.readUShort()
			for i = 0 to count
				coordSystem = createConversationCoordSystem(StringID.new(reader.readString8()))
				coordSystem.readFromFile(env, reader)
				addCoordSystem(coordSystem, coordSystem.getAliasID())
			end
			
			// restore object links that can only be restored once the parent playback is present
			pActors.forEach(block ConversationActor each
				each.playbackRestoreObjectLinks()
			end)
			
			// ConversationCameraDirector pCameraDirector
			// ConversationPlaybackSubTitle pSubTitle
			// ConversationPlaybackPlayerChoice pPlayerChoice
			
		else
			throw EInvalidParam.new("unsupported version")
		end
	end
	
	
	
	/** \brief Conversation. */
	public func Conversation getConversation()
		return pConversation
	end
	
	/** \brief Topic group being talking about. */
	public func ConversationTopicGroup getTopicGroup()
		return pTopicGroup
	end
	
	/** \brief Topic being talking about. */
	public func ConversationTopic getTopic()
		return pTopic
	end
	
	/** \brief Set topic to talk about. */
	public func void setTopic(ConversationTopicGroup group, ConversationTopic topic)
		pTopicGroup = group
		pTopic = topic
		
		removeAllLayers()
		pActionTime = 0
		pActionWaiting = true
		
		if topic == null
			setPaused(false)
			setRunning(false)
		end
		
		advanceToNextAction()
	end
	
	/** \brief Playback is running. */
	public func bool getRunning()
		return pRunning
	end
	
	/** \brief Set if playback is running. */
	public func void setRunning(bool running)
		if pTopic == null
			running = false
		end
		
		if running == pRunning
			return
		end
		
		pRunning = running
		
		if running
			update(0.0) // ensure first action is activated at the first frame
			
		else
			clearDoneActorSubTitles()
		end
		
		notifyRunningChanged()
		
		if running
			onConversationStarted()
			
		else
			onConversationStopped()
		end
	end
	
	/** \brief Playback is paused. */
	public func bool getPaused()
		return pPaused
	end
	
	/** \brief Set if playback is paused. */
	public func void setPaused(bool paused)
		pPaused = paused
	end
	
	/** \brief Enabling calling fastForwardSpeaking() to be allowed. */
	public func bool getEnableFastForwardSpeaking()
		return pEnableFastForwardSpeaking
	end
	
	/** \brief Set if calling fastForwardSpeaking() is allowed. */
	public func void setEnableFastForwardSpeaking(bool enable)
		pEnableFastForwardSpeaking = enable
	end
	
	
	
	/** \brief Number of actors. */
	public func int getActorCount()
		return pActors.getCount()
	end
	
	/** \brief Actor by index. */
	public func ConversationActor getActorAt(int index)
		return pActors.getAt(index) cast ConversationActor
	end
	
	/** \brief Actor with ID or number or null if absent. */
	public func ConversationActor getActorMatching(StringID id)
		return pActors.find(block ConversationActor each
			return id.equals(each.getAliasID()) or each.getID().equals(id)
		end) cast ConversationActor
	end
	
	/** \brief Add actor with no alias if absent. */
	public func void addActor(ConversationActor actor)
		addActor(actor, null)
	end
	
	/** \brief Add actor with alias if absent. */
	public func void addActor(ConversationActor actor, StringID alias)
		if pActors.has(actor)
			return
		end
		
		if actor.getPlayback() != null
			throw EInvalidParam.new()
		end
		
		pActors.add(actor)
		
		if alias == null or alias.toString().empty()
			actor.setAliasID(null)
			
		else
			actor.setAliasID(alias)
		end
		
		actor.setPlayback(this)
		
	end
	
	/** \brief Remove actor if present. */
	public func void removeActor(ConversationActor actor)
		if not pActors.has(actor)
			return
		end
		
		actor.setRemainingSpeechTime(0)
		actor.setSubTitleText(null) // hide timer takes care of it if present
		
		pActors.remove(actor)
		actor.setPlayback(null)
	end
	
	/** \brief Remove all actors. */
	public func void removeAllActors()
		pActors.forEach(block ConversationActor each
			each.setPlayback(null)
		end)
		
		pActors.removeAll()
	end
	
	/**
	 * \brief Clear sub title from all actors done speaking.
	 * 
	 * This only remove the sub title from affected actors. The sub title text itself is
	 * not removed from the sub title box. If you want to clear the sub title box call
	 * getSubTitle().removeAllSubTitleText().
	 */
	public func void clearDoneActorSubTitles()
		pActors.forEach(block ConversationActor each
			if not each.isSpeaking()
				each.setSubTitleText(null)
			end
		end)
	end
	
	/** \brief Visit actors with block with parameter ConversationActor. */
	public func void forEachActor(Block ablock)
		pActors.forEach(ablock)
	end
	
	
	
	/** \brief Number of coordinate systems. */
	public func int getCoordSystemCount()
		return pCoordSystems.getCount()
	end
	
	/** \brief Coordinate system with ID or <em null if absent. */
	public func ConversationCoordSystem getCoordSystemByID(StringID id)
		return pCoordSystems.find(block ConversationCoordSystem each
			return id.equals(each.getAliasID()) or each.getID().equals(id)
		end) cast ConversationCoordSystem
	end
	
	/** \brief Add coordinate system without alias if absent. */
	public func void addCoordSystem(ConversationCoordSystem coordSystem)
		addCoordSystem(coordSystem, null)
	end
	
	/** \brief Add coordinate system with alias if absent. */
	public func void addCoordSystem(ConversationCoordSystem coordSystem, StringID alias)
		if pCoordSystems.has(coordSystem)
			return
		end
		
		if alias == null or alias.toString().empty()
			coordSystem.setAliasID(null)
			
		else
			coordSystem.setAliasID(alias)
		end
		
		pCoordSystems.add(coordSystem)
	end
	
	/** \brief Remove coordinate system if present. */
	public func void removeCoordSystem(ConversationCoordSystem coordSystem)
		if pCoordSystems.has(coordSystem)
			pCoordSystems.remove(coordSystem)
		end
	end
	
	/** \brief Remove all coordinate systems. */
	public func void removeAllCoordSystems()
		pCoordSystems.removeAll()
	end
	
	/** \brief Visit coordinate systems with block with parameter ConversationCoordSystem. */
	public func void forEachCoordSystem(Block ablock)
		pCoordSystems.forEach(ablock)
	end
	
	
	
	/** \brief Camera director or \em null. */
	public func ConversationCameraDirector getCameraDirector()
		return pCameraDirector
	end
	
	/** \brief Set camera director or \em null. */
	public func void setCameraDirector(ConversationCameraDirector director)
		pCameraDirector = director
	end
	
	
	
	/** \brief Variable is set. */
	public func bool hasVariable(String name)
		return pVariables.has(name)
	end
	
	/** \brief Variable value or default value if not set */
	public func int getVariable(String name, int defaultValue)
		return pVariables.getAt(name, defaultValue) cast int
	end
	
	/** \brief Set variable. */
	public func void setVariable(String name, int value)
		pVariables.setAt(name, value)
	end
	
	/** \brief Remove variable if set. */
	public func void removeVariable(String name)
		pVariables.removeIfExisting(name)
	end
	
	/** \brief Remove all variables. */
	public func void removeAllVariables()
		pVariables.removeAll()
	end
	
	
	
	/** \brief Sub title or \em null. */
	public func ConversationPlaybackSubTitle getSubTitle()
		return pSubTitle
	end
	
	/** \brief Set sub title or \em null. */
	public func void setSubTitle(ConversationPlaybackSubTitle subTitle)
		pSubTitle = subTitle
	end
	
	/** \brief Player choice interface or \em null. */
	public func ConversationPlaybackPlayerChoice getPlayerChoice()
		return pPlayerChoice
	end
	
	/** \brief Set player choice interface or \em null. */
	public func void setPlayerChoice(ConversationPlaybackPlayerChoice playerChoice)
		pPlayerChoice = playerChoice
	end
	
	/**
	 * \brief Translation manager or null.
	 * \version 1.16
	 */
	public func TranslationManager getTranslationManager()
		return pTranslationManager
	end
	
	/**
	 * \brief Set translation manager or null.
	 * \version 1.16
	 */
	public func void setTranslationManager(TranslationManager translationManager)
		pTranslationManager = translationManager
	end
	
	
	
	/** \brief Update playback. */
	public func void update(float elapsed)
		if not pPaused
			processActions(elapsed, false)
		end
		
		if pCameraDirector != null
			pCameraDirector.advanceCameraTime(elapsed)
		end
	end
	
	/** \brief Process actions. */
	public func void processActions(float elapsed, bool skipDelay)
		// decrement the remaining speech time of all actors
		pActors.forEach(block ConversationActor each
			each.decrementRemainingSpeechTime(elapsed)
		end)
		
		// loop until there are no more actions able to be processed in elapsed time
		var ConversationPlaybackLayer layer
		var ConversationCondition condition
		var ConversationAction action
		var int i
		
		while true
			action = null
			
			// check if any stack entry upwards contains a condition evaluating to false. in
			// this case all actions up to this level are cancelled. in particular this means
			// if two looping conditions are nested and the outer condition becomes false then
			// control passes outside the outer layer. this also means top-level layer
			// boundaries are skiped so be careful how you nest conditional loops
			for i = pLayers.getCount() - 1 downto 0
				layer = pLayers.getAt(i) cast ConversationPlaybackLayer
				
				condition = layer.getLoopCondition()
				if condition != null and not condition.evaluate(this)
					layer.cancelLooping()
					pLayers.resize(i + 1)
					pActionTime = 0
					pActionWaiting = true
					break
				end
			end
			
			// determine the next action
			if pLayers.getCount() > 0
				layer = getTopLayer()
				action = getTopLayer().getNextAction()
				
				// special case. it is possible the stack entry is looping but contains no actions.
				// in this case skip processing until a change comes from the outside world
				if action == null and layer.getLooping()
					return
				end
			end
			
			// if there is a next action process it
			if action != null
				// check for waiting conditions
				if pActionWaiting
					if action.getWaitForActor()
						var bool useActorWait = not action.getWaitSpeakOnly()
						var bool notDone = false
						
						if action.getWaitForActorID() != null
							var ConversationActor actor = getActorMatching(\
								StringID.new(action.getWaitForActorID()))
							if actor != null
								notDone = actor.isSpeaking() or (useActorWait and actor.wait())
							end
							
						else
							notDone = pActors.find(block ConversationActor each
								return each.isSpeaking() or (useActorWait and each.wait())
							end) != null
						end
						
						if notDone
							return
						end
					end
					
					pActionWaiting = false
				end
				
				// wait the delay time then process the action
				if skipDelay
					pActionTime = action.getDelay()
					
				else
					pActionTime += elapsed
				end
				
				if pActionTime >= action.getDelay()
					action.execute(this)
					pActionTime = 0
					pActionWaiting = true
					
				else
					return // end the loop
				end
				
			// if there is no next action this can be either because a looping action has no actions or
			// we actually arrive at the end of the conversation.
			else
				if pLayers.getCount() > 1
					// looping action without actions. advance to the next action in the stack below
					advanceToNextAction()
					
				else
					// end of conversation. wait for all actors to be done speaking and exit the loop
					var bool notDone = false
					
					notDone = (pActors.find(block ConversationActor each
						return each.isSpeaking()
					end) != null)
					
					if not notDone
						setRunning(false)
					end
					
					return
				end
			end
		end
	end
	
	/** \brief Advance to next action. */
	public func void advanceToNextAction()
		if pLayers.getCount() == 0
			if pTopic == null
				setRunning(false)
				
			else
				var ConversationPlaybackLayer layer = ConversationPlaybackLayer.new(pTopic.getIteratorActions())
				layer.setTopicTopLevel(true)
				pLayers.add(layer)
			end
			
		else
			while true
				var ConversationPlaybackLayer layer = getTopLayer()
				
				layer.advance()
				
				if layer.hasNextAction()
					pActionWaiting = true
					pActionTime = 0
					break
				end
				
				if pLayers.getCount() < 2
					break
				end
				
				popLayer()
			end
		end
	end
	
	/**
	 * \brief Fast forward until the actor stopped speaking.
	 * 
	 * Used by ConversationInputProcessor to allow player to skip dialog.
	 * Use setEnableFastForwardSpeaking() to allow/deny fast forwarding. If complex and timed
	 * conversation parts are used disabling fast forward speaking should be disabled to avoid
	 * conversation scripts breaking.
	 */
	public func void fastForwardSpeaking()
		if pTopic == null or not pRunning or not pEnableFastForwardSpeaking
			return
		end
		
		var float timeToForward = 0
		var float timeStep = 0.1
		var ConversationActor actor
		var Speaker speaker
		var float actorTime
		var float subStep
		
		var ConversationPlaybackLayer layer = getTopLayer()
		if layer.hasNextAction()
			timeToForward = DEMath.max(layer.getNextAction().getDelay() - pActionTime, 0.0)
		end
		
		var int i, count= pActors.getCount()
		for i = 0 to count
			actor = pActors.getAt(i) cast ConversationActor
			
			speaker = actor.getVoiceSpeaker()
			if speaker == null
				continue
			end
			
			/* // getPlayPosition missing
			if speaker.getPlaying()
				var Sound sound = speaker.getSound()
				if sound != null
					actorTime = ((speaker.getPlayTo() - speaker.getPlayPosition()) cast float) \
						/ (sound.getSampleRate() cast float)
				end
				
				timeToForward = DEMath.max(timeToForward, actorTime)
			end
			*/
			
			actorTime = actor.getRemainingSpeechTime()
			timeToForward = DEMath.max(timeToForward, actorTime)
			
			// this not correct but should work in the most cases. correctly the speaker of each actor
			// has to be advanced properly but if somebody skips chances are slim this actually would
			// be noticed. so all voice audio of all actors is simply stopped here
			speaker.stop()
			speaker.setSound(null)
		end
		
		while timeToForward > 0.00001
			subStep = DEMath.min(timeStep, timeToForward)
			
			pActors.forEach(block ConversationActor each
				if each.getSpeechAnimationPlayback() != null
					each.getSpeechAnimationPlayback().update(subStep)
				end
			end)
			
			processActions(subStep, true)
			
			timeToForward -= timeStep
		end
	end
	
	/** \brief Cancel looping layer removing all layers below. */
	public func void cancelLoopingLayer(ConversationPlaybackLayer layer)
		var int i
		
		for i = pLayers.getCount() - 1 downto 0
			if pLayers.getAt(i) == layer
				layer.cancelLooping()
				pLayers.resize(i + 1)
				pActionTime = 0
				pActionWaiting = true
				return
			end
		end
		
		throw EInvalidParam.new()
	end
	
	
	
	/** \brief Number of layers. */
	public func int getLayerCount()
		return pLayers.getCount()
	end
	
	/** \brief Top layer. */
	public func ConversationPlaybackLayer getTopLayer()
		return pLayers.getAt(pLayers.getCount() - 1) cast ConversationPlaybackLayer
	end
	
	/** \brief Push layer to top of stack. */
	public func void pushLayer(ConversationPlaybackLayer layer)
		if layer == null
			throw EInvalidParam.new()
		end
		pLayers.add(layer)
	end
	
	/** \brief Pop top layer off stack. */
	public func void popLayer()
		pLayers.removeFrom(pLayers.getCount() - 1)
	end
	
	/** \brief Next action is present. */
	public func bool hasNextAction()
		return pLayers.getCount() > 0 and getTopLayer().hasNextAction()
	end
	
	/**
	 * \brief Next action or \em null if top layer is finished.
	 * \version 1.16
	 */
	public func ConversationAction getNextAction()
		return hasNextAction() if getTopLayer().getNextAction() else null
	end
	
	/** \brief Remove all layers. */
	public func void removeAllLayers()
		pLayers.removeAll()
	end
	
	/** \brief Stop conversation. */
	public func void stopConversation()
		pLayers.removeAll()
		pActionWaiting = false
		pActionTime = 0
		setRunning(false)
	end
	
	/**
	 * \brief Waiting for action to begin.
	 * \version 1.16
	 */
	public func bool getWaitingForAction()
		return pActionWaiting
	end
	
	/**
	 * \brief Elapsed action waiting time in seconds.
	 * \version 1.16
	 */
	public func float getElapsedActionWaiting()
		return pActionTime
	end
	
	
	
	/** \brief Add listener. */
	public func void addListener(ConversationPlaybackListener listener)
		if not pListeners.has(listener)
			pListeners.add(listener)
		end
	end
	
	/** \brief Remove listener if present. */
	public func void removeListener(ConversationPlaybackListener listener)
		if pListeners.has(listener)
			pListeners.remove(listener)
		end
	end
	
	/** \brief Notify listeners running state changed. */
	public func void notifyRunningChanged()
		if pListeners == null
			return // can happen if somebody disposed of us very quickly
		end
		
		pListeners.forEach(block ConversationPlaybackListener each
			each.runningChanged(this)
		end)
	end
	
	
	
	/**
	 * \brief Obtain actor for a conversation identifier.
	 * 
	 * This is used by readFromFile to add actors for playing back the conversation.
	 * Implement to return the actors matching a conversation identifier.
	 */
	abstract public func ConversationActor loadConversationActor(StringID id)
	
	/**
	 * \brief Create coordinate system for a conversation identifier.
	 * 
	 * This is used by readFromFile to add coordinate system for playing back the
	 * conversation. Subclass to create the coordinate system matching a
	 * conversation identifier.
	 */
	abstract public func ConversationCoordSystem createConversationCoordSystem(StringID id)
	
	/**
	 * \brief Obtain trigger table to use.
	 * 
	 * Implement to return the trigger table.
	 */
	abstract public func TSTriggerTable getTriggerTable()
	
	/**
	 * \brief Game command send by the conversation script.
	 * 
	 * Overwrite to make the game execute the action. The default implementation does nothing.
	 */
	public func void gameCommand(String command)
	end
	
	/**
	 * \brief Game condition command send by the conversation script.
	 * 
	 * Overwrite to make the game evaluate the command returning true or false as result.
	 * The default implementation returns false.
	 */
	public func bool conditionGameCommand(String command)
		return false
	end
	
	/**
	 * \brief Switch music.
	 * 
	 * Overwrite to make the game change music. The default implementation does nothing.
	 */
	public func void changeMusic(String music)
	end
	
	/**
	 * \brief Conversation started hook method.
	 * 
	 * Called if running state changed to true after sending notifications to listeners.
	 */
	public func void onConversationStarted()
	end
	
	/**
	 * \brief Conversation stopped hook method.
	 * 
	 * Called if running state changed to false after sending notifications to listeners.
	 */
	public func void onConversationStopped()
	end
	
	
	
	/**
	 * \brief Name of PersistencyFactory required to load object from file.
	 * 
	 * Name of PersistencyFactory is first written to the file as string with
	 * 8-bit length. Then writeToFile() is called to write the object itself.
	 * Empty name is not allowed as is names longer than 255 characters.
	 * Name has to match a PersistencyFactory present in the Persistency
	 * instance used for loading objects. Object is read using
	 * PersistencyFactory.readObjectFromFile() of the matching PersistencyFactory.
	 */
	public func String persistencyFactoryName()
		return null
	end
	
	/**
	 * \brief Write object to file writer.
	 * 
	 * This method supports reading object using constructor and readDelayedFromFile().
	 * Subclass has to overwrite writeObjectConstructToFile() and writeObjectDelayedToFile().
	 * This method should not be changed.
	 */
	public func void writeObjectToFile(PersistencyEnvironment env, FileWriter writer)
		writeObjectConstructToFile(env, writer)
		writeObjectDelayedToFile(env, writer)
	end
	
	/**
	 * \brief Write object data to file writer read during construction time.
	 * 
	 * Writes all data which are read during construction time not accessing
	 * subclass implemented methods. This affects besides others the use of
	 * loadConversationActor() and createConversationCoordSystem().
	 * 
	 * Subclass usually does not required to overwrite this method.
	 */
	public func void writeObjectConstructToFile(PersistencyEnvironment env, FileWriter writer)
		writer.writeByte(0) // version
		
		writer.writeString16(pConversation != null if pConversation.getPathFile() else "")
		writer.writeString8(pTopicGroup != null if pTopicGroup.getID().toString() else "")
		writer.writeString8(pTopic != null if pTopic.getID().toString() else "")
		
		writer.writeUShort(pVariables.getCount())
		pVariables.forEach(block String name, int value
			writer.writeString8(name)
			writer.writeInt(value)
		end)
		
		writer.writeUShort(pLayers.getCount())
		pLayers.forEach(block ConversationPlaybackLayer each
			each.writeToFile(env, writer)
		end)
		
		var PersistencyFlags flags = PersistencyFlags.new(4)
		flags.setAt(0, pActionWaiting)
		flags.setAt(1, pRunning)
		flags.setAt(2, pPaused)
		flags.setAt(3, pEnableFastForwardSpeaking)
		flags.writeToFile(writer)
		
		writer.writeFloat(pActionTime)
	end
	
	/**
	 * \brief Write object data to file writer read during readDelayedFromFile.
	 * 
	 * Writes all data which are read from inside readDelayedFromFile() accessing
	 * subclass implemented methods. This affects besides others the use of
	 * loadConversationActor() and createConversationCoordSystem().
	 * 
	 * Subclass usually does not required to overwrite this method.
	 */
	public func void writeObjectDelayedToFile(PersistencyEnvironment env, FileWriter writer)
		writer.writeByte(0) // version
		
		writer.writeUShort(pActors.getCount())
		pActors.forEach(block ConversationActor each
			writer.writeString8(each.getID().toString())
		end)
		
		writer.writeUShort(pCoordSystems.getCount())
		pCoordSystems.forEach(block ConversationCoordSystem each
			each.writeToFile(env, writer)
		end)
		
		// ConversationCameraDirector pCameraDirector
		// ConversationPlaybackPlayerChoice pPlayerChoice
		
		// SubTitle: handled by actors adding their text boxes while loading
	end
end
