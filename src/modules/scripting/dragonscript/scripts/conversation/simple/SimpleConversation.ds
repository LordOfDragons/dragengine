/*
 * MIT License
 *
 * Copyright (C) 2024, DragonDreams GmbH (info@dragondreams.ch)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

namespace Dragengine.ConversationSystem


/**
 * \brief Simple conversation.
 * \version 1.25
 * 
 * Simple conversations allow to define quickly a conversation for use with the conversation
 * system which is based on a simplified XML file. Regular conversations are powerful but
 * can be tedious and time consuming for simple conversations which are not important nor
 * complex. In a simple conversation the actors and the text they are speaking is mainly
 * defined. Between switching actors talking random camera shot changes are added. Furthermore
 * simple gestures can be easily defined right inside the text. See
 * \ref LoadSave.LoadSimpleConversation for an example XML definition.
 */
class SimpleConversation
	var String pPathFile
	var Dictionary pCameras, pActors, pSnippets
	
	
	/** \brief Create simple conversation. */
	func new(String pathFile)
		pPathFile = pathFile
		pCameras = Dictionary.new()
		pActors = Dictionary.new()
		pSnippets = Dictionary.new()
	end
	
	/** \brief Create deep copy of simple conversation. */
	func new(SimpleConversation conversation)
		pPathFile = conversation.pPathFile
		pCameras = conversation.pCameras.map(block SimpleConversationCamera each
			return SimpleConversationCamera.new(each)
		end)
		pActors = conversation.pActors.map(block SimpleConversationActor each
			return SimpleConversationActor.new(each)
		end)
		pSnippets = conversation.pSnippets.map(block SimpleConversationSnippet each
			return SimpleConversationSnippet.new(each)
		end)
	end
	
	
	/** \brief Path simple conversation has been loaded from or null if manually build. */
	func String getPathFile()
		return pPathFile
	end
	
	
	/** \brief Count of cameras. */
	func int getCameraCount()
		return pCameras.getCount()
	end
	
	/** \brief Camera with identifier or null. */
	func SimpleConversationCamera getCameraWith(StringID identifier)
		return pCameras.getAt(identifier, null) cast SimpleConversationCamera
	end
	
	/**
	 * \brief Visit cameras with block.
	 * 
	 * Block is required to have signature void(SimpleConversationCamera camera) or
	 * void(int index, SimpleConversationCamera camera).
	 */
	func void forEachCamera(Block ablock)
		pCameras.forEachValue(ablock)
	end
	
	/**
	 * \brief Add camera.
	 * 
	 * If camera with same name exists it is replaced.
	 */
	func void addCamera(SimpleConversationCamera camera)
		if camera == null
			throw ENullPointer.new("camera")
		end
		pCameras.setAt(camera.getId(), camera)
	end
	
	
	/** \brief Count of actors. */
	func int getActorCount()
		return pActors.getCount()
	end
	
	/** \brief Actor with identifier or null. */
	func SimpleConversationActor getActorWith(StringID identifier)
		return pActors.getAt(identifier, null) cast SimpleConversationActor
	end
	
	/**
	 * \brief Visit actors with block.
	 * 
	 * Block is required to have signature void(SimpleConversationActor actor) or
	 * void(int index, SimpleConversationActor actor).
	 */
	func void forEachActor(Block ablock)
		pActors.forEachValue(ablock)
	end
	
	/**
	 * \brief Add actor.
	 * 
	 * If actor with same name exists it is replaced.
	 */
	func void addActor(SimpleConversationActor actor)
		if actor == null
			throw ENullPointer.new("actor")
		end
		pActors.setAt(actor.getId(), actor)
	end
	
	
	/** \brief Count of snippets. */
	func int getSnippetCount()
		return pSnippets.getCount()
	end
	
	/** \brief Snippet with identifier or null. */
	func SimpleConversationSnippet getSnippetWith(StringID identifier)
		return pSnippets.getAt(identifier, null) cast SimpleConversationSnippet
	end
	
	/**
	 * \brief Visit snippets with block.
	 * 
	 * Block is required to have signature void(SimpleConversationSnippet snippet) or
	 * void(int index, SimpleConversationSnippet snippet).
	 */
	func void forEachSnippet(Block ablock)
		pSnippets.forEachValue(ablock)
	end
	
	/**
	 * \brief Add snippet.
	 * 
	 * If snippet with same name exists it is replaced.
	 */
	func void addSnippet(SimpleConversationSnippet snippet)
		if snippet == null
			throw ENullPointer.new("snippet")
		end
		pSnippets.setAt(snippet.getId(), snippet)
	end
	
	
	/**
	 * \brief Import simple conversation.
	 * \warning Imported elements are shared. Do not change them.
	 */
	func void import(SimpleConversation conversation)
		conversation.forEachCamera(block SimpleConversationCamera each
			pCameras.setAt(each.getId(), each)
		end)
		conversation.forEachActor(block SimpleConversationActor each
			pActors.setAt(each.getId(), each)
		end)
		conversation.forEachSnippet(block SimpleConversationSnippet each
			pSnippets.setAt(each.getId(), each)
		end)
	end
	
	/**
	 * \brief Import translation simple conversation.
	 * \warning Imported elements are shared. Do not change them.
	 * 
	 * Similar to \ref #import() but used to import a simple conversation containing translations.
	 * 
	 * Only snippets are imported with this function. The imported snippets are only used as
	 * translations to modify the text content of existing snippets. If a snippet exists it is
	 * first duplicated to allow making changes safely.
	 * 
	 * The actions in the snippet are then visited and only actions of type
	 * \ref SimpleConversationAction.Type#speak are modified. The text content of the respective
	 * imported snippet speak type action is assigned to the modified action. For this to work
	 * the translation snippet is required to have the same count of speak type actions in the
	 * same order. Since only speak type actions are used for translation any other actions are
	 * ignored. It is thus only required to include the speak type actions in a translation
	 * snippet. This simplifies the process of creating translation simple conversations.
	 * 
	 * Importaint translated text can the done in two modes: partial or full.
	 * 
	 * \par Full translation mode
	 * 
	 * Full translation assigns translated action text as modified action text and translated
	 * animation text as modified action animation text. This mode is useful if the
	 * \ref SpeechAnimations.SpeechAnimation used by the \ref ConversationActor is also translated.
	 * If this is not the case the translated words are not found and no speech animation can be
	 * done. If this is the case use partial mode instead.
	 * 
	 * \par Partial translation mode
	 * 
	 * Partial translation first assigns modified action text to modified action animation text
	 * if modified action animation text is null. Then translated action text is assigned as
	 * modified action text. This has the effect that untranslated text is used as animation text
	 * no matter if manually assigned or not. This ensures that untranslated
	 * \ref SpeechAnimations.SpeechAnimation keep working with the modified actions while the
	 * text displayed to the user is translated.
	 * 
	 * Using partial translation mode is faster and required less work since only the text has
	 * to be translated not entire speech animations.
	 */
	func void importTranslation(SimpleConversation conversation, bool fullTranslationMode)
		var StringID id
		var SimpleConversationSnippet snippet
		conversation.forEachSnippet(block SimpleConversationSnippet each
			id = each.getId()
			snippet = pSnippets.getAt(id, null) cast SimpleConversationSnippet
			if snippet == null
				throw EInvalidParam.new("snippet to translate not found: " + id)
			end
			pSnippets.setAt(id, translateSnippet(snippet, each, fullTranslationMode))
		end)
	end
	
	/**
	 * \brief Translate snippet.
	 * \see #importTranslation(SimpleConversation,bool)
	 * 
	 * Returns modified snippet which is a copy of snippet.
	 */
	func SimpleConversationSnippet translateSnippet(SimpleConversationSnippet snippet,\
	SimpleConversationSnippet translated, bool fullTranslationMode)
		var SimpleConversationSnippet modified = SimpleConversationSnippet.new(snippet)
		
		var int indexTra, countTra = translated.getActionCount()
		var SimpleConversationAction traAction
		modified.forEachAction(block SimpleConversationAction modAction
			if modAction.getType() != SimpleConversationAction.Type.speak
				return null
			end
			
			while true
				if indexTra >= countTra
					throw EInvalidParam.new("Text count missmatch ({}): '{}'".format(\
						Array.newWith(snippet.getId(), modAction.getText())))
				end
				traAction = translated.getActionAt(indexTra++)
				if traAction.getType() == SimpleConversationAction.Type.speak
					break
				end
			end
			
			if fullTranslationMode
				modAction.setAnimText(traAction.getAnimText())
				
			elif modAction.getAnimText() == null
				modAction.setAnimText(modAction.getText())
			end
			
			modAction.setText(traAction.getText())
		end)
		
		return modified
	end
end
