<xs:schema attributeFormDefault='unqualified'
		elementFormDefault='qualified'
		xmlns:xs='http://www.w3.org/2001/XMLSchema'>
	<xs:annotation>
		<xs:documentation>
			<![CDATA[
			Schema for Drag[en]gine XML Element Class files.
			[Documentation on Wiki](https://developer.dragondreams.ch/wiki/doku.php/dragengine:modules:dragonscript:behavior_elements#xml_element_classes).
			]]>
		</xs:documentation>
	</xs:annotation>
	
	<xs:include schemaLocation='https://lordofdragons.github.io/dragengine/artifacts/xmlschema/dragengine/latest/dragengineTypes.xsd'/>
	
	
	<xs:complexType name='list'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set list property. Lists can contain all other property types in any combination.
				See the game documentation on what values are allowed inside the list.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:element name='string' type='string'/>
			<xs:element name='float' type='float'/>
			<xs:element name='integer' type='integer'/>
			<xs:element name='boolean' type='boolean'/>
			<xs:element name='vector' type='vector'/>
			<xs:element name='vector2' type='vector2'/>
			<xs:element name='point' type='point'/>
			<xs:element name='point3' type='point3'/>
			<xs:element name='borderSize' type='borderSize'/>
			<xs:element name='rectArea' type='rectArea'/>
			<xs:element name='floatRectArea' type='floatRectArea'/>
			<xs:element name='color' type='color'/>
			<xs:element name='null' type='null'/>
			<xs:element name='list' type='list'/>
			<xs:element name='map' type='map'/>
		</xs:choice>
	</xs:complexType>
	
	<xs:simpleType name='map_key'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Key of entry. If entry with the same key is present it is overwritten.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:string'/>
	</xs:simpleType>
	
	<xs:complexType name='map'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set map property. Maps are associative lists storing for each entry a string
				key and a value which can be any other property types. See the game documentation
				on what values are allowed inside the map.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:element name='string'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='string'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='float'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='float'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='integer'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='integer'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='boolean'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='boolean'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='vector'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='vector'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='vector2'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='vector2'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='point'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='point'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='point3'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='point3'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='borderSize'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='borderSize'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='rectArea'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='rectArea'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='floatRectArea'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='floatRectArea'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='color'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='color'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='null'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='null'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='list'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='list'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='map'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='map'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	
	<!-- end definitions modified from parameterTree.xsd -->
	
	
	<xs:simpleType name='property_name'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Name of property.
				<p>
				Element class properties are typically in the form <code>behavior.property</code>
				or <code>behavior(id).property</code>. The identifier is omitted if it is empty
				string. For example the <code>ECBehaviorComponent</code> behavior uses the prefix
				<code>component.</code>. Hence <code>component.model</code> would set the
				<code>model</code> property. The same for an <code>ECBehaviorComponent</code>
				with the identifier second. Here the name would be <code>component(second).model</code>.
				</p>
				<p>
				Inside <code>behavior</code> tag names can be shortened since the prefix used
				by the respective behavior is known. Just remove the behavior property prefix
				from the property name leaving being only the <code>.</code> as first character
				in the name. This way the DragonScript module prepends the behavior property
				prefix while setting the property values. This is easier to write, increases
				readability and has less possibility for errors. It is thus recommended to set
				properties of just added behaviors in this way.
				</p>
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:restriction base='xs:string'/>
	</xs:simpleType>
	
	<xs:group name='node_with_properties'>
		<xs:choice>
			<xs:element name='string'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='string'>
							<xs:annotation>
								<xs:documentation>Set string property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='float'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='float'>
							<xs:annotation>
								<xs:documentation>Set float property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='integer'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='integer'>
							<xs:annotation>
								<xs:documentation>Set integer property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='boolean'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='boolean'>
							<xs:annotation>
								<xs:documentation>Set boolean property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='vector'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='vector'>
							<xs:annotation>
								<xs:documentation>Set vector property.</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='vector2'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='vector2'>
							<xs:annotation>
								<xs:documentation>Set vector2 property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='point'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='point'>
							<xs:annotation>
								<xs:documentation>Set point property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='point3'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='point3'>
							<xs:annotation>
								<xs:documentation>Set point3 property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='borderSize'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='borderSize'>
							<xs:annotation>
								<xs:documentation>Set border size property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='rectArea'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='rectArea'>
							<xs:annotation>
								<xs:documentation>Set rectangular area property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='floatRectArea'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='floatRectArea'>
							<xs:annotation>
								<xs:documentation>Set float rectangular area property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='color'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='color'>
							<xs:annotation>
								<xs:documentation>Set color property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='null'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='null'>
							<xs:annotation>
								<xs:documentation>Set null property</xs:documentation>
							</xs:annotation>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='list'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='list'>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='map'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='map'>
							<xs:attribute type='property_name' name='name' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	
	
	<xs:complexType name='behavior'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Adding behaviors is done using the behavior tag. Some behaviors require additional
				parameters during construction time. These parameters can be defined inside the
				behavior tag using the same tags as you use to define element properties.
				The behavior documentation list the supported parameters. After adding a behavior
				you can set the element properties outside the behavior tag as you usually would do.
				<p>
				To simplify the adding of behaviors properties of a just added behavior can be also
				defined by moving the property tags inside the <code>behavior</code> tag.
				If you do this you have to remove the behavior property prefix from the property
				names leaving being only the <code>.</code> as first character in the name.
				This way the DragonScript module prepends the behavior property prefix while
				setting the property values. This is easier to write, increases readability and
				has less possibility for errors. It is thus recommended to set properties of just
				added behaviors in this way.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:group ref='node_with_properties'/>
		</xs:choice>
		
		<xs:attribute type='xs:string' name='type' use='required'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Type of behavior to add. This is the name of the behavior script class
					(for example <code>ECBehaviorComponent</code>).
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:string' name='id' use='optional'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Identifier unique amongst all behaviors of the same type. If not set empty
					string is used as identifier.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	
	
	<xs:complexType name='elementClass'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Drag[en]gine XML Element Class.
				[Documentation on Wiki](https://developer.dragondreams.ch/wiki/doku.php/dragengine:modules:dragonscript:behavior_elements#xml_element_classes).
				<p>
				XML Element classes allow to create new element classes using an XML file
				(<code>*.deeclass</code>) instead of writing script code. XML element classes
				always subclass from an existing script class or XML element class. Using an
				XML element class you can change properties added by the behavior definitions.
				</p>
				<p>
				Element class properties are typically in the form <code>behavior.property</code>
				or <code>behavior(id).property</code>. The identifier is omitted if it is empty
				string. For example the <code>ECBehaviorComponent</code> behavior uses the prefix
				<code>component.</code>. Hence <code>component.model</code> would set the
				<code>model</code> property. The same for an <code>ECBehaviorComponent</code>
				with the identifier second. Here the name would be <code>component(second).model</code>.
				</p>
				<p>
				Behaviors can be complex and nested. This allows behaviors to add other behaviors
				to achieve their goals. Such nested behaviors need to be differentiated from
				other behaviors of the same kind. The rule is to prefix the property names of the
				behaviors with their parent prefix to make them unique. For example if you have a
				fictional behavior MyBehavior with the prefix mybehavior. which adds one or more
				<code>ECBehaviorComponent</code> then the property names of those component
				behaviors would look like </code>mybehavior.component.model</code> or
				<code>mybehavior.component(second).model</code>. This nesting can go deeper
				depending on how complex of a behavior you are designing. In general it is
				favorable to keep the nesting as little as possible as this is easier to use for
				team members and modders.
				</p>
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:group ref='node_with_properties'/>
			<xs:element type='behavior' name='behavior'/>
		</xs:choice>
		
		<xs:attribute type='xs:string' name='name' use='required'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Name of the element class to define. Name has to be unique across all
					element class no matter if scripted or XML defined. The name can use any
					character but it is recommended to use only <code>A-Z</code>,
					<code>a-z</code>, <code>0-9</code> and <code>_</code>.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:string' name='class' use='required'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Name of the element class to subclass. Name has to be an existing script
					class or another XML defined class.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	
	<xs:element name='elementClass' type='elementClass'>
	</xs:element>
</xs:schema>
