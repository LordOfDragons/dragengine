<?xml version='1.0' encoding='utf-8'?>
<xs:schema attributeFormDefault='unqualified'
		elementFormDefault='qualified'
		xmlns:xs='http://www.w3.org/2001/XMLSchema'>
	<xs:annotation>
		<xs:documentation>
			<![CDATA[
			Schema for Drag[en]gine Parameter Tree XML files.
			]]>
		</xs:documentation>
	</xs:annotation>
	
	<xs:simpleType name='parameter_path'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Path of parameter to set. Path separater is chosen by application but typically
				it is <code>/</code>. Do not begin with <code>/</code> since this is no file system path.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:string'/>
	</xs:simpleType>
	
	<xs:complexType name='string'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set string parameter. Value is tag text content.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:simpleContent>
			<xs:extension base='xs:string'/>
		</xs:simpleContent>
	</xs:complexType>
	
	<xs:complexType name='float'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set floating point parameter. Value is tag text content.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:simpleContent>
			<xs:extension base='xs:float'/>
		</xs:simpleContent>
	</xs:complexType>
	
	<xs:complexType name='integer'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set integer point parameter. Value is tag text content.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:simpleContent>
			<xs:extension base='xs:integer'/>
		</xs:simpleContent>
	</xs:complexType>
	
	<xs:complexType name='boolean'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set boolean point parameter. Value is tag text content.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:simpleContent>
			<xs:extension base='xs:boolean'/>
		</xs:simpleContent>
	</xs:complexType>
	
	<xs:simpleType name='vector_x'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				X component of vector. If not set defaults to 0.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:float'/>
	</xs:simpleType>
	
	<xs:simpleType name='vector_y'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Y component of vector. If not set defaults to 0.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:float'/>
	</xs:simpleType>
	
	<xs:simpleType name='vector_z'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Z component of vector. If not set defaults to 0.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:float'/>
	</xs:simpleType>
	
	<xs:complexType name='vector'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set 3-component floating point vector parameter.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:attribute type='vector_x' name='x' use='optional' default='0'/>
		<xs:attribute type='vector_y' name='y' use='optional' default='0'/>
		<xs:attribute type='vector_z' name='z' use='optional' default='0'/>
	</xs:complexType>
	
	<xs:complexType name='vector2'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set 2-component floating point vector parameter.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:attribute type='vector_x' name='x' use='optional' default='0'/>
		<xs:attribute type='vector_y' name='y' use='optional' default='0'/>
	</xs:complexType>
	
	<xs:simpleType name='point_x'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				X component of point. If not set defaults to 0.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:integer'/>
	</xs:simpleType>
	
	<xs:simpleType name='point_y'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Y component of point. If not set defaults to 0.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:integer'/>
	</xs:simpleType>
	
	<xs:simpleType name='point_z'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Z component of point. If not set defaults to 0.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:integer'/>
	</xs:simpleType>
	
	<xs:complexType name='point'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set 2-component integer point parameter.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:attribute type='point_x' name='x' use='optional' default='0'/>
		<xs:attribute type='point_y' name='y' use='optional' default='0'/>
	</xs:complexType>
	
	<xs:complexType name='point3'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set 3-component integer point parameter.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:attribute type='point_x' name='x' use='optional' default='0'/>
		<xs:attribute type='point_y' name='y' use='optional' default='0'/>
		<xs:attribute type='point_z' name='z' use='optional' default='0'/>
	</xs:complexType>
	
	<xs:complexType name='borderSize'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set 4-component integer border size parameter. Border size defines a border
				around an area. This can be done either using the <code>all</code> attribute to set all
				borders to the same value or setting the borders individually using <code>left</code>,
				<code>top</code>, <code>right</code> and <code>bottom</code>.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:attribute type='xs:integer' name='all' use='optional'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set left, top, right and bottom border to the same value in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='left' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set left border to value in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='top' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set top border to value in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='right' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set right border to value in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='bottom' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set bottom border to value in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	
	<xs:complexType name='rectArea'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set 4-component integer rectangular area parameter. Area is define as
				upper left (inclusive) and lower right (exclusive) corner.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:attribute type='xs:integer' name='x1' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set X coordinate of upper left corner in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='y1' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set Y coordinate of upper left corner in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='x2' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set X coordinate of lower right corner in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='y2' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set Y coordinate of lower right corner in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	
	<xs:complexType name='floatRectArea'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set 4-component floating point rectangular area parameter. Area is define as
				upper left (inclusive) and lower right (exclusive) corner.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:attribute type='xs:float' name='x1' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set X coordinate of upper left corner in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:float' name='y1' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set Y coordinate of upper left corner in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:float' name='x2' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set X coordinate of lower right corner in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:float' name='y2' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set Y coordinate of lower right corner in pixels.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	
	<xs:complexType name='color'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set color parameter with optional transparency value. Colors can be defined
				using multiple ways depending what is easier to use for the situation.
				<p>
				Define color as floating point components in the range from 0 (black) to 1 (white).
				For this use the attributes <code>r</code>, <code>g</code>, <code>b</code> and <code>a</code>.
				</p>
				<p>
				Define color as integer components in the range from 0 (black) to 255 (white).
				For this use the attributes <code>ir</code>, <code>ig</code>, <code>ib</code>, <code>ia</code>.
				</p>
				<p>
				Define color as string hexadecimal value. For this use the attribute <code>hex</code>.
				</p>
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:attribute type='xs:float' name='r' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set red floating point component in the range from 0 (black) to 1 (white).
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:float' name='g' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set green floating point component in the range from 0 (black) to 1 (white).
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:float' name='b' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set blue floating point component in the range from 0 (black) to 1 (white).
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:float' name='a' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set alpha floating point component in the range from 0 (transparent) to 1 (solid).
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='ir' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set red integer component in the range from 0 (black) to 255 (white).
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='ig' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set green integer component in the range from 0 (black) to 255 (white).
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='ib' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set blue integer component in the range from 0 (black) to 255 (white).
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute type='xs:integer' name='ia' use='optional' default='0'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Set alpha integer component in the range from 0 (transparent) to 255 (solid).
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		
		<xs:attribute name='hex' use='optional' default='000000'>
			<xs:simpleType>
				<xs:restriction base='xs:string'>
					<xs:annotation>
						<xs:documentation>
							<![CDATA[
							Set color using dexadecimal string in the form <code>RRGGBB</code> or <code>RRGGBBAA</code>
							where each component is in the range from <code>00</code> to <code>FF</code>. Both upper and
							lower case letters are supported.
							]]>
						</xs:documentation>
					</xs:annotation>
					<xs:pattern value='([0-9a-fA-F][0-9a-fA-F]){3,4}'></xs:pattern>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	
	<xs:simpleType name='enum_curve_interpolation' final='restriction'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set interpolation mode.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:string'>
			<xs:enumeration value='constant'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Constant interpolation. Control points composes of a position only.
						Curve keeps same Y coordinate until the X coordinate of the next
						control point is reached then jumps to the new Y coordinate.
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value='linear'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Linear interpolation. Control points composes of a position only.
						Curves is piecewise linear between control points.
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value='bezier'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Bezier interpolation. Control points composes of a position and two
						handles with the curve smoothly interpolated between control points.
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	
	<xs:complexType name='curve_point'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Curve control point.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:element name='coordinates' type='vector2'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Set control point position as 2-component floating point vector.
						<p>
						If not set defaults to 0-vector.
						</p>
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			
			<xs:element name='handle1' type='vector2'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Set control point left side handle as 2-component floating point vector.
						This is the handle controling how the curve flows into the control point
						from the direction of the previous one.
						<p>
						Only used for <code>bezier</code> type <code>interpolation</code>.
						</p>
						<p>
						If not set defaults to the value of <code>coordinates</code>.
						</p>
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			
			<xs:element name='handle2' type='vector2'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Set control point right side handle as 2-component floating point vector.
						This is the handle controling how the curve flows out of the control
						point towards the next control point.
						<p>
						Only used for <code>bezier</code> type <code>interpolation</code>.
						</p>
						<p>
						If not set defaults to the value of <code>coordinates</code>.
						</p>
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	
	<xs:complexType name='curve'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set 2-dimensional curve parameter. Curves compose of a series of control points.
				Control points composes of a position and two handles. The handles are only used
				if <code>bezier</code> interpolation is used. With <code>constant</code> the same value is used from
				the starting coordinates up to but excluding the coordinates of the next point.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:element name='interpolation' type='enum_curve_interpolation'/>
			<xs:element name='point' type='curve_point'/>
		</xs:choice>
	</xs:complexType>
	
	<xs:simpleType name='enum_curve3d_interpolation' final='restriction'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set interpolation mode.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:string'>
			<xs:enumeration value='constant'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Constant interpolation. Control points composes of a position only.
						Curve evaluates only to the last passed through control point.
						This is best used for situations where objects are only supposed to
						be placed in very specific locations across the curve. Moving over
						a control point teleports to the just passed control point position.
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value='linear'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Linear interpolation. Control points composes of a position only.
						Curves is piecewise linear between control points.
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value='bezier'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Bezier interpolation. Control points composes of a position and two
						handles with the curve smoothly interpolated between control points.
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	
	<xs:complexType name='curve3d_point'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Curve control point.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:element name='coordinates' type='vector'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Set control point position as 3-component floating point vector.
						<p>
						If not set defaults to 0-vector.
						</p>
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			
			<xs:element name='handle1' type='vector'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Set control point left side handle as 3-component floating point vector.
						This is the handle controling how the curve flows into the control point
						from the direction of the previous one.
						<p>
						Only used for <code>bezier</code> type <code>interpolation</code>.
						</p>
						<p>
						If not set defaults to the value of <code>coordinates</code>.
						</p>
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			
			<xs:element name='handle2' type='vector'>
				<xs:annotation>
					<xs:documentation>
						<![CDATA[
						Set control point right side handle as 3-component floating point vector.
						This is the handle controling how the curve flows out of the control
						point towards the next control point.
						<p>
						Only used for <code>bezier</code> type <code>interpolation</code>.
						</p>
						<p>
						If not set defaults to the value of <code>coordinates</code>.
						</p>
						]]>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	
	<xs:complexType name='curve3d'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set 3-dimensional curve parameter. Curves compose of a series of control points.
				Control points composes of a position and two handles. The handles are only used
				if <code>bezier</code> interpolation is used. With <code>constant</code> the same value is used from
				the starting coordinates up to but excluding the coordinates of the next point.
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:element name='interpolation' type='enum_curve3d_interpolation'/>
			<xs:element name='point' type='curve3d_point'/>
		</xs:choice>
	</xs:complexType>
	
	<xs:complexType name='null'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set null parameter. This tag is typically used to clear a previously set
				parameter or to explicitely mark a value as having no value (null value).
				]]>
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	
	<xs:complexType name='list'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set list parameter. Lists can contain all other parameter types in any combination.
				See the game documentation on what values are allowed inside the list.
				<p>
				Lists support appending values by using the <code>append</code> attribute. Append can be
				used only if the list is not located in a list.
				</p>
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:element name='string' type='string'/>
			<xs:element name='float' type='float'/>
			<xs:element name='integer' type='integer'/>
			<xs:element name='boolean' type='boolean'/>
			<xs:element name='vector' type='vector'/>
			<xs:element name='vector2' type='vector2'/>
			<xs:element name='point' type='point'/>
			<xs:element name='point3' type='point3'/>
			<xs:element name='borderSize' type='borderSize'/>
			<xs:element name='rectArea' type='rectArea'/>
			<xs:element name='floatRectArea' type='floatRectArea'/>
			<xs:element name='color' type='color'/>
			<xs:element name='curve' type='curve'/>
			<xs:element name='curve3d' type='curve3d'/>
			<xs:element name='null' type='null'/>
			<xs:element name='list' type='list'/>
			<xs:element name='map' type='map'/>
			<xs:element name='tree' type='parameterTree'/>
			<xs:element name='treeFile' type='treeFile'/>
		</xs:choice>
		
		<xs:attribute name='append' use='optional'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Append to list if present (attribute value does not matter).
					<p>
					If the list parameter does not exist it is created with the
					specified list content. If the list parameter does exist the specified
					list content is appended to the existing list.
					</p>
					<p>
					Append mode is useful for game modifications to extend existing
					lists for example to add more objects a player can use. Append mode is
					also useful without game modifications to allow storing parameter trees
					for individual game components combining the values together. This
					makes developing complex game content easier.
					</p>
					]]>
				</xs:documentation>
			</xs:annotation>
			
			<xs:simpleType>
				<xs:restriction base='xs:string'>
					<xs:pattern value=''></xs:pattern>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	
	<xs:simpleType name='map_key'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Key of entry. If entry with the same key is present it is overwritten.
				]]>
			</xs:documentation>
		</xs:annotation>
		<xs:restriction base='xs:string'/>
	</xs:simpleType>
	
	<xs:complexType name='map'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Set map parameter. Maps are associative lists storing for each entry a string
				key and a value which can be any other parameter types. See the game documentation
				on what values are allowed inside the map.
				<p>
				Maps support adding values by using the <code>append</code> attribute. Append can be
				used only if the map is not located in a list.
				</p>
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:element name='string'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='string'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='float'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='float'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='integer'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='integer'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='boolean'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='boolean'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='vector'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='vector'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='vector2'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='vector2'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='point'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='point'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='point3'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='point3'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='borderSize'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='borderSize'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='rectArea'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='rectArea'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='floatRectArea'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='floatRectArea'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='color'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='color'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='curve'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='curve'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='curve3d'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='curve3d'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='null'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='null'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='list'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='list'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='map'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='map'>
							<xs:attribute type='map_key' name='key' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='tree'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='parameterTree'>
							<xs:attribute type='map_key' name='key' use='required'/>
							<xs:attribute type='tree_append' name='append' use='optional'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='treeFile'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='treeFile'>
							<xs:attribute type='map_key' name='key' use='required'/>
							<xs:attribute type='tree_append' name='append' use='optional'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
		
		<xs:attribute name='append' use='optional'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Append to map if present (attribute value does not matter).
					<p>
					If the map parameter does not exist it is created with
					the specified map content. If the mapt parameter does exist the
					specified map content is added to the existing map overwriting existing
					values with same keys.
					</p>
					<p>
					Append mode is useful for game modifications to extend existing
					maps for example to add more objects a player can use. Append mode is
					also useful without game modifications to allow storing parameter trees
					for individual game components combining the values together. This
					makes developing complex game content easier.
					</p>
					]]>
				</xs:documentation>
			</xs:annotation>
			
			<xs:simpleType>
				<xs:restriction base='xs:string'>
					<xs:pattern value=''></xs:pattern>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	
	<xs:simpleType name='tree_append' final='restriction'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Append to tree if present (attribute value does not matter).
				<p>
				If the tree parameter does not exist it is created with
				the specified tree content. If the tree parameter does exist the
				specified tree content is added to the existing tree overwriting existing
				parameters with same path.
				</p>
				<p>
				Append mode is useful for game modifications to extend existing
				trees for example to add more objects a player can use. Append mode is
				also useful without game modifications to allow storing parameter trees
				for individual game components combining the values together. This
				makes developing complex game content easier.
				</p>
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:restriction base='xs:string'>
			<xs:pattern value=''></xs:pattern>
		</xs:restriction>
	</xs:simpleType>
	
	<xs:complexType name='treeFile'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Load parameter tree from file. Path can be relative to the directory this
				parameter tree file is located in.
				<p>
				Parameter trees support adding values by using the <code>append</code> attribute.
				Append can be used only if the parameter tree is not located in a list.
				</p>
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:simpleContent>
			<xs:extension base='xs:string'/>
		</xs:simpleContent>
	</xs:complexType>
	
	<xs:complexType name='parameterTree'>
		<xs:annotation>
			<xs:documentation>
				<![CDATA[
				Parameter Tree.
				<p>
				Parameter trees support adding values by using the <code>append</code> attribute.
				Append can be used only if the parameter tree is not located in a list and
				is not the root element.
				</p>
				]]>
			</xs:documentation>
		</xs:annotation>
		
		<xs:choice minOccurs='0' maxOccurs='unbounded'>
			<xs:element name='string'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='string'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='float'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='float'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='integer'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='integer'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='boolean'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='boolean'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='vector'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='vector'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='vector2'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='vector2'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='point'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='point'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='point3'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='point3'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='borderSize'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='borderSize'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='rectArea'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='rectArea'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='floatRectArea'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='floatRectArea'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='color'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='color'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='curve'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='curve'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='curve3d'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='curve3d'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='null'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='null'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='list'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='list'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='map'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='map'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='tree'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='parameterTree'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
							<xs:attribute type='tree_append' name='append' use='optional'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			
			<xs:element name='treeFile'>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base='treeFile'>
							<xs:attribute type='parameter_path' name='path' use='required'/>
							<xs:attribute type='tree_append' name='append' use='optional'/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
		
		<xs:attribute name='pathPrefix' type='xs:string' use='optional'>
			<xs:annotation>
				<xs:documentation>
					<![CDATA[
					Prefix to prepend to all parameter path.
					]]>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	
	<xs:element name='parameterTree' type='parameterTree'>
	</xs:element>
</xs:schema>
